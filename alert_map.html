<div id="civix-neo">
    {{styleshtml}}
    <style>
        .layer-controls {
            background: var(--panel);
            border: 1px solid var(--teal);
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .layer-control-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(34,230,217,0.2);
        }
        
        .layer-control-item:last-child {
            border-bottom: none;
        }
        
        .layer-control-item input[type="checkbox"] {
            margin-right: 8px;
            accent-color: var(--teal);
        }
        
        .layer-control-item label {
            color: var(--ink);
            font-size: 14px;
            cursor: pointer;
        }
    </style>
  <div class="splash" id="splash">
    <h2 style="color:var(--ink-strong)">M√≥dulo de Alertas</h2>
    <button id="enter" class="btn btn-accent">Ingresar al Dashboard</button>
  </div>

  <div class="top-right" id="controls">
    <button id="exit" class="btn btn-accent">Salir de pantalla completa</button>
    <div class="selected-persons-map-panel" id="selected-persons-map-panel">
        <div class="selected-persons-map-body" id="selected-persons-map-body">
            <div class="selection-placeholder">No hay personas seleccionadas</div>
        </div>
    </div>
</div>

  <div id="dashboard">
    <div class="grid">

      <div class="panel">
            <div class="tabs-container">
                <div class="tabs-header">
                    <button class="tab-button active" data-tab="kpi">KPI's</button>
                    <button class="tab-button" data-tab="busqueda">B√∫squeda</button>
                </div>

                <div class="tabs-content">
                    <!-- Pesta√±a 1: Personas de Inter√©s -->
                    <div class="tab-pane active" id="tab-kpi">
                        <div id="kpiContent">
                            <div class="kpi-header">
                                <h3>KPIs</h3>
                                <span id="kpi-timestamp" style="font-size: 12px; color: var(--ink);"></span>
                            </div>

                            <div class="kpi-grid">
                                <!-- El resto del contenido permanece igual -->
                                <div class="kpi-card">
                                    <div style="display:flex;justify-content:space-between;align-items:center;">
                                        <h3 class="kpi-title">Total Alertas</h3>
                                        <h3 class="kpi-value" id="total-alerts">0</h3>
                                    </div>
                                </div>

                                <!-- Gr√°fico de Tendencia -->
                                <div class="kpi-card">
                                  <h3 class="kpi-title">Tendencia (4h)</h3>
                                  <div id="trend-chart-container" class="bar-chart-container">
                                    <div class="loading">Cargando tendencia...</div>
                                  </div>
                                </div>

                                <button id="clear-filters-btn" class="clear-filters-btn" disabled>Limpiar Filtros</button>

                                <div class="kpi-card">
                                  <h3 class="kpi-title">Top Tipos de Alertas</h3>
                                  <div id="alert-type-metrics" class="bar-chart-container">
                                    <div class="loading">Cargando...</div>
                                  </div>
                                </div>

                                <div class="kpi-card">
                                  <h3 class="kpi-title">Top C√°maras</h3>
                                  <div id="camera-metrics" class="bar-chart-container">
                                    <div class="loading">Cargando...</div>
                                  </div>
                                </div>
                              </div>
                        </div>
                    </div>

                    <!-- Pesta√±a 2: Veh√≠culos -->
                    <div class="tab-pane" id="tab-busqueda">
                        <div id="busquedaContent">
                            <div id="selected-persons-container" style="margin-bottom:20px; border-top: 1px solid rgba(34,230,217,0.2); padding-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <h4 style="color: var(--teal); margin: 0;">Lista de Inter√©s</h4>
                                    <button type="button" class="btn btn-default" data-search-type="personas-interes"
                                            style="padding: 8px 12px; font-size: 12px;">
                                        Seleccionar
                                    </button>
                                </div>
                                <div id="current-selections-list">
                                    <!-- Las selecciones se cargar√°n aqu√≠ din√°micamente -->
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: auto; gap: 10px; margin-bottom: 15px;">
                                <button type="button" class="btn btn-default" data-search-type="personas">
                                    B√∫squeda de Personas
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="vehiculos">
                                    B√∫squeda de Veh√≠culos
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="placa">
                                    B√∫squeda por placa de Veh√≠culos
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="caracteristicas">
                                    B√∫squeda por Caracter√≠sticas
                                </button>
                            </div>

                            <!-- Por este: -->
                            <div id="selectedPersonBox" style="display: none; background: var(--panel); padding: 12px; margin-bottom: 12px; border-radius: 8px; border: 1px solid rgba(34,230,217,0.2);">
                                <div id="selectedPersonDetails"></div>
                            </div>
                            <!-- Formulario de b√∫squeda por placa -->
                            <div id="placa-search-form" class="search-form" style="display: none;">
                                <h4>B√∫squeda por Placa</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                    <input type="text" id="placa-input" placeholder="Ingrese n√∫mero de placa"
                                           style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
                                    <button type="button" class="btn btn-accent" id="search-placa-btn">Buscar</button>
                                </div>
                                <div id="placa-results"></div>
                            </div>

                            <!-- Formulario de b√∫squeda por caracter√≠sticas -->
                            <div id="caracteristicas-search-form" class="search-form" style="display: none;">
                                <h4>B√∫squeda por Caracter√≠sticas</h4>
                                <div>
                                    <small>*Los campos son requeridos</small>
                                </div>
                                <div style="display: grid; grid-template-columns: 48% 48%; gap: 10px; margin-bottom: 15px;">
                                    <div>
                                        <label for="txtFechaIni">Fecha Inicio*</label>
                                        <div class="form-group ">
                                            <input id="txtFechaIni" type="datetime-local" class="form-control">
                                        </div>
                                    </div>

                                    <div>
                                        <label for="txtFechaFin">Fecha Fin*</label>
                                        <div class="form-group ">
                                            <input id="txtFechaFin" type="datetime-local" class="form-control">
                                        </div>
                                    </div>
                                    <div>
                                        <div class=form-group>
                                            <label>Color Prenda Superior*</label>
                                            <select id="txtcolorsup" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <div class=form-group>
                                            <label>Color Prenda Inferior</label>
                                            <select id="txtcolorinf" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label>Edad</label>
                                        <div class=form-group>
                                            <select id="txtedad" class="form-control">
                                                <option value="all" selected>Seleccione Rango</option>
                                                <option value=0>0-2 a√±os</option>
                                                <option value=1>3-6 a√±os</option>
                                                <option value=2>7-13 a√±os</option>
                                                <option value=3>14-22 a√±os</option>
                                                <option value=4>23-35 a√±os</option>
                                                <option value=5>36-46 a√±os</option>
                                                <option value=6>47-56 a√±os</option>
                                                <option value=7>57-100 a√±os</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label>Sexo</label>
                                        <div class=form-group>
                                            <select id="txtsexo" class="form-control">
                                                <option value="all" selected>Seleccione sexo</option>
                                                <option value=0>Mujer</option>
                                                <option value=1>Hombre</option>
                                            </select>
                                        </div>
                                    </div>
                                    <!--
                                    <div style="grid-column: 1 / span 2;">
                                        <label>Zonas/Subzonas</label>
                                        <div class="form-group">
                                            <button type="button" class="btn btn-default" id="btnSeleccionarZonas"
                                                    style="width: 100%; text-align: left; background: var(--panel); border: 1px solid var(--teal); color: var(--ink); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                                Seleccionar Zonas/Subzonas
                                            </button>
                                            <div id="zonas-seleccionadas" style="margin-top: 5px; font-size: 12px; color: var(--ink);">
                                                No hay zonas seleccionadas
                                            </div>
                                        </div>
                                    </div>
                                    -->
                                </div>
                                <button type="button" class="btn btn-accent" id="search-caracteristicas-btn" style="width: 100%;">Buscar por Caracter√≠sticas</button>
                                <div id="caracteristicas-results" style="margin-top: 15px;"></div>
                            </div>

                            <!-- Contenedor para resultados de listas (personas/veh√≠culos) -->
                            <div id="search-results"></div>

                            <!-- NUEVO: Contenedor de personas seleccionadas en la parte inferior -->

                        </div>
                    </div>
                </div>
            </div>
        </div>
      <div class="panel">
          <h3 id="title-panel">Alertas en tiempo real (√öltimas 4 horas)</h3>
            <div style="margin-bottom: 1em;">
                <button id="btnBackToAll" class="btn btn-accent" style="width: 100%; display: none;">Volver a todas las alertas</button>
            </div>
            <div id="data-spinner" style="text-align:center;margin:2em; display:none">
                <div class="spinner"></div>
                <div>Cargando...</div>
            </div>
          <ul class="timeline" id="timelineList">
            <div>
            </div>
          </ul>
        </div>
      <div class="panel" style="position:relative">
            <!-- A√ëADE map-id con tu Map ID real -->
            <gmp-map-3d
                id="map"
                map-id="df090e50125b4144ce6d7b11"
                mode="SATELLITE" center="-12.119264, -77.029081" altitude="0"
                range="1500"
                tilt="45"
                heading="0"
                style="width: 100%; height: 100%;"
            >
                </gmp-map-3d>

            <div class="map-legend" id="map-legend">
              <div class="legend-header">
                <div class="legend-title">Filtrar alertas</div>
                <button class="legend-toggle">‚àí</button>
              </div>
              <div class="legend-body">
                <div class="loading">Cargando leyenda...</div>
              </div>
            </div>
          <div class="alert-details-panel" id="alert-details">
            <div class="alert-details-header">
              <h4 class="alert-details-title" id="alert-details-title">Detalles de Alerta</h4>
              <button class="close-details">&times;</button>
            </div>
            <div class="alert-details-content" id="alert-details-content">
              <!-- Contenido generado din√°micamente -->
            </div>
            <div class="alert-details-footer">
              <button id="view-video-btn" class="btn btn-accent">Ver Video <span class="pe-7s-play"></span></button>
            </div>
          </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="ovl" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="hdr">
        <h4 id="mtitle">Detalle de alerta</h4>
        <span class="x" id="mclose">&times;</span>
      </div>
      <div id="mbody">...</div>
    </div>
  </div>

  <div class="overlay" id="interesOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="interesModalTitle">B√∫squeda Avanzada - Personas de Inter√©s</h4>
                </div>
                <div class="modal-body">
                    <!-- Contenido directo sin pesta√±as -->
                    <div id="interesModalContent">
                        <div class="loading">Cargando personas de inter√©s...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="closeInteresModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Nuevo modal para selecci√≥n m√∫ltiple -->
    <div class="overlay" id="multiSelectOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="multiSelectModalTitle">Selecci√≥n de Inter√©s</h4>
                </div>
                <div class="modal-body">
                    <div id="multiSelectModalContent" style="width:100%">
                        <div class="loading">Cargando personas de inter√©s...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="saveMultiSelection">Guardar Selecci√≥n</button>
                    <button type="button" class="btn btn-default btn-rounded" id="closeMultiSelectModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para mostrar videos -->
    <div class="overlay" id="videoOvl" aria-hidden="true" style="display: none;">
      <div class="modal-video" role="dialog" aria-modal="true">
        <div class="modal-content">
          <div class="modal-header text-left" style="display: flex;justify-content: space-between;">
              <div style="width:100%">
                <span class="c-white" style="float:right" id="showtime"></span>
                <h3>Identificador: <span class="c-white" id="showId"></span></h3>
                <h5>Tipo: <span class="c-white" id="showAlert"></span></h5>
                <h5>C√°mara: <span class="c-white" id="showcamera"></span></h5>
                <h5>Ubicaci√≥n: <span class="c-white" id="showUbication"></span></h5>
                <div id="showlocation"></div>
              </div>
            <div id="photo-short">
                  <div class="image-section" style="overflow:hidden;">
                    <div class="image-label">Detecci√≥n Recortada</div>
                    <div class="image-container" id="cropped-detection"></div>
                  </div>
                  <div class="image-section" id="photo-name" >
                    <div class="image-label">Foto de Referencia</div>
                    <div class="image-container" id="person-photo"></div>
                  </div>
              </div>
          </div>

          <div class="modal-body">
            <div class="video-player-wrapper" style="height:400px;"></div>
            <div class="person-info-panel" id="person-info-panel" style="display: none;">
              <h4>Detecci√≥n</h4>
              <div id="person-data" style=""></div>
            </div>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-default btn-rounded" id="closeVideoModal">Cerrar</button>
          </div>
        </div>
      </div>
    </div>
</div>

<script>
    
    let alertas = [];
    let openPopovers = new Map(); // Almacena coordenadas -> estado del popover
    let popoversToRestore = new Set();

    let alertasInterval = null;
    let frameInterval = null; // Intervalo para obtainLastFrame
    let busqueda = null;
    let showCameras = false;
    let showPisos = true;
    let showAmbientes = true;
    let showSubzonesText = false; // NUEVO: Control para texto de subzonas
    let showRoutes = true;
    let currentTab = 'personas';

    let multiSelectedItems = [];
    
    let Marker3DInteractiveElement, PopoverElement, PinElement; // A√±adir PinElement aqu√≠
    
    let currentlyOpenPopover = null; // Referencia al popover actualmente abierto
    let previousAlertCoordinates = new Set(); // Para trackear coordenadas anteriores

    // ==========================
    // Variables para tracking de offset del canvas
    // ==========================
    let canvasOffsetX = 0;
    let canvasOffsetY = 0;
    let canvasScaleX = 1;
    let canvasScaleY = 1;
    
    let activeAlertTimers = {};

    // ==========================
    // Variables para controlar el estado de b√∫squeda
    // ==========================
    let selectedInteresItem = null;
    let nuevasAlertas = [];

    // ==========================
    // Variables para controlar el estado de b√∫squeda
    // ==========================
    let currentSearchType = null; // 'placa', 'caracteristicas', 'interes', null
    let currentSearchResults = null;

    // ==========================
    // Variables para KPI est√°tico
    // ==========================
    let initialAlerts = []; // Almacena las alertas iniciales (sin filtros)
    let lastKPUpdate = null; // Timestamp de √∫ltima actualizaci√≥n de KPIs
    let kpiTrendData = []; // Datos para el gr√°fico de tendencia
    
    // ==========================
    // DOM Element Caching for Optimization
    // ==========================
    const domCache = {
        titlePanel: document.getElementById('title-panel'),
        selectedPersonBox: document.getElementById('selectedPersonBox'),
        btnBackToAll: document.getElementById('btnBackToAll'),
        caracteristicasResults: document.getElementById('caracteristicas-results'),
        alertDetails: document.getElementById('alert-details'),
        searchResults: document.getElementById('search-results'),
        map: document.getElementById('map'),
        interesModalContent: document.getElementById('interesModalContent'),
        placaSearchForm: document.getElementById('placa-search-form'),
        multiSelectOvl: document.getElementById('multiSelectOvl')
    };
    const videoOvl = document.getElementById('videoOvl');
    const closeVideoModalBtn = document.getElementById('closeVideoModal');

    const interesOvl = document.getElementById('interesOvl');
    const closeinteresOvlBtn = document.getElementById('closeInteresModal');
    
    // Variables globales para tracking de c√°mara seleccionada
    let currentlySelectedCamera = null;
    let currentlySelectedMarker = null;
    
    // A√±adir estas variables globales (al inicio con las otras variables)
    let currentRoute = null;
    let routeAnimationProgress = 0;
    let routeAnimationInterval = null;
    let routeCoordinates = [];
    let currentRouteType = null; // 'person' o 'vehicle'
    
    let suspendAutoMarkers = false;
    
    let cameraUpdateIntervals = new Map();

    // Modificar la funci√≥n showInteresModal para aceptar el tipo de b√∫squeda
    function showInteresModal(searchType) {
        // Establecer el tipo de b√∫squeda activa
        currentSearchType = searchType;
        const modal = document.getElementById('interesOvl');
        modal.style.display = 'flex';

        // Cambiar el t√≠tulo seg√∫n el tipo de b√∫squeda
        const title = document.getElementById('interesModalTitle');
        if (title) {
            if (searchType === 'personas') {
                title.textContent = 'B√∫squeda de Personas de Inter√©s';
            } else if (searchType === 'vehiculos') {
                title.textContent = 'B√∫squeda de Veh√≠culos de Inter√©s';
            } else {
                title.textContent = 'B√∫squeda Avanzada';
            }
        }

        // Cargar directamente la lista correspondiente
        if (searchType === 'personas') {
            loadInteresList();
        } else if (searchType === 'vehiculos') {
            loadVehicleList();
        }
    }

    // Funci√≥n simplificada para cargar veh√≠culos
    function loadVehicleList() {
        const container = domCache.interesModalContent;
        container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de veh√≠culos...</div></div>';

        callAPI({
            method: 'gestion/get_vehiculos_lista',
            ok: function(data) {
                interesDataVehicle = data;
                renderInteresList(data, container, 2);
            },
            error: function(error) {
                log("Error al cargar la lista de veh√≠culos:", error);
                container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
            }
        });
    }

    // Funci√≥n para cerrar el modal de inter√©s
    function closeInteresModal() {
        const modal = document.getElementById('interesOvl');
        modal.style.display = 'none';

        // Resetear a la pesta√±a de personas para la pr√≥xima apertura
        setTimeout(() => {
            switchTab('busqueda');
        }, 300);
    }

    // Event listeners para cerrar el modal
    document.getElementById('closeInteresModal').addEventListener('click', closeInteresModal);
    document.getElementById('interesOvl').addEventListener('click', function(e) {
        if (e.target === this) {
            closeInteresModal();
        }
    });

    function showVideoModal() {
      videoOvl.style.display = 'flex';
    }

    function closeVideoModal() {
      videoOvl.style.display = 'none';

      if (videoPlayer) {
        try {
          videoPlayer.stop();
        } catch (e) {
          log("Error al detener video player:", e);
        }
        videoPlayer = null;
      }
    }

    // Event listeners para el modal de video
    closeVideoModalBtn.addEventListener('click', closeVideoModal);
    closeinteresOvlBtn.addEventListener('click', closeInteresModal);
    videoOvl.addEventListener('click', (e) => {
      if (e.target === videoOvl) {
        closeVideoModal();
      }
    });
    interesOvl.addEventListener('click', (e) => {
      if (e.target === interesOvl) {
        closeInteresModal();
      }
    });

    // Cargar API de Google Maps de forma controlada
    async function loadGoogleMaps() {
        return new Promise((resolve, reject) => {
            if (window.google && window.google.maps) {
                log('‚úÖ Google Maps ya est√° cargado');
                // Verificar si Directions Service est√° disponible
                if (isDirectionsServiceAvailable()) {
                    log('‚úÖ Directions Service disponible');
                } else {
                    log('‚ö†Ô∏è Directions Service no disponible');
                }
                resolve();
                return;
            }
    
            const mapId = 'df090e50125b4144ce6d7b11';
    
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyCFYX7xdnzANmkTDUN38FsYV7U0BSaZczM&loading=async&libraries=maps3d,marker,geometry&v=beta&map_ids=${mapId}&callback=initMap`;
            script.async = true;
            script.defer = true;
    
            script.onload = () => {
                resolve();
            };
    
            script.onerror = () => {
                reject(new Error("Error al cargar Google Maps Platform API"));
            };
    
            document.head.appendChild(script);
        });
    }

    $(document).ready(function() {

        // Inicializar fechas por defecto
        const hoy = new Date();
        const ayer = new Date(hoy);
        ayer.setDate(hoy.getDate() - 1);
        (function initDateTimeWindow(){
          const now = new Date();
          const start = new Date(now.getTime() - 6*60*60*1000);
          const pad = n => String(n).padStart(2,'0');
          const toLocalDT = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
          $('#txtFechaIni').val(toLocalDT(start));
          $('#txtFechaFin').val(toLocalDT(now));
        })();

        switchTab('kpi');

        loadSavedSelections();
        updateMapSelectedPersonsPanel();
        
        initSelectionsContainer();
        loadInteresList();
        loadVehicleList();
        getColors();
        
        setTimeout(() => {
            if (map) {
                setupMapClickHandler();
            }
        }, 1000);
    });

    function switchTab(tabName) {
        // Ocultar todos los paneles de pesta√±as
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });

        // Desactivar todos los botones de pesta√±as
        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.remove('active');
        });

        // Activar la pesta√±a seleccionada
        document.getElementById(`tab-${tabName}`).classList.add('active');
        document.querySelector(`.tab-button[data-tab="${tabName}"]`).classList.add('active');
    }
    
    // Inicializaci√≥n para GMP Map 3D
    window.initMap = async function() {
        try {
            // Importar las librer√≠as necesarias
            const maps3dLibrary = await google.maps.importLibrary("maps3d");
            const markerLibrary = await google.maps.importLibrary("marker");
    
            Marker3DInteractiveElement = maps3dLibrary.Marker3DInteractiveElement;
            PopoverElement = maps3dLibrary.PopoverElement; // Asegurar que est√© disponible
            PinElement = markerLibrary.PinElement;
    
            // Obtener la referencia al componente gmp-map-3d
            map = domCache.map;
    
            if (!map) {
                return;
            }
            
            initAreaLabelStyles();
    
            // Esperar a que el mapa est√© listo usando el evento gmp-ready
            await new Promise((resolve) => {
                if (map.mapEl) {
                    resolve();
                } else {
                    map.addEventListener('gmp-ready', resolve, { once: true });
                }
            });
    
            log("‚úÖ Mapa GMP 3D completamente inicializado");
    
            // Reforzar configuraci√≥n despu√©s de que el mapa est√© listo
            setTimeout(() => {
                if (map) {
                    // Coordenadas de Lima, Per√∫
                    map.setAttribute('center', '-12.046374, -77.042793');
                    map.setAttribute('range', '5000');
                    map.setAttribute('tilt', '45');
                    map.setAttribute('heading', '0');
                    
                    log('üéØ Mapa configurado para Lima, Per√∫');
                }
            }, 1000);
    
            // Inicializar arrays
            markers = [];
            userMarkers = [];
            alertMarkers = [];
            userMarkerCounter = 0;
    
            // Evento para crear marcadores al hacer clic
            map.addEventListener('click', (event) => {
                log('üó∫Ô∏è Clic en el mapa');
                
                // Verificar si el clic fue en un marcador
                const clickedOnMarker = event.target.closest('gmp-marker-3d') || 
                                       event.target.closest('gmp-marker-3d-interactive');
                
                if (!clickedOnMarker) {
                    // Solo resetear si se hace clic directamente en el mapa (no en un marcador)
                    // Y si hay un popover abierto (indicando que se est√° cerrando)
                    if (currentlySelectedCamera && currentlyOpenPopover) {
                        log('üîÑ Clic fuera de marcadores con popover abierto, reseteando filtro...');
                        resetCameraFilter();
                    } else if (currentlySelectedCamera) {
                        log('üîÑ Clic fuera de marcadores, reseteando filtro...');
                        resetCameraFilter();
                    }
                    
                    // Cerrar popover abierto si existe
                    if (currentlyOpenPopover) {
                        try {
                            currentlyOpenPopover.popover.open = false;
                            currentlyOpenPopover = null;
                            log('‚úÖ Popover cerrado por clic fuera');
                        } catch (error) {
                            log('Error cerrando popover:', error);
                        }
                    }
                }
            
                // Crear marcador de usuario (mantener tu l√≥gica actual)
                if (event.detail && event.detail.latLng && !clickedOnMarker) {
                    const lat = event.detail.latLng.lat;
                    const lng = event.detail.latLng.lng;
                    log(`üìç Creando marcador de usuario en: ${lat}, ${lng}`);
                    createUserMarker(lat, lng);
                }
            });
        
            log("‚úÖ Eventos del mapa configurados");
            // Configurar el manejador de clics en el mapa
            setupMapClickHandler();
    
            // Esperar un poco m√°s para asegurar que el mapa est√© completamente cargado
            setTimeout(() => {
                if (listaAlertas.length > 0 && !currentlySelectedCamera) {
                    renderMapAndMarkers(listaAlertas);
                }
            }, 2000);
    
            if (isDashboardVisible) {
                getAlertas(null);
            }
            
            setTimeout(() => {
                addPolygonLayerControls();
                
                // Si ya hay datos de √°reas, dibujarlas
                if (areasData && areasData.length > 0) {
                    drawAreasOnMap(areasData);
                }
            }, 3000);
        } catch (error) {
            //error("Error al inicializar el mapa GMP:", error);
            const mapContainer = domCache.map;
            if (mapContainer) {
                mapContainer.innerHTML = `
                    <div style="padding: 20px; color: #ff7a2f; text-align: center;">
                        <h4>Error al cargar el mapa 3D</h4>
                        <p>${error.message}</p>
                        <p><strong>Nota:</strong> Se requiere un Map ID configurado en Google Cloud Console</p>
                        <button onclick="retryMapLoad()" style="
                            background: #ff7a2f;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 5px;
                            cursor: pointer;
                            margin-top: 10px;
                        ">Reintentar</button>
                    </div>
                `;
            }
        }
    };
    
    async function renderMapAndMarkers(alerts) {
        
        if (!map || !alerts || alerts.length === 0) {
            log("‚ö†Ô∏è No hay mapa o alertas para renderizar");
            clearAlertMarkers();
            return;
        }
    
        // Si estamos en modo de ruta o suspendido, no renderizar marcadores normales
        if (currentRoute || suspendAutoMarkers) {
            log('üìç En modo ruta, omitiendo renderizado normal de marcadores');
            return;
        }

    
        // Agrupar alertas por coordenadas
        const alertsByLocation = groupAlertsByLocation(alerts);
        
        // Guardar estado del popover abierto actualmente
        const openPopoverCoordinates = currentlyOpenPopover ? currentlyOpenPopover.coordinates : null;
    
        if (!map || !alerts || alerts.length === 0) {
            log("No hay mapa o alertas para renderizar");
            clearAlertMarkers();
            currentlyOpenPopover = null;
            previousAlertCoordinates.clear();
            return;
        }
    
        // Guardar coordenadas actuales
        const currentAlertCoordinates = new Set(Object.keys(alertsByLocation));
    
        // Eliminar solo marcadores que ya no existen
        const markersToRemove = [];
    
        alertMarkers.forEach((markerData, index) => {
            const coordinates = markerData.coordinates;
            if (!currentAlertCoordinates.has(coordinates)) {
                markersToRemove.push(index);
                if (currentlyOpenPopover && currentlyOpenPopover.coordinates === coordinates) {
                    currentlyOpenPopover = null;
                }
            }
        });
    
        // Eliminar marcadores en orden inverso
        markersToRemove.reverse().forEach(index => {
            const { marker, popover } = alertMarkers[index];
            try {
                if (popover && popover.open) {
                    popover.open = false;
                }
                if (marker && marker.parentNode === map) {
                    map.removeChild(marker);
                }
                if (popover && popover.parentNode === map) {
                    map.removeChild(popover);
                }
            } catch (error) {
                log(`Error eliminando marcadores ${alertMarkers[index].coordinates}:`, error);
            }
            alertMarkers.splice(index, 1);
        });
    
        // Actualizar marcadores existentes y crear nuevos
        Object.entries(alertsByLocation).forEach(([coordinatesKey, groupData]) => {
            const existingMarkerIndex = alertMarkers.findIndex(m => m.coordinates === coordinatesKey);
    
            if (existingMarkerIndex >= 0) {
                // Actualizar marcador existente
                updateExistingMarker(alertMarkers[existingMarkerIndex], groupData);
            } else {
                // Crear nuevo marcador
                try {
                    createInteractiveMarker(coordinatesKey, groupData);
                } catch (error) {
                    log('Error creando marcador interactivo:', error);
                }
            }
        });
    
        // Restaurar popover abierto si todav√≠a existe
        if (openPopoverCoordinates && currentAlertCoordinates.has(openPopoverCoordinates)) {
            setTimeout(() => {
                restoreSingleOpenPopover(openPopoverCoordinates);
            }, 300);
        }
    
        // Actualizar coordenadas anteriores
        previousAlertCoordinates = new Set(currentAlertCoordinates);
    }
    
    function updateExistingMarker(markerData, groupData) {
        const { coordinates, alerts } = groupData;
        const alertCount = alerts.length;
    
        // Actualizar el contenido del popover
        const popoverContent = createPopoverContent(coordinates, alerts, alertCount);
        
        try {
            markerData.popover.innerHTML = popoverContent;

        } catch (error) {
            log('Error actualizando marcador existente:', error);
        }
    }
    
    function restoreSingleOpenPopover(coordinates) {
        
        // Cerrar cualquier popover abierto actualmente
        if (currentlyOpenPopover && currentlyOpenPopover.popover) {
            try {
                currentlyOpenPopover.popover.open = false;
            } catch (error) {
                log('Error cerrando popover actual:', error);
            }
        }
    
        // Buscar el marcador correspondiente
        const markerData = alertMarkers.find(({ coordinates: markerCoords }) =>
            markerCoords === coordinates
        );
    
        if (markerData && markerData.marker && markerData.popover) {
            
            try {
                markerData.popover.open = true;
                currentlyOpenPopover = {
                    coordinates: coordinates,
                    popover: markerData.popover,
                    marker: markerData.marker
                };
            } catch (error) {
                log('Error abriendo popover:', error);
                currentlyOpenPopover = null;
            }
        } else {
            log('‚ùå No se pudo encontrar marcador para:', coordinates);
            currentlyOpenPopover = null;
        }
    }
    
    function openPopoverWithRetry(popover, coordinates, attempt) {
        const maxAttempts = 5;
        
        try {
            log(`üîÑ Intentando abrir popover (intento ${attempt + 1}) para: ${coordinates}`);
            popover.open = true;
            
            // Verificar si realmente se abri√≥
            setTimeout(() => {
                if (popover.open) {
                    log(`‚úÖ Popover abierto exitosamente para: ${coordinates}`);
                } else if (attempt < maxAttempts - 1) {
                    log(`üîÑ Reintentando abrir popover para: ${coordinates}`);
                    openPopoverWithRetry(popover, coordinates, attempt + 1);
                } else {
                    log(`‚ùå No se pudo abrir el popover despu√©s de ${maxAttempts} intentos: ${coordinates}`);
                }
            }, 100);
        } catch (error) {
            log(`‚ùå Error abriendo popover (intento ${attempt + 1}):`, error);
            if (attempt < maxAttempts - 1) {
                setTimeout(() => {
                    openPopoverWithRetry(popover, coordinates, attempt + 1);
                }, 200);
            }
        }
    }
    
    function createInteractiveMarker(coordinatesKey, groupData) {
        const { coordinates, alerts, types, isCamera, cameraId } = groupData;
        const alertCount = alerts.length;
    
        try {
            // Crear el popover PRIMERO
            const popover = new PopoverElement({
                open: false,
            });
    
            // Crear contenido del popover
            const popoverContent = createPopoverContent(coordinates, alerts, alertCount);
            popover.innerHTML = popoverContent;
    
            // Calcular intensidad del heatmap basado en la cantidad de alertas
            const heatmapIntensity = calculateHeatmapIntensity(alertCount);
            
            // Determinar color base con heatmap
            const baseColor = isCamera ? '#22e6d9' : getGroupAlertColor(Array.from(types));
            const heatmapColor = applyHeatmapToColor(baseColor, heatmapIntensity);
    
            // Crear el marcador interactivo
            const interactiveMarker = new Marker3DInteractiveElement({
                position: {
                    lat: coordinates.lat,
                    lng: coordinates.lng,
                    altitude: 0
                },
                gmpPopoverTargetElement: popover
            });
    
            // Configurar propiedades b√°sicas del marcador
            interactiveMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            interactiveMarker.setAttribute('scale', '1.5');
            interactiveMarker.setAttribute('interactive', 'true');
    
            // ENFOQUE PRINCIPAL: Usar PinElement si est√° disponible
            if (typeof PinElement !== 'undefined' && PinElement) {
                try {
                    const pinElement = new PinElement({
                        background: heatmapColor,
                        borderColor: '#ffffff',
                        glyphColor: '#ffffff',
                        scale: 1.2,
                        glyph: 'üìπ' // Fallback simple
                    });
                    interactiveMarker.appendChild(pinElement.element);
                } catch (pinError) {
                    log('‚ùå Error con PinElement, usando fallback:', pinError);
                    // Fallback a HTMLTemplateElement con icono Luna
                    createMarkerWithLunaIcon(interactiveMarker, heatmapColor, heatmapIntensity, alertCount);
                }
            } else {
                // Fallback: Usar HTMLTemplateElement con icono Luna
                log('‚ö†Ô∏è PinElement no disponible, usando HTMLTemplateElement con icono Luna');
                createMarkerWithLunaIcon(interactiveMarker, heatmapColor, heatmapIntensity, alertCount);
            }
    
            // A√±adir datos personalizados para identificar c√°maras
            if (isCamera && cameraId) {
                interactiveMarker.setAttribute('data-camera-id', cameraId);
                interactiveMarker.setAttribute('data-camera-name', alerts[0].camera_name);
                interactiveMarker.setAttribute('data-is-camera', 'true');
            }
    
            // A√±adir datos de heatmap para referencia
            interactiveMarker.setAttribute('data-heatmap-intensity', heatmapIntensity);
            interactiveMarker.setAttribute('data-alert-count', alertCount);
    
            // EVENTOS DE CLIC
            interactiveMarker.addEventListener('click', (event) => {
                event.stopPropagation();
                event.preventDefault();
                handleMarkerClick(coordinatesKey, isCamera, cameraId, alerts, popover, interactiveMarker);
            });
    
            interactiveMarker.addEventListener('gmp-click', (event) => {
                event.stopPropagation();
                handleMarkerClick(coordinatesKey, isCamera, cameraId, alerts, popover, interactiveMarker);
            });
    
            // A√±adir al mapa
            map.appendChild(interactiveMarker);
            map.appendChild(popover);
    
            // Guardar referencia para limpiar despu√©s
            alertMarkers.push({
                marker: interactiveMarker,
                popover: popover,
                coordinates: coordinatesKey,
                isCamera: isCamera,
                cameraId: cameraId,
                heatmapIntensity: heatmapIntensity,
                alertCount: alertCount
            });
    
            return interactiveMarker;
    
        } catch (error) {
            log('‚ùå Error cr√≠tico creando marcador interactivo:', error);
            return null;
        }
    }
    
    function createMarkerWithLunaIcon(interactiveMarker, heatmapColor, heatmapIntensity, alertCount) {
        try {
            const template = document.createElement('template');
            
            // Calcular tama√±o basado en la intensidad del heatmap
            const baseSize = 32;
            const sizeMultiplier = 0.5 + (heatmapIntensity * 0.5); // 0.5 a 1.0
            const markerSize = Math.floor(baseSize * sizeMultiplier);
            
            // Calcular opacidad basada en la intensidad
            const opacity = 0.7 + (heatmapIntensity * 0.3); // 0.7 a 1.0
    
            template.innerHTML = `
                <div class="custom-marker luna-marker ${getHeatmapClass(heatmapIntensity)}" style="
                    width: ${markerSize}px;
                    height: ${markerSize}px;
                    background-color: ${heatmapColor};
                    border: 3px solid white;
                    border-radius: 50%;
                    box-shadow: 
                        0 2px 10px rgba(0,0,0,0.4),
                        0 0 0 ${Math.floor(heatmapIntensity * 10)}px ${heatmapColor}33;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: ${Math.floor(markerSize * 0.5)}px;
                    font-family: 'Pe-icon-7-stroke', Arial, sans-serif;
                    cursor: pointer;
                    opacity: ${opacity};
                    transition: all 0.3s ease;
                    position: relative;
                ">
                    <span class="pe-7s-video"></span>
                    ${alertCount > 1 ? `
                    <div style="
                        position: absolute;
                        top: -5px;
                        right: -5px;
                        background: #ff4444;
                        color: white;
                        border-radius: 50%;
                        width: 18px;
                        height: 18px;
                        font-size: 10px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        border: 2px solid white;
                    ">${alertCount > 99 ? '99+' : alertCount}</div>
                    ` : ''}
                </div>
            `;
            interactiveMarker.appendChild(template.content.cloneNode(true));
            log('‚úÖ Marcador creado con icono Luna y heatmap');
        } catch (templateError) {
            log('‚ùå Error cr√≠tico creando marcador con icono Luna:', templateError);
        }
    }
    
    // FUNCI√ìN AUXILIAR PARA OBTENER CLASE DE HEATMAP
    function getHeatmapClass(intensity) {
        if (intensity <= 0.3) return 'heatmap-low';
        if (intensity <= 0.7) return 'heatmap-medium';
        return 'heatmap-high';
    }
    
    // FUNCI√ìN PARA CALCULAR INTENSIDAD DEL HEATMAP
    function calculateHeatmapIntensity(alertCount) {
        if (alertCount <= 1) return 0.1;
        if (alertCount <= 3) return 0.3;
        if (alertCount <= 5) return 0.5;
        if (alertCount <= 10) return 0.7;
        if (alertCount <= 20) return 0.8;
        return 1.0; // M√°xima intensidad para 20+ alertas
    }
    
    // FUNCI√ìN PARA APLICAR HEATMAP AL COLOR BASE
    function applyHeatmapToColor(baseColor, intensity) {
        // Convertir color hexadecimal a RGB
        let r, g, b;
        if (baseColor.startsWith('#')) {
            const hex = baseColor.replace('#', '');
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        } else {
            // Fallback para colores con nombre
            return baseColor;
        }
    
        // Aplicar intensidad del heatmap (hacer el color m√°s "caliente")
        const heatR = Math.min(255, r + (intensity * 100));
        const heatG = Math.max(0, g - (intensity * 50));
        const heatB = Math.max(0, b - (intensity * 50));
    
        return `rgb(${Math.floor(heatR)}, ${Math.floor(heatG)}, ${Math.floor(heatB)})`;
    }
    
    // FUNCI√ìN AUXILIAR PARA EL FALLBACK CON TEMPLATE
    function createMarkerWithTemplate(interactiveMarker, color, glyph, alertCount) {
        try {
            const template = document.createElement('template');
            const fontSize = alertCount > 1 ? (alertCount > 9 ? '11px' : '12px') : '16px';
            
            template.innerHTML = `
                <div class="custom-marker" style="
                    width: 32px;
                    height: 32px;
                    background-color: ${color};
                    border: 3px solid white;
                    border-radius: 50%;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.4);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: ${fontSize};
                    font-family: Arial, sans-serif;
                    cursor: pointer;
                ">
                    ${glyph}
                </div>
            `;
            interactiveMarker.appendChild(template.content.cloneNode(true));
            log('‚úÖ Marcador creado con HTMLTemplateElement (fallback)');
        } catch (templateError) {
            log('‚ùå Error cr√≠tico con HTMLTemplateElement:', templateError);
            // En este caso, el marcador se crear√° sin contenido personalizado
        }
    }
    
    // A√ëADIR: Funci√≥n para manejar el cierre desde cualquier tipo de evento
    function handleMarkerClick(coordinatesKey, isCamera, cameraId, alerts, popover, interactiveMarker) {
    // Si estamos en modo de b√∫squeda (persona/veh√≠culo), no aplicar filtro de c√°mara
        if (currentSearchType === null || selectedInteresItem !== null) {
            log('üîç Modo b√∫squeda activo - omitiendo filtro de c√°mara');
            
            // Solo manejar la apertura/cierre del popover
            if (currentlyOpenPopover && currentlyOpenPopover.popover === popover && popover.open) {
                popover.open = false;
                currentlyOpenPopover = null;
                stopCameraUpdates(cameraId);
                return;
            }
            
            // Cerrar popover anterior si existe
            if (currentlyOpenPopover && currentlyOpenPopover.popover !== popover) {
                try {
                    currentlyOpenPopover.popover.open = false;
                    stopCameraUpdates(currentlyOpenPopover.cameraId);
                } catch (error) {
                    log('Error cerrando popover anterior:', error);
                }
            }
            
            // Abrir este popover
            try {
                popover.open = true;
                currentlyOpenPopover = {
                    coordinates: coordinatesKey,
                    popover: popover,
                    marker: interactiveMarker,
                    cameraId: cameraId
                };
                
                // Iniciar actualizaciones incluso en modo b√∫squeda
                if (cameraId) {
                    startCameraUpdates(cameraId);
                }
            } catch (error) {
                log('‚ùå Error abriendo popover:', error);
            }
        }
    
        // FILTRADO AUTOM√ÅTICO: Si es una c√°mara, filtrar alertas autom√°ticamente
        // SOLO si no estamos en modo b√∫squeda
        if (isCamera && cameraId && currentSearchType === null) {
            filterByCamera(cameraId, alerts[0].camera_name);
        }
    }
    
    function createPopoverContent(coordinates, alerts, alertCount) {
        const isCamera = alerts.length > 0 && alerts.every(alert =>
            alert.camera_name === alerts[0].camera_name
        );
    
        if (isCamera) {
            const cameraName = alerts[0].camera_name;
            const cameraId = alerts[0].camera_id;
            
            // Encontrar la alerta m√°s reciente para mostrar su hora
            const latestAlert = alerts.reduce((latest, current) => {
                const currentTime = new Date(current.init_time_frame || current.epoch_frame);
                const latestTime = new Date(latest.init_time_frame || latest.epoch_frame);
                return currentTime > latestTime ? current : latest;
            }, alerts[0]);
            
            const latestTime = new Date(latestAlert.init_time_frame || latestAlert.epoch_frame);
            const formattedTime = latestTime.toLocaleTimeString('es-PE', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const formattedDate = latestTime.toLocaleDateString('es-PE');
    
            // Asegurar que el ID sea √∫nico y v√°lido
            const containerId = `camera-live-${String(cameraId).replace(/[^a-zA-Z0-9-_]/g, '')}`;
    
            return `
                <div class="popover-modal">
                    <h3 style="margin: 0 0 8px 0; color: #22e6d9; text-align: center;">${cameraName}</h3>
                    <p style="margin: 0 0 8px 0; color: #22e6d9; text-align: center;">${alerts[0].location}</p>
                    <div style="text-align: center; margin-bottom: 6px; font-size: 12px; color: #e8f4f8;">
                        <div>√öltima detecci√≥n:</div>
                        <div><strong>${formattedDate} ${formattedTime}</strong></div>
                    </div>
                    <div style="text-align: center; margin-bottom: 4px;">
                        <div id="${containerId}"
                             class="camera-live-container"
                             style="; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;">
                            <div class="camera-placeholder" style="color: #22e6d9; padding: 15px; display: flex; flex-direction: column; align-items: center;">
                                <div style="font-size: 16px; margin-bottom: 6px;">üìπ</div>
                                <div>Cargando vista en vivo...</div>
                                <div style="font-size: 11px; margin-top: 4px;">C√°mara ${cameraId}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        } else {
            // Contenido original para agrupaciones de alertas (sin cambios)
            return `
                <div style="background: #1a2b3c; border-radius: 12px; padding: 20px; color: white; max-width: 300px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border: 2px solid #22e6d9;">
                    <h3 style="margin: 0 0 10px 0; color: #22e6d9; text-align: center;">${alertCount} Alertas</h3>
                    <p style="margin: 0; text-align: center;">Ubicaci√≥n con m√∫ltiples alertas</p>
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(34,230,217,0.3);">
                        <small>Coordenadas: ${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}</small><br>
                        <small>Haga clic en "Ver detalles" para m√°s informaci√≥n.</small>
                    </div>
                    <button onclick="closePopover(this)" style="
                        background: #ff4757;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 6px;
                        font-size: 12px;
                        cursor: pointer;
                        margin-top: 15px;
                        width: 100%;
                    ">Cerrar</button>
                    <button onclick="showGroupAlertDetails(${JSON.stringify(coordinates).replace(/"/g, '&quot;')}, ${JSON.stringify(alerts).replace(/"/g, '&quot;')})" style="
                        background: #22e6d9;
                        color: #1a2b3c;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 6px;
                        font-size: 12px;
                        cursor: pointer;
                        margin-top: 5px;
                        width: 100%;
                        font-weight: bold;
                    ">Ver detalles</button>
                </div>
            `;
        }
    }
    
    // Funci√≥n para cerrar popover
    function closePopover(button) {
        log('‚ùå Bot√≥n cerrar clickeado (solo popover)');
        const popover = button.closest('gmp-popover');
        if (popover) {
            popover.open = false;
    
            // Buscar en currentlyOpenPopover si este popover est√° abierto
            if (currentlyOpenPopover && currentlyOpenPopover.popover === popover) {
                const cameraId = currentlyOpenPopover.cameraId;
                if (cameraId) {
                    stopCameraUpdates(cameraId);
                }
                currentlyOpenPopover = null;
            }
    
            // Tambi√©n buscar en todos los alertMarkers por si acaso
            alertMarkers.forEach(markerData => {
                if (markerData.popover === popover && markerData.cameraId) {
                    stopCameraUpdates(markerData.cameraId);
                }
            });
        }
    
        // NO resetear el filtro de c√°mara aqu√≠
        log('‚úÖ Popover cerrado (sin resetear filtro)');
    }
    
    // Funci√≥n para agrupar alertas por coordenadas
    function groupAlertsByLocation(alerts) {
        const groups = {};
    
        alerts.forEach(alert => {
            // Verificar que la alerta tenga coordenadas
            if (alert.latitud && alert.longitud) {
                const lat = parseFloat(alert.latitud).toFixed(6);
                const lng = parseFloat(alert.longitud).toFixed(6);
                const key = `${lat},${lng}`;
    
                if (!groups[key]) {
                    groups[key] = {
                        coordinates: { lat: parseFloat(alert.latitud), lng: parseFloat(alert.longitud) },
                        alerts: [],
                        types: new Set(),
                        cameras: new Set(),
                        isCamera: false,
                        cameraId: null
                    };
                }
    
                groups[key].alerts.push(alert);
                groups[key].types.add(alert.type_event_name || 'Alerta');
                groups[key].cameras.add(alert.camera_id);
            }
        });
    
        // Determinar si cada grupo es una c√°mara
        Object.keys(groups).forEach(key => {
            const group = groups[key];
            const uniqueCameras = Array.from(group.cameras);
            
            // Es una c√°mara si todas las alertas tienen el mismo camera_id
            group.isCamera = uniqueCameras.length === 1;
            if (group.isCamera) {
                group.cameraId = uniqueCameras[0];
            }
        });
    
        return groups;
    }
    
    // Funci√≥n para determinar el color del grupo basado en la prioridad de tipos de alerta
    function getGroupAlertColor(alertTypes) {
        if (!alertTypes || alertTypes.length === 0) return '#22e6d9';
    
        // Orden de prioridad de colores (de mayor a menor prioridad)
        const priorityOrder = {
            'red': ['accidente', 'emergencia', 'incendio', 'robo'],
            'orange': ['aglomeracion', 'restringida', 'violencia', 'pelea'],
            'yellow': ['zona', 'advertencia', 'precauci√≥n'],
            'teal': [] // default
        };
    
        for (const [color, keywords] of Object.entries(priorityOrder)) {
            for (const type of alertTypes) {
                // CORREGIDO: Verificar que type sea string antes de toLowerCase()
                if (type && typeof type === 'string') {
                    const lowerType = type.toLowerCase();
                    for (const keyword of keywords) {
                        if (lowerType.includes(keyword)) {
                            switch (color) {
                                case 'red': return '#ff4444';
                                case 'orange': return '#ffaa00';
                                case 'yellow': return '#ffff00';
                            }
                        }
                    }
                }
            }
        }
    
        return '#22e6d9'; // Color por defecto
    }
    
    // Variables para trackear event listeners
    let closeOnClick = null;
    let closeOnEsc = null;
    
    // Funci√≥n para mostrar detalles de un grupo de alertas
    function showGroupAlertDetails(coordinates, alerts) {
        const panel = domCache.alertDetails;
        const content = document.getElementById('alert-details-content');
        
        if (!panel || !content) return;
        
        // Ordenar alertas por fecha (m√°s reciente primero)
        const sortedAlerts = [...alerts].sort((a, b) => 
            new Date(b.init_time_frame) - new Date(a.init_time_frame)
        );
        
        let html = `
            <div style="max-width: 350px;">
                <div class="detail-item">
                    <h4 class="person-details-title">${alerts.length} Alertas en esta ubicaci√≥n</h4>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Coordenadas:</span>
                    <span class="detail-value">${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">C√°mara:</span>
                    <span class="detail-value">${alerts[0].camera_name || 'N/A'}</span>
                </div>
                <div style="max-height: 300px; overflow-y: auto; margin-top: 15px;">
        `;
        
        // Lista de alertas
        sortedAlerts.forEach((alert, index) => {
            const time = new Date(alert.init_time_frame);
            const formattedTime = time.toLocaleString('es-PE');
            
            html += `
                <div class="alert-group-item" style="border-bottom: 1px solid rgba(34,230,217,0.2); padding: 10px 0; ${index === 0 ? 'border-top: 1px solid rgba(34,230,217,0.2);' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: ${getAlertColor(alert.type_event_name)};">
                                ${alert.type_event_name || 'Alerta'}
                            </div>
                            <div style="font-size: 12px; color: var(--ink);">
                                ${formattedTime}
                            </div>
                            ${alert.nombre_objetivo ? `
                            <div style="font-size: 12px; color: var(--ink);">
                                Objetivo: ${alert.nombre_objetivo}
                            </div>
                            ` : ''}
                        </div>
                        <button onclick="selectSingleAlertFromGroup('${alert.id}')" 
                                style="background: var(--teal); color: white; border: none; padding: 5px 10px; border-radius: 4px; font-size: 12px; cursor: pointer; margin-left: 10px;">
                            Ver
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
            </div>
        `;
        
        content.innerHTML = html;
        panel.style.display = 'block';
        
        // Centrar el mapa en esta ubicaci√≥n
        if (map) {
            map.setAttribute('center', `${coordinates.lat},${coordinates.lng}`);
            map.setAttribute('range', '500');
        }
    }
    
    // Funci√≥n para seleccionar una alerta individual desde el grupo
    function selectSingleAlertFromGroup(alertId) {
        // Buscar la alerta en todas las alertas disponibles
        let alert = null;
        
        // Buscar en las alertas filtradas primero
        if (filteredAlerts && filteredAlerts.length > 0) {
            alert = filteredAlerts.find(a => a.id == alertId);
        }
        
        // Si no se encuentra, buscar en todas las alertas
        if (!alert) {
            alert = alertas.find(a => a.id == alertId);
        }
        
        if (alert) {
            // Mostrar detalles de la alerta individual
            showAlertDetails(alert);
            
            // Cerrar el panel de grupo
            const panel = domCache.alertDetails;
            if (panel) {
                panel.style.display = 'none';
            }
        }
    }
    
    // Mantener la funci√≥n getAlertColor original para alertas individuales
    function getAlertColor(alertType) {
        if (!alertType) return '#22e6d9';
        
        const lowerType = alertType.toLowerCase();
        
        if (lowerType.includes('accidente') || lowerType.includes('emergencia')) {
            return '#ff4444';
        } else if (lowerType.includes('aglomeracion') || lowerType.includes('restringida')) {
            return '#ffaa00';
        } else if (lowerType.includes('zona')) {
            return '#ffff00';
        } else {
            return '#22e6d9';
        }
    }

    // Funci√≥n para reintentar carga del mapa
    function retryMapLoad() {
        const mapContainer = domCache.map;
        if (mapContainer) {
            mapContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Cargando mapa...</div>';
        }

        // Limpiar cach√© de Google Maps
        delete window.google;
        delete window.initMap;

        // Recargar la API
        setTimeout(() => {
            loadGoogleMaps().catch(error => {
                //error("Error al recargar Google Maps:", error);
            });
        }, 1000);
    }

    // Funci√≥n para cargar el mapa cuando se muestra el dashboard
    function showDashboard() {
        splash.style.display = 'none';
        dashboard.style.display = 'block';
        controls.style.display = 'flex';
        isDashboardVisible = true;
    
        clearCurrentRoute();
        switchTab('kpi');
    
        try {
            if (!document.fullscreenElement) {
                root.requestFullscreen({ navigationUI: 'hide' }).catch(() => {});
            }
        } catch (e) {}
    
        getAlertas(null);
    
        // CARGAR √ÅREAS
        setTimeout(() => {
            loadAreas();
    
            // Crear panel de √°reas
            createAreasPanel();
            addAreasPanelButton();
        }, 1000);
    
        // Cargar Google Maps si no est√° cargado
        if (!window.google) {
            loadGoogleMaps()
                .then(() => {
                    alertasInterval = setInterval(() => {
                        getAlertas(busqueda);
                    }, 10000);
                })
                .catch(error => {
                    showMapFallback();
                });
        } else {
            alertasInterval = setInterval(() => {
                getAlertas(busqueda);
            }, 10000);
        }
        
        setTimeout(() => {
            // Inicializar estilos
            initAreaStyles();
            
            // Crear panel de √°reas
            createAreasPanel();
            addAreasPanelButton();
        }, 2000);
    }
    
    function initAreaStyles() {
        const style = document.createElement('style');
        style.textContent = `
            /* Ocultar completamente los marcadores invisibles */
            gmp-marker-3d[data-type*="clickable"] {
                opacity: 0 !important;
                pointer-events: all !important;
            }
            
            gmp-marker-3d[data-type*="clickable"]::part(container) {
                opacity: 0 !important;
            }
            
            /* Cursor pointer para √°reas clickeables */
            gmp-marker-3d[data-type*="clickable"] {
                cursor: pointer !important;
            }
            
            /* Estilos para el popover de etiqueta */
            gmp-popover[data-type="area-label"] {
                --gmp-popover--background-color: transparent !important;
                --gmp-popover--border: none !important;
                --gmp-popover--box-shadow: none !important;
                --gmp-popover--padding: 0 !important;
            }
            
            gmp-popover[data-type="area-label"]::part(container) {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                padding: 0 !important;
            }
        `;
        document.head.appendChild(style);
    }
    
    function setupClickDebugging() {
        if (!map) return;
        
        map.addEventListener('click', (event) => {
            console.log('üó∫Ô∏è Clic en el mapa (coords):', event.detail?.latLng);
        });
        
        // Verificar marcadores clickeables
        setTimeout(() => {
            const clickableMarkers = document.querySelectorAll('[data-type*="clickable"]');
            console.log(`üîç Marcadores clickeables encontrados: ${clickableMarkers.length}`);
            
            clickableMarkers.forEach((marker, index) => {
                console.log(`üìç Marcador ${index + 1}:`, marker.getAttribute('data-area-name'));
            });
        }, 3000);
    }

    // Funci√≥n de fallback si el mapa no carga
    function showMapFallback() {
        const mapContainer = domCache.map;
        if (mapContainer) {
            mapContainer.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #e8f4f8;">
                    <h3>‚ö†Ô∏è Mapa no disponible</h3>
                    <p>El mapa no pudo cargarse debido a problemas de conexi√≥n o compatibilidad.</p>
                    <p>Las alertas seguir√°n funcionando en la lista temporal.</p>
                    <button onclick="retryMapLoad()" style="
                        background: #22e6d9;
                        color: #1a2b3c;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        margin-top: 15px;
                        font-weight: bold;
                    ">Reintentar Carga del Mapa</button>
                </div>
            `;
        }
    }

    // Funci√≥n para crear marcador de usuario
    function createUserMarker(lat, lng) {
        if (!Marker3DInteractiveElement || !PopoverElement) {
            log('Librer√≠as de Maps 3D no cargadas');
            return;
        }
    
        userMarkerCounter++;
    
        try {
            // Crear popover para el marcador de usuario
            const popover = new PopoverElement({
                open: false,
            });
    
            const popoverContent = `
                <div style="background: #1a2b3c; border-radius: 12px; padding: 20px; color: white; max-width: 280px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border: 2px solid #ffd700;">
                    <h3 style="margin: 0 0 10px 0; color: #ffd700; text-align: center;">Marcador Personalizado</h3>
                    <div style="margin-bottom: 15px;">
                        <p><strong>ID:</strong> ${userMarkerCounter}</p>
                        <p><strong>Coordenadas:</strong><br>
                           Lat: ${lat.toFixed(6)}<br>
                           Lng: ${lng.toFixed(6)}</p>
                    </div>
                    <button onclick="removeUserMarker(${userMarkerCounter})" style="
                        background: #ff4757;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 6px;
                        font-size: 12px;
                        cursor: pointer;
                        margin-top: 10px;
                        width: 100%;
                    ">Eliminar Marcador</button>
                    <button onclick="closePopover(this)" style="
                        background: #666;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 6px;
                        font-size: 12px;
                        cursor: pointer;
                        margin-top: 5px;
                        width: 100%;
                    ">Cerrar</button>
                </div>
            `;
    
            popover.innerHTML = popoverContent;
    
            // Crear marcador interactivo - SOLO PROPIEDADES V√ÅLIDAS
            const marker = new Marker3DInteractiveElement({
                position: {
                    lat: lat,
                    lng: lng,
                    altitude: 30
                },
                gmpPopoverTargetElement: popover
                // Eliminadas propiedades no v√°lidas
            });
    
            // A√±adir al mapa
            map.appendChild(marker);
            map.appendChild(popover);
    
            userMarkers.push({
                id: userMarkerCounter,
                marker: marker,
                popover: popover,
                lat: lat,
                lng: lng
            });
    
            showTempMessage(`‚úÖ Marcador creado en (${lat.toFixed(4)}, ${lng.toFixed(4)})`);
        } catch (error) {
            log('Error creando marcador de usuario:', error);
            showTempMessage('‚ùå Error al crear marcador');
        }
    }
    
    // Actualizar la funci√≥n removeUserMarker
    function removeUserMarker(markerId) {
        const markerIndex = userMarkers.findIndex(m => m.id === markerId);
        if (markerIndex !== -1) {
            const { marker, popover } = userMarkers[markerIndex];
            try {
                if (marker.parentNode === map) {
                    map.removeChild(marker);
                }
                if (popover.parentNode === map) {
                    map.removeChild(popover);
                }
            } catch (error) {
                log('Error eliminando marcador de usuario:', error);
            }
            userMarkers.splice(markerIndex, 1);
    
            showTempMessage('Marcador eliminado');
        }
    }

    // Funci√≥n para mostrar mensaje temporal
    function showTempMessage(message) {
        const existingMessage = document.getElementById('temp-message');
        if (existingMessage) {
            existingMessage.remove();
        }

        const messageDiv = document.createElement('div');
        messageDiv.id = 'temp-message';
        messageDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #22e6d9;
            color: #1a2b3c;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        messageDiv.textContent = message;

        document.body.appendChild(messageDiv);

        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.remove();
            }
        }, 3000);
    }
    // Variables globales principales
    let alertMarkers = [];
    let map = null;
    let markers = [];
    let infoWindow = null;
    let userMarkers = [];
    let userMarkerCounter = 0;
    let isDashboardVisible = false;
    const timelineList = document.getElementById('list');
    let listaAlertas = [];
    let filteredAlerts = [];
    let videoPlayer = null;
    let alertInterval = null;
    let lastAlertIds = new Set();
    let currentFilter = 'all';
    let kpiUpdateInterval = null;
    let selectedAlert = null;
    let filtersApplied = false;
    

    // Funci√≥n principal para obtener alertas
    function getAlertas(item) {
        // MOSTRAR LOADER - MEJORADO
        const timelineList = document.getElementById('timelineList');
    
        // NO mostrar loader si hay una b√∫squeda activa de placa o caracter√≠sticas
        if (!(currentSearchType === 'placa' && item === null) &&
            !(currentSearchType === 'caracteristicas' && item === null)) {
            if (timelineList) {
                //timelineList.innerHTML = '<div style="text-align:center;margin:2em; display:flex; flex-direction:column; align-items:center; justify-content:center;"><div class="spinner"></div><div>Cargando alertas...</div></div>';
            }
        }
    
        // Crear objeto de par√°metros base
        let params = {};
    
        // Agregar par√°metros solo si son v√°lidos
        if (item && isValidParam(item.matched_plate)) {
            params.matched_plate = item.matched_plate;
        }
    
        if (item && isValidParam(item.id)) {
            params.matched_ident = item.id;
        }
    
        if(item){
            return;
        }else{
            callAPI({
                method: 'gestion/getalerts',
                params: params,
                    ok: function (vals) {
            
                        // CORRECCI√ìN: Actualizar las alertas que se usan para determinar c√°maras
                        if (currentSearchType === null || currentSearchType === 'interes') {
                            alertas = vals.data;
    
                        // Identificar nuevas alertas vs todas
                        const alertResult = identificarNuevasAlertas(alertas);
                        const newAlerts = alertResult.nuevas;
    
                        // **CAMBIO: Agregar esta secci√≥n para notificar sobre las nuevas alertas**
                        if (newAlerts.length > 0 && newAlerts.length!=alertas.length) {
                            checkAlertsAgainstInteres(newAlerts);
    
                            newAlerts.forEach(item => {
                                nuevasAlertas.push(item);
                            });
                        }
    
                        // **MODIFICACI√ìN: Solo actualizar filteredAlerts para inter√©s**
                        if (selectedInteresItem !== null && item !== null) {
                            if (vals.data && vals.data.length > 0) {
                                filteredAlerts = [...vals.data];
                            } else {
                                filteredAlerts = [];
                            }
                        } else if (item === null) {
                            // NUEVO: Si hay c√°mara seleccionada, mantener el filtro
                            if (currentlySelectedCamera) {
                                filteredAlerts = alertas.filter(alert => alert.camera_id === currentlySelectedCamera);
                            } else {
                                filteredAlerts = null;
                            }
                        }
                    }
    
                    if (item === null && selectedInteresItem === null) {
                        initialAlerts = [...vals.data];
                        lastKPUpdate = new Date();
                        calculateTrendData();
    
                        // NUEVO: Si hay c√°mara seleccionada, mantener filteredAlerts
                        if (currentlySelectedCamera) {
                            filteredAlerts = alertas.filter(alert => alert.camera_id === currentlySelectedCamera);
                            
                            // NUEVO: Mantener el bot√≥n de limpiar filtros visible
                            showClearFiltersButton();
                        }
    
                        // NUEVO: Actualizar el panel de personas seleccionadas cuando lleguen nuevas alertas
                        if (multiSelectedItems && multiSelectedItems.length > 0) {
                            updateMapSelectedPersonsPanel();
                        }
    
                        // Limpiar y actualizar resaltado permanente de c√°maras con alertas
                        alertHighlightedCameras = {};
                    }
    
                    // **MODIFICACI√ìN: Renderizar con las alertas apropiadas seg√∫n el contexto**
                    let alertsToRender;
                    if (currentSearchType === 'placa' || currentSearchType === 'caracteristicas') {
                        alertsToRender = currentSearchResults || [];
                    } else if (currentlySelectedCamera) {
                        alertsToRender = filteredAlerts || [];
                        
                        // NUEVO: Asegurar que el bot√≥n est√© visible
                        showClearFiltersButton();
                    } else {
                        alertsToRender = filteredAlerts !== null ? filteredAlerts : alertas;
                    }
        
                    if( currentFilter != null){
                        applyFilter()
                    }else{
                        renderTimelineList(alertsToRender);
                    }
        
                    // NUEVO: Si hay c√°mara seleccionada, mantener el t√≠tulo actualizado
                    if (currentlySelectedCamera) {
                        const markerData = alertMarkers.find(marker => 
                            marker.cameraId === currentlySelectedCamera && marker.isCamera
                        );
                        if (markerData) {
                            domCache.titlePanel.textContent = `Alertas - C√°mara: ${markerData.marker.getAttribute('data-camera-name')}`;
                        }
                    }
    
                    // Actualizar la leyenda y KPIs (siempre con datos iniciales)
                    const uniqueAlertTypes = [...new Set(initialAlerts.map(alert => alert.type_event_name))];
                    if (!currentlySelectedCamera) {
                        renderMapAndMarkers(alertsToRender).then(() => {
                            buildLegend(uniqueAlertTypes);
                            updateAllMetrics();
                        }).catch(error => {
                            log('Error renderizando marcadores:', error);
                            buildLegend(uniqueAlertTypes);
                            updateAllMetrics();
                        });
                    }
    
                },
                error: function (error) {
                    //showGlobalLoader(false);

                    // NO mostrar error si hay una b√∫squeda activa
                    if (currentSearchType !== null && item === null) {
                        return;
                    }

                    log("Error al obtener las alertas:", error);
                    // Mostrar alertas de ejemplo en caso de error
                    const alertasEjemplo = [
                        {
                            id: 1,
                            type_event_name: "Accidente",
                            camera_name: "C√°mara 1",
                            location: "Estacionamientos S1",
                            init_time_frame: new Date().toISOString()
                        },
                        {
                            id: 2,
                            type_event_name: "Aglomeraci√≥n",
                            camera_name: "C√°mara 2",
                            location: "Recepci√≥n",
                            init_time_frame: new Date(Date.now() - 10000000).toISOString()
                        }
                    ];

                    // **MODIFICACI√ìN: Solo actualizar en caso de error si no hay b√∫squeda activa**
                    if (currentSearchType === null) {
                        // Guardar tambi√©n en caso de error
                        if (item === null && currentSearchType === null) {
                            initialAlerts = [...alertasEjemplo];
                            lastKPUpdate = new Date();
                            calculateTrendData();

                            // Resaltar c√°maras de ejemplo
                            alertHighlightedCameras = {};
                        }
                        
                        renderTimelineList(alertasEjemplo);
                        updateAllMetrics();
                    }
                }
            });
        }
    }
    
    // Funci√≥n para limpiar popovers antiguos (m√°s de 1 minuto)
    function cleanupOldPopovers() {
        const now = Date.now();
        const maxAge = 60000; // 1 minuto
        
        openPopovers.forEach((data, coordinates) => {
            if (now - data.timestamp > maxAge) {
                openPopovers.delete(coordinates);
            }
        });
    }
    
    // Llamar esta funci√≥n peri√≥dicamente
    setInterval(cleanupOldPopovers, 30000); // Cada 30 segundos

    function calculateTrendData() {
        if (initialAlerts.length === 0) return;

        const now = new Date();
        kpiTrendData = [];

        // Crear intervalos de 1 hora para las √∫ltimas 4 horas, incluyendo la hora actual parcial
        for (let i = 4; i >= 1; i--) {
            const hourStart = new Date(now.getTime() - i * 60 * 60 * 1000);
            const hourEnd = i === 1 ? now : new Date(now.getTime() - (i - 1) * 60 * 60 * 1000);

            const alertsInHour = initialAlerts.filter(alert => {
                const alertTime = new Date(alert.init_time_frame);
                return alertTime >= hourStart && alertTime < hourEnd;
            });

            // Formatear la etiqueta del intervalo
            let hourLabel;
            if (i === 1) {
                // Para el √∫ltimo intervalo (hora actual), mostrar hora inicio - hora actual
                const startHour = hourStart.getHours().toString().padStart(2, '0');
                const endHour = hourEnd.getHours().toString().padStart(2, '0');
                const endMinutes = hourEnd.getMinutes().toString().padStart(2, '0');
                hourLabel = `${startHour}:00-${endHour}:${endMinutes}`;
            } else {
                const startHour = hourStart.getHours().toString().padStart(2, '0');
                const endHour = hourEnd.getHours().toString().padStart(2, '0');
                hourLabel = `${startHour}:00-${endHour}:00`;
            }

            kpiTrendData.push({
                hour: hourLabel,
                count: alertsInHour.length,
                timestamp: hourStart
            });
        }
    }

    // ==========================
    // Funci√≥n para identificar nuevas alertas (MODIFICADA)
    // ==========================
    function identificarNuevasAlertas(alertasActuales) {
      // Asegurarse de que lastAlertIds existe
      if (!lastAlertIds) {
        lastAlertIds = new Set();
      }

      // Normalizar IDs a strings para evitar problemas
      const idsActuales = new Set(alertasActuales.map(a => String(a.id)));

      // Filtrar las que no est√°n en el set ACUMULADO
      const nuevasAlertas = alertasActuales.filter(a => !lastAlertIds.has(String(a.id)));

      let now = new Date();
      nuevasAlertas.forEach(item=>{
        item.timeStamp=now;
      })

      // **--- L√çNEA CLAVE ---**
      // ACUMULAR los IDs antiguos con los nuevos.
      // Esto crea un nuevo Set con la uni√≥n de ambos.
      // ¬°Esto es lo que evita el "l√≠mite" de 300!
      lastAlertIds = new Set([...lastAlertIds, ...idsActuales]);

      return {
        nuevas: nuevasAlertas,
        todas: alertasActuales
      };
    }

    function initLegendEvents() {
      const legendItems = document.querySelectorAll('.map-legend .legend-item');
      legendItems.forEach(item => {
        item.addEventListener('click', () => {
          legendItems.forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          currentFilter = item.getAttribute('data-filter');
          applyFilter();
        });
      });
    }

    function applyFilter() {
        if(busqueda){
            return;
        }
        
        // Si hay una c√°mara seleccionada, usar filteredAlerts, sino usar alertas base
        const baseAlerts = currentlySelectedCamera ? filteredAlerts : 
                          (filteredAlerts !== null && filteredAlerts.length >= 0 ? filteredAlerts : alertas);
    
        if (currentFilter === 'all') {
            const alertsToShow = baseAlerts;
            renderTimelineList(alertsToShow);
            hideClearFiltersButton();
        } else {
            // Verificar si currentFilter es un tipo de alerta o una c√°mara
            const isAlertType = baseAlerts.some(alert => alert.type_event_name === currentFilter);
            const isCamera = baseAlerts.some(alert => alert.camera_name === currentFilter);
    
            let filteredResult;
            if (isAlertType) {
                // Filtro por tipo de alerta
                filteredResult = baseAlerts.filter(alert => alert.type_event_name === currentFilter);
            } else if (isCamera) {
                // Filtro por c√°mara
                filteredResult = baseAlerts.filter(alert => alert.camera_name === currentFilter);
            } else {
                // Si no coincide con nada, mostrar todas
                filteredResult = baseAlerts;
            }
    
            renderTimelineList(filteredResult);
            
            // Mostrar bot√≥n de limpiar filtros si hay un filtro activo
            if (isAlertType || isCamera) {
                showClearFiltersButton();
            }
        }
    }

    // FUNCI√ìN PARA LIMPIAR MARCADORES
    function clearAlertMarkers() {
        log('üóëÔ∏è Limpiando todos los marcadores. Total a limpiar:', alertMarkers.length);
    
        // Cerrar y limpiar popover abierto
        if (currentlyOpenPopover && currentlyOpenPopover.popover) {
            try {
                currentlyOpenPopover.popover.open = false;
            } catch (error) {
                log('Error cerrando popover abierto:', error);
            }
            currentlyOpenPopover = null;
        }
    
        alertMarkers.forEach(({ marker, popover, coordinates }) => {
            try {
                // Cerrar popover antes de eliminar
                if (popover && popover.open) {
                    popover.open = false;
                }
    
                // Eliminar elementos del DOM
                if (marker && marker.parentNode === map) {
                    map.removeChild(marker);
                }
                if (popover && popover.parentNode === map) {
                    map.removeChild(popover);
                }
            } catch (error) {
                log(`‚ùå Error eliminando marcadores ${coordinates}:`, error);
            }
        });
    
        alertMarkers = [];
        previousAlertCoordinates.clear();
        log('‚úÖ Todos los marcadores limpiados');
    }

    // FUNCI√ìN PARA MOSTRAR DETALLES DE ALERTA (opcional)
    function showAlertDetails(alert) {
        // Puedes personalizar esto seg√∫n tus necesidades
        log('Alerta seleccionada:', alert);
        // Ejemplo: mostrar un modal o informaci√≥n en un panel
    }

    function adjustMapView(positions) {
        if (!positions.length) return;

        // Calcular bounds aproximados
        let minLat = positions[0].lat;
        let maxLat = positions[0].lat;
        let minLng = positions[0].lng;
        let maxLng = positions[0].lng;

        positions.forEach(pos => {
            minLat = Math.min(minLat, pos.lat);
            maxLat = Math.max(maxLat, pos.lat);
            minLng = Math.min(minLng, pos.lng);
            maxLng = Math.max(maxLng, pos.lng);
        });

        // Calcular centro
        const centerLat = (minLat + maxLat) / 2;
        const centerLng = (minLng + maxLng) / 2;

        // Calcular zoom/range aproximado basado en la extensi√≥n
        const latRange = maxLat - minLat;
        const lngRange = maxLng - minLng;
        const maxRange = Math.max(latRange, lngRange);

        // Ajustar range basado en la extensi√≥n (valores emp√≠ricos)
        let range = 300;
        if (maxRange > 0.1) range = 1000;
        if (maxRange > 0.01) range = 500;
        if (maxRange > 0.001) range = 100;

        // Actualizar el mapa - FORMA CORRECTA
        if (map) {
            map.setAttribute('center', `${centerLat}, ${centerLng}`);
            map.setAttribute('range', range.toString());
        }
    }

    function renderTimelineList(data) {
        const timelineList = document.getElementById('timelineList');
        if (!data || data.length === 0) {
            timelineList.innerHTML = '<div class="loading">No hay alertas disponibles para los filtros aplicados</div>';
            return;
        }
    
        // El resto del c√≥digo de renderTimelineList permanece igual...
        timelineList.innerHTML = '';
    
        // Ordenar por fecha m√°s reciente primero
        const sortedData = [...data].sort((a, b) => new Date(b.init_time_frame) - new Date(a.init_time_frame));
        const now = new Date();
    
        sortedData.forEach(item => {
            const li = document.createElement('li');
            li.setAttribute('data-id', item.main_id||item.id);
            li.setAttribute('data-type', item.type_event_name?item.type_event_name.toLowerCase():"Detecci√≥n");

            const time = new Date(item.init_time_frame||item.epoch_frame);
            const formattedTime = time.toLocaleString('es-PE');

            // CALCULAR TIEMPO TRANSCURRIDO Y CATEGOR√çA
            const timeDiff = now - time;
            const minutesDiff = timeDiff / (1000 * 60);

            // Determinar categor√≠a de tiempo
            let timeCategory = 'old'; // M√°s de 15 minutos
            if (minutesDiff <= 5) {
                timeCategory = 'recent';
            } else if (minutesDiff <= 15) {
                timeCategory = 'medium';
            }

            // A√±adir clase de categor√≠a de tiempo
            li.classList.add(`time-${timeCategory}`);

            // Opacidad (manteniendo tu l√≥gica original)
            const opacity = Math.max(0.3, 1 - (Math.floor(minutesDiff / 10) * 0.15));
            li.style.opacity = opacity;

            li.innerHTML = `
                <strong>${(item.main_id||item.id) + " - " +(item.type_event_name?item.type_event_name:'Detecci√≥n') || 'Alerta'}</strong>
                <strong>${formattedTime}</strong>
                ${item.camera_name||item.cameraname} ¬∑ ${item.location || 'Ubicaci√≥n no especificada'}
                <div id='data-frame-${item.main_id||item.id}'></div>
            `;

            li.addEventListener('click', () => {
                showExpandedData(item);
            });

            timelineList.appendChild(li);
        });

        if (selectedAlert) {
            let expandedAlert = null;
            if(selectedAlert.main_id){
                expandedAlert = sortedData.find(a => a.main_id == selectedAlert.main_id);
            }else{
                expandedAlert = sortedData.find(a => a.id == selectedAlert.id);
            }
            if (expandedAlert) {
                setTimeout(() => {
                    showExpandedData(expandedAlert);
                }, 200);
            }
        }
    }

    function isValidParam(value) {
        return value !== null &&
               value !== undefined &&
               value.toString().trim() !== '' &&
               value.toString().toLowerCase() !== 'null' &&
               value.toString().toLowerCase() !== 'undefined';
    }

    function showExpandedData(alert) {

      const frameContainer = document.getElementById('data-frame-' + (alert.main_id||alert.id));
      const li = document.querySelector(`#timelineList li[data-id="${alert.main_id||alert.id}"]`);
      if (!frameContainer || !li) return;

      // ‚úÖ Si ya est√° expandida ‚Üí colapsar
      if (frameContainer.classList.contains('expanded')) {
        frameContainer.innerHTML = '';
        frameContainer.classList.remove('expanded');
        li.classList.remove('highlighted');

        // üîπ Restaurar opacidad original
        if (li.dataset.originalOpacity) {
          li.style.opacity = li.dataset.originalOpacity;
        }

        expandedAlertId = null;
        selectedAlert = null;
        log("entre")
        return;
      }

      if(selectedAlert && (selectedAlert.main_id||selectedAlert.id)!=(alert.main_id||alert.id)){
          let idToSearch = null;
          if(selectedAlert.main_id){
            idToSearch = selectedAlert.main_id;
          }else{
            idToSearch = selectedAlert.id;
          }
          let containerExpanded = document.getElementById('data-frame-' + idToSearch);
          let segment = document.querySelector(`#timelineList li[data-id="${selectedAlert.main_id||selectedAlert.id}"]`);
          if(containerExpanded && segment){
            containerExpanded.innerHTML = '';
            containerExpanded.classList.remove('expanded');
            segment.classList.remove('highlighted');
            segment.style.opacity = segment.dataset.originalOpacity;
          }
      }

        selectedAlert = alert;

      // üîπ Expandir alerta actual e iluminarla
      frameContainer.classList.add('expanded');
      li.classList.add('highlighted');
      expandedAlertId = alert.main_id||alert.id;

      // üîπ Guardar opacidad original y dejar opacidad completa al expandir
      if (!li.dataset.originalOpacity) {
        li.dataset.originalOpacity = li.style.opacity || 1;
      }
      li.style.opacity = 1;

      // üîπ Render din√°mico del contenido
      if (alert.coords_face || alert.person_coords_face || alert.coords_plate || alert.vehicle_coords_plate) {
        const personName = alert.nombre ? `${alert.nombre} ${alert.apellido}` : alert.vehicle_plate || alert.plate;
        const personTitle = alert.nombre ? "Persona Detectada" : "Veh√≠culo Detectado";
        const subTitle = alert.nombre ? "Nombre:" : "Placa:";
        const regTime = new Date(alert.fecha_registro || alert.fecha_robo || alert.list_fecha_robo);
        const formattedRegTime = regTime.toLocaleString('es-PE');

        frameContainer.innerHTML = `
          <div class="">
            <h4 class="person-details-title">${personTitle}</h4>
            <div class="detail-item">${subTitle} ${personName}</div>
            ${alert.documento_contacto || alert.num_documento || alert.list_num_documento ?
              `<div class="detail-item">${alert.tipo_documento || alert.vtipo_documento}: ${alert.documento_contacto || alert.num_documento || alert.list_num_documento}</div>` : ''}
            <div class="detail-item">Reportado: ${formattedRegTime}</div>
            <div class="detail-item">Precisi√≥n: ${alert.person_accuracy || alert.vehicle_accuracy || alert.acc_parecido || alert.accuracy_obj}%</div>
            ${alert.persona_contacto || alert.nombre_propietario || alert.list_nombre_propietario ?
              `<div class="detail-item">Contacto: ${alert.parentesco || 'Propietario'} - ${alert.persona_contacto || alert.nombre_propietario || alert.list_nombre_propietario}</div>` : ''}
            ${alert.numero_contacto || alert.contacto_propietario || alert.list_contacto_propietario ?
              `<div class="detail-item">Tel√©fono: ${alert.numero_contacto || alert.contacto_propietario || alert.list_contacto_propietario}</div>` : ''}
            <div class="person-details-images">
              <div class="person-image-container">
                <div class="person-image-label">Detecci√≥n Recortada</div>
                <div id="cropped-detection-detail" class="person-image"></div>
              </div>
              <div class="person-image-container">
                <div class="person-image-label">Foto de Referencia</div>
                <div id="person-detection-detail" class="person-image"
                  style="background-image: url(${alert.person_coords_face || alert.coords_face ?
                    `/personimages/inputs/${alert.matched_ident || alert.id}.jpg` :
                    alert.foto_frame || alert.foto})">
                </div>
              </div>
            </div>
          </div>
          <button
            style="width:100%"
            class="btn btn-success"
            onclick="event.stopPropagation(); seleccionVideo('${alert.main_id||alert.id}')">
            ‚ñ∂ Ver video
          </button>
        `;
      } else {
        frameContainer.innerHTML = `
          <div class="">
            <img src="${alert.foto_frame || alert.foto}" style="width:100%; border-radius:8px; margin-bottom:8px;">
            <button
              style="width:100%"
              class="btn btn-success"
              onclick="event.stopPropagation(); seleccionVideo('${alert.main_id||alert.id}')">
              ‚ñ∂ Ver video
            </button>
          </div>
        `;
      }

      // üîπ Si hay detecci√≥n recortada, aplicar recorte luego
      if ((alert.tracking_id || alert.xtracking_id) && (alert.foto || alert.foto_frame)) {
        setTimeout(() => applyImageCropping(alert), 100);
      }
    }

    function seleccionVideo(id){
        log("hola",id);
        if(filteredAlerts && filteredAlerts.length){
            selectedAlert = filteredAlerts.find(i => i.id == id);
            if(!selectedAlert){
                selectedAlert = filteredAlerts.find(i => i.main_id == id);
            }
        }else{
            selectedAlert = alertas.find(i => i.id == id);
            if(!selectedAlert){
                selectedAlert = alertas.find(i => i.main_id == id);
            }
        }

        if (selectedAlert) {
            if((selectedAlert.tracking_id != null || selectedAlert.xtracking_id!=null) && selectedAlert.plate==null){
                verVideoPersona(selectedAlert);
            } else {
              verVideo(selectedAlert);
            }
         }
    }

    // Funci√≥n para mostrar detalles de la alerta
    function showAlertDetails(alert) {
        selectedAlert = alert;
        const panel = domCache.alertDetails;
        const content = document.getElementById('alert-details-content');

        // Formatear la fecha
        const time = new Date(alert.init_time_frame);
        const formattedTime = time.toLocaleString('es-PE');

        $('#alert-details-title').text("Detalle de Alerta: "+alert.id+" - "+(alert.type_event_name?alert.type_event_name:'No identificado'));

        // Construir el contenido b√°sico
        let html = `
        <div style="max-width:320px">
            <div class="detail-item">
                <h4 class="person-details-title">Datos de la c√°mara</h4>
            </div>
            <div class="detail-item">
                <span class="detail-label">C√°mara:</span>
                <span class="detail-value">${alert.camera_name}</span>
            </div>
            <div class="detail-item">
                <span class="detail-label">Ubicaci√≥n:</span>
                <span class="detail-value">${alert.location}</span>
            </div>
            <div class="detail-item">
                <span class="detail-label">Fecha y Hora:</span>
                <span class="detail-value">${formattedTime}</span>
            </div>
        `;

        // A√±adir informaci√≥n adicional si est√° disponible
        if (alert.nombre_objetivo) {
            html += `
                <div class="detail-item">
                    <span class="detail-label">Objetivo:</span>
                    <span class="detail-value">${alert.nombre_objetivo}</span>
                </div>
            `;
        }

        if (alert.nombre_cuadrante) {
            html += `
                <div class="detail-item">
                    <span class="detail-label">Cuadrante:</span>
                    <span class="detail-value">${alert.nombre_cuadrante}</span>
                </div>
            `;
        }
        const date = new Date(alert.epoch_frame);

        // Format the date to 'YYYY-MM-DD'
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const formattedDate = `${year}-${month}-${day}`;

        // Get the hour and pad it with a leading zero if necessary
        const hour = String(date.getHours()).padStart(2, '0');

        // Construct the full path using a template literal
        const filePath = `/vframes/${formattedDate}/${alert.camera_id}/${hour}/${alert.epoch_frame}.jpeg`;

        html+=` <br>
                ${alert.foto?`<div class="person-name">
                    <span>Frame:</span>
                    <img src="${alert.foto}" style="width:100%">
                </div>`:``}
            </div>`;

        // A√±adir informaci√≥n de persona/veh√≠culo si est√° disponible
        if (alert.person_coords_face !== null || alert.vehicle_coords_plate !== null) {
            const personName = alert.nombre ? `${alert.nombre} ${alert.apellido}` : alert.vehicle_plate;
            const personTitle = alert.nombre ? "Persona Detectada" : "Veh√≠culo Detectado";
            const subTitle = alert.nombre ? "Nombre:" : "Placa:";
            const time = new Date(alert.fecha_registro||alert.fecha_robo);
            const formattedTime = time.toLocaleString('es-PE');

            html += `
                <div class="person-details-section">
                    <h4 class="person-details-title">${personTitle}</h4>
                    <div class="person-name">
                        <div>${subTitle} ${personName}</div>
                        ${alert.documento_contacto||alert.num_documento?`<div>${alert.tipo_documento||alert.vtipo_documento}: ${alert.documento_contacto||alert.num_documento}</div>`:``}
                        <div>Reportado: ${formattedTime}</div>
                        <div>Precisi√≥n: ${alert.person_accuracy||alert.vehicle_accuracy}%</div>
                        ${alert.persona_contacto||alert.nombre_propietario?`<div>Persona de Contacto: ${alert.parentesco||'Propietario'} - ${alert.persona_contacto||alert.nombre_propietario}</div>`:``}
                        ${alert.numero_contacto||alert.contacto_propietario?`<div>Telefono de contacto: ${alert.numero_contacto||alert.contacto_propietario}</div>`:``}
                    </div>
                    <div class="person-details-images">
                        <div class="person-image-container">
                            <div class="person-image-label">Foto de Referencia</div>
                            <div id="person-detection-detail"
                                 class="person-image"> </div>
                        </div>
                        <div class="person-image-container">
                            <div class="person-image-label">Detecci√≥n Recortada</div>
                            <div id="cropped-detection-detail"
                                 class="person-image"></div>
                        </div>
                    </div>
                </div>
            `;
        }

        content.innerHTML = html;

        // Mostrar el panel
        panel.style.display = 'block';

        // Si hay una detecci√≥n recortada, aplicar el recorte
        if (alert.tracking_id !== null && alert.foto) {
            setTimeout(() => {
                applyImageCropping(alert);
            }, 100);
        }
    }

    // Evento para el bot√≥n de ver video
    document.getElementById('view-video-btn').addEventListener('click', () => {
        if (selectedAlert) {
            if(selectedAlert.tracking_id != null){
                verVideoPersona(selectedAlert);
            } else {
                verVideo(selectedAlert);
            }
        }
    });
    
    function safeClearMarkers() {
        // Limpiar marcadores de alertas
        markers.forEach(marker => {
            marker.setMap(null);
        });
        markers = [];

        // Cerrar infoWindow
        if (infoWindow) {
            infoWindow.close();
        }
    }

    // Controles del dashboard
    const root = document.getElementById('civix-neo');
    const splash = document.getElementById('splash');
    const dashboard = document.getElementById('dashboard');
    const controls = document.getElementById('controls');

    function hideDashboard() {
        
        clearCurrentRoute();
        isDashboardVisible = false;
        dashboard.style.display = 'none';
        controls.style.display = 'none';
        splash.style.display = 'flex';

        if (alertInterval) {
            clearInterval(alertInterval);
            alertInterval = null;
        }
        
        alertas = [];

        lastAlertIds.clear();

        if (kpiUpdateInterval) {
            clearInterval(kpiUpdateInterval);
            kpiUpdateInterval = null;
        }

        safeClearMarkers();

        //NUEVO
        // Limpiar intervalo de obtainLastFrame
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }
        
        // NUEVO: Limpiar ruta actual al salir del dashboard
        if (currentRoute) {
            clearCurrentRoute();
        }

        /*
        // NUEVO: Limpiar el cache de im√°genes de c√°maras
        cameraImageCache.clear();

        // NUEVO: Resetear filtro de c√°maras
        filtroCamara = '';
        const inputFiltro = document.getElementById('input-filtro-camara');
        if (inputFiltro) {
            inputFiltro.value = '';
        }
        */
        
        // LIMPIAR INTERVALOS DE C√ÅMARA
        cameraUpdateIntervals.forEach((interval, cameraId) => {
            clearInterval(interval);
        });
        cameraUpdateIntervals.clear();

        // RESETEO DE B√öSQUEDAS ACTIVAS
        currentSearchType = null;
        currentSearchResults = null;

        // Ocultar formularios de b√∫squeda
        domCache.placaSearchForm.style.display = 'none';
        document.getElementById('caracteristicas-search-form').style.display = 'none';
        domCache.searchResults.innerHTML = '';
        domCache.caracteristicasResults.innerHTML = '';

        // Limpiar inputs de b√∫squeda
        document.getElementById('placa-input').value = '';
        document.getElementById('txtFechaIni').value = '';
        document.getElementById('txtFechaFin').value = '';
        document.getElementById('txtsexo').value = 'all';
        document.getElementById('txtcolorsup').value = 'all';
        document.getElementById('txtcolorinf').value = 'all';
        document.getElementById('txtedad').value = 'all';

        closeModal();

        // Cerrar el panel de detalles de alerta al salir del dashboard
        const alertDetails = domCache.alertDetails;
        if (alertDetails) {
            alertDetails.style.display = 'none';
        }

        // Detener el intervalo de actualizaci√≥n
        if (alertasInterval) {
            clearInterval(alertasInterval);
            alertasInterval = null;
        }

        // ==========================
        // RESETEO COMPLETO DEL ESTADO
        // ==========================

        alertas = [];
        filteredAlerts = null; // Resetear a null en lugar de array vac√≠o
        currentFilter = 'all';
        lastAlertIds = new Set();
        filteredCamerasByInteres = null;
        busqueda = null;

        // LIMPIAR VARIABLES DE B√öSQUEDA - NUEVO
        currentSearchType = null;
        currentSearchResults = null;

        // LIMPIAR VARIABLES DE RUTA
        currentRoute = null;
        routeAnimationProgress = 0;

        // Resetear selecciones de interfaz
        selectedInteresItem = null; // <-- A√ëADIDO: Resetear la persona de inter√©s seleccionada
        selectedAlert = null;

      // Cerrar y resetear modal de inter√©s si est√° abierto
      if (interesOvl.style.display !== 'none') {
        interesOvl.style.display = 'none';
        domCache.interesModalContent.innerHTML = '<div class="loading">Cargando...</div>';
      }

      // Cerrar y resetear modal de video si est√° abierto
      if (videoOvl.style.display !== 'none') {
        closeVideoModal();
      }

      // A√ëADIDO: Ocultar el panel de persona seleccionada y restaurar el bot√≥n de b√∫squeda avanzada
      domCache.selectedPersonBox.style.display = 'none';
        domCache.btnBackToAll.style.display = 'none';
        document.getElementById('selectedPersonDetails').innerHTML = 'Seleccione una persona o veh√≠culo para continuar.';

      // A√ëADIDO: Restaurar el t√≠tulo del timeline
      domCache.titlePanel.textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
    }

    const modal = document.querySelector("#civix-neo .modal");
    const overlay = document.getElementById("ovl");
    const mtitle = document.getElementById("mtitle");
    const mbody = document.getElementById("mbody");
    const mclose = document.getElementById("mclose");

    function showModal(title, content) {
        mtitle.textContent = title;
        mbody.innerHTML = content;
        overlay.style.display = 'flex';
    }

    function closeModal() {
        overlay.style.display = 'none';
    }

    document.getElementById('enter').addEventListener('click', showDashboard);
    document.getElementById('exit').addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        }
        hideDashboard();
    });

    document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && isDashboardVisible) {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
            hideDashboard();
        }
    });

    document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isDashboardVisible) {
            hideDashboard();
        }
    });

    // Funciones para el modal y video
    function verVideo(item) {

      resetVideoModal('regular');

      // Actualizar informaci√≥n en el modal
      document.getElementById("showcamera").textContent = item.camera_name;
      document.getElementById("showUbication").textContent = item.location;
      document.getElementById("showAlert").textContent = item.type_event_name;
      document.getElementById("showId").textContent = item.id;

      let coords_data = null;
      if(item.coords_zone){
        try {
          let poligono = JSON.parse(item.coords_zone);
          coords_data = [{
            points: poligono,
            lineColor: "blue",
            fillColor: "rgba(0,0,255,0.3)",
            lineWidth: 3
          }];
        } catch (e) {
          log("Error parsing coords_zone:", e);
        }
      }

      // Mostrar el modal primero
      showVideoModal();

      // Luego cargar el video
      callAPI({
        method: 'gestion/dolistimgevents',
        params: {
          camid: item.camera_id,
          date_start: item.init_time_frame || item.date_start,
          tracking_id: item.tracking_id
        },
        ok: function (data) {
          const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
          if (!videoContainer) return;

          videoContainer.innerHTML = '';
          try {
            videoPlayer = new videoplay(videoContainer);
          } catch (e) {
            log("Error al crear video player:", e);
            return;
          }

          const grouped = Object.values(
            data[1].reduce((acc, item) => {
              if (!acc[item.foto]) {
                acc[item.foto] = {
                  foto: item.foto,
                  coords_obj: []
                };
              }
              acc[item.foto].coords_obj.push({
                categoria: item.category,
                accuracy_obj: item.accuracy_obj,
                colorupper: item.color_name_upper,
                colorlower: item.color_name_lower,
                plate: item.plate,
                coords: item.coords_obj.split(","),
                coordsplate: (item.coords_plate || '').split(",")
              });
              return acc;
            }, {})
          );

          try {
            videoPlayer.update(grouped, "foto", "coords_obj", coords_data);
            setTimeout(() => {
              try {
                videoPlayer.play();
              } catch (e) {
                log("Error al reproducir video:", e);
              }
            }, 500);
          } catch (e) {
            log("Error al actualizar video player:", e);
          }
        },
        error: function(error) {
          log("Error al cargar el video:", error);
        }
      });
    }

    function createCroppedImage(parentElement, imageUrl, coordsString, label, coordsObj,width,height) {
        if (!coordsString) return;

        const coords = coordsString.split(",").map(Number);
        const coords1 = coordsObj.split(",").map(Number);
        const [xf1, yf1, xf2, yf2] = coords;
        const [xb1, yb1] = coords1

        const containerW = width;
        const containerH = height;

        const x1 = xf1 + xb1;
        const y1 = yf1 + yb1;
        const w = xf2 - xf1;
        const h = yf2 - yf1;

        const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
        const w_obj = xo2 - xo1;
        const h_obj = yo2 - yo1;

        const container = document.createElement('div');
        container.className = 'image-section';

        const img = new Image();
        img.src = imageUrl;
        img.onload = () => {
            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            var scale = Math.min(containerW / w, containerH / h);
            var bgW = imgW * scale;
            var bgH = imgH * scale;

            var bgX = (containerW - w * scale) / 2 - x1 * scale;
            var bgY = (containerH - h * scale) / 2 - y1 * scale;

            container.style.backgroundImage = `url(${imageUrl})`;
            container.style.backgroundSize = `${bgW}px ${bgH}px`;
            container.style.backgroundPosition = `${bgX}px ${bgY}px`;
            container.style.backgroundRepeat = "no-repeat";
            container.style.height="100%";
        };
        parentElement.appendChild(container);
    }

    function resetVideoModal(type) {
      if (videoPlayer) {
        try {
          videoPlayer.stop();
        } catch (e) {
          log("Error al detener video player:", e);
        }
        videoPlayer = null;
      }

      const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
      if (videoContainer) videoContainer.innerHTML = '';

      const personInfoPanel = document.getElementById('person-info-panel');
      const photoShort = document.getElementById('photo-short');

      if (photoShort) {
        photoShort.style.display = type === 'person' || type === 'caracteristicas' ? 'flex' : 'none';
      }

      if (personInfoPanel) {
        personInfoPanel.style.display = (type === 'person' || type === 'caracteristicas') ? 'block' : 'none';
      }
    }

    function verVideoPersona(item) {
      resetVideoModal('person');

      // Actualizar informaci√≥n en el modal
      document.getElementById("showcamera").textContent = item.camera_name || item.cameraname;
      document.getElementById("showUbication").textContent = item.location;
      document.getElementById("showAlert").textContent = item.type_event_name || 'Detecci√≥n';
      document.getElementById("showId").textContent = item.main_id||item.id;

      const personInfoPanel = document.getElementById('person-info-panel');
      const photoShort = document.getElementById('photo-short');
      const photoName = document.getElementById('photo-name');
      photoName.style.display = `block`;
      photoShort.style.display = 'none';
      if (personInfoPanel) {
        personInfoPanel.style.display = 'block';
        photoShort.style.display = 'flex';

        dataPerson =  document.getElementById('person-data');
        const personName = item.nombre ? `${item.nombre} ${item.apellido}` : item.vehicle_plate;
        const personTitle = item.nombre ? "Persona Detectada" : "Veh√≠culo Detectado";
        const subTitle = item.nombre ? "Nombre:" : "Placa:";
        const regTime = new Date(item.fecha_registro || item.fecha_robo);
        const formattedRegTime = regTime.toLocaleString('es-PE');
        //document.getElementById('person-name').textContent = `${item.nombre ? (`Nombre: ` + item.nombre + " " + item.apellido) : `Placa: ` + item.vehicle_plate}`;
        dataPerson.innerHTML = `
            <div class="detail-item">${subTitle} ${personName}</div>
              ${item.documento_contacto || item.num_documento ?
                `<div class="detail-item">${item.tipo_documento || item.vtipo_documento}: ${item.documento_contacto || item.num_documento}</div>` : ''}
              <div class="detail-item">Reportado: ${formattedRegTime}</div>
              <div class="detail-item">Precisi√≥n: ${item.person_accuracy || item.vehicle_accuracy || item.acc_parecido}%</div>
              ${item.persona_contacto || item.nombre_propietario ?
                `<div class="detail-item">Persona de Contacto: ${item.parentesco || 'Propietario'} - ${item.persona_contacto || item.nombre_propietario}</div>` : ''}
              ${item.numero_contacto || item.contacto_propietario ?
                `<div class="detail-item">Tel√©fono de contacto: ${item.numero_contacto || item.contacto_propietario}</div>` : ''}
            `;

        const personPhoto = document.getElementById('person-photo');
        if(item.person_coords_face != null || item.coords_face){
          personPhoto.style.backgroundImage = `url(/personimages/inputs/${item.matched_ident||item.id}.jpg)`;
        } else {
          // L√≥gica para vehicle photo
          const containerW = 90;
          const containerH = 100;
          const [xf1, yf1, xf2, yf2] = (item.vehicle_coords_plate || "0,0,1,1").split(",").map(Number);
          const [xb1, yb1] = (item.vehicle_coords_obj || "0,0").split(",").map(Number);

          const x1 = xf1 + xb1;
          const y1 = yf1 + yb1;
          const w = xf2 - xf1;
          const h = yf2 - yf1;

          const [xo1, yo1, xo2, yo2] = (item.vehicle_coords_obj || "0,0,1,1").split(",").map(Number);
          const w_obj = xo2 - xo1;
          const h_obj = yo2 - yo1;

          const img = new Image();
          img.src = item.foto;
          img.onload = () => {
            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            const scale_ = Math.min(containerW / w_obj, containerH / h_obj);
            const bgW_ = imgW * scale_;
            const bgH_ = imgH * scale_;
            const bgX_ = (containerW - w_obj * scale_) / 2 - xo1 * scale_;
            const bgY_ = (containerH - h_obj * scale_) / 2 - yo1 * scale_;

            personPhoto.style.backgroundImage = `url(${item.foto})`;
            personPhoto.style.backgroundSize = `${bgW_}px ${bgH_}px`;
            personPhoto.style.backgroundPosition = `${bgX_}px ${bgY_}px`;
          };
        }

        const croppedDetection = document.getElementById('cropped-detection');
        croppedDetection.innerHTML = '';

        createCroppedImage(croppedDetection, item.foto||item.foto_frame,
                          (item.person_coords_face||item.vehicle_coords_plate || item.coords_face),
                          'Detecci√≥n',
                          (item.person_coords_obj||item.vehicle_coords_obj || item.coords_obj),
                          90, 100);
      } else {
        if (personInfoPanel) personInfoPanel.style.display = 'none';
      }

      // Mostrar el modal primero
      showVideoModal();

      let tracking_id=item.tracking_id || item.xtracking_id;
      let ident = item.matched_ident || item.id;
      // Luego cargar el video seg√∫n el tipo
      if(item.person_coords_face != null || item.coords_face){
        callAPI({
          method: 'gestion/getframesperson',
          params: {
            camara: item.camera_id,
            tracking_id: tracking_id,
            documento: ident,
          },
          ok: function (data) {
            const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
            if (!videoContainer) return;

            videoContainer.innerHTML = '';
            videoPlayer = new videoplay(videoContainer);

            const frames = data;
            const grouped = Object.values(
              frames.reduce((acc, frame) => {
                if (!acc[frame.foto]) {
                  acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
                }
                acc[frame.foto].coords_obj.push({
                  categoria: frame.category,
                  accuracy_obj: frame.acc_parecido,
                  colorupper: frame.color_name_upper,
                  colorlower: frame.color_name_lower,
                  coords: (frame.coords_obj || '').split(","),
                  coordsplate: (frame.coords_face || '').split(","),
                  plate: item.nombre + " " + item.apellido
                });
                return acc;
              }, {})
            ).sort((a, b) => a.foto.localeCompare(b.foto));

            videoPlayer.update(grouped, "foto", "coords_obj", null);
            setTimeout(() => {
              try {
                videoPlayer.play();
              } catch (e) {
                log("Error al reproducir video:", e);
              }
            }, 100);
          },
          error: function(error) {
            log("Error al cargar video de persona:", error);
          }
        });
      } else {
        callAPI({
          method: 'gestion/dolistimgbytrackid',
          params: {
            cameraid: item.camera_id,
            tracking_id: item.tracking_id
          },
          ok: function(data) {
            const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
            if (!videoContainer) return;

            videoContainer.innerHTML = '';
            videoPlayer = new videoplay(videoContainer);

            const frames = data[2];
            const grouped = Object.values(
              frames.reduce((acc, frame) => {
                if (!acc[frame.foto]) {
                  acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
                }
                acc[frame.foto].coords_obj.push({
                  categoria: frame.category,
                  accuracy_obj: frame.accuracy_obj,
                  colorupper: frame.color_name_upper,
                  colorlower: frame.color_name_lower,
                  coords: (frame.coords_obj || '').split(","),
                  coordsplate: (frame.coords_plate || '').split(","),
                  plate: frame.plate
                });
                return acc;
              }, {})
            ).sort((a, b) => a.foto.localeCompare(b.foto));

            videoPlayer.update(grouped, "foto", "coords_obj", null);
            setTimeout(() => {
              try {
                videoPlayer.play();
              } catch (e) {
                log("Error al reproducir video:", e);
              }
            }, 100);
          },
          error: function(error) {
            log("Error al cargar video por trackid:", error);
          }
        });
      }
    }

    function buildLegend(alertTypes) {
      const legendContainer = document.querySelector('.map-legend');
      if (!legendContainer) return;

      legendContainer.innerHTML = '';

      const alertCounts = {};
      alertas.forEach(alert => {
        const type = alert.type_event_name;
        alertCounts[type] = (alertCounts[type] || 0) + 1;
      });

      const totalAlerts = alertas.length;

      const legendHeader = document.createElement('div');
      legendHeader.className = 'legend-header';
      legendHeader.innerHTML = `
        <div class="legend-title" style="margin-right:3em">Filtrar alertas</div>
        <button class="legend-toggle">‚àí</button>
      `;
      legendContainer.appendChild(legendHeader);

      const legendBody = document.createElement('div');
      legendBody.className = 'legend-body';
      legendBody.style.maxHeight= '280px';
      legendBody.style.overflow= 'auto';

      const allButton = document.createElement('div');
      allButton.className = 'legend-item active';
      allButton.setAttribute('data-filter', 'all');
      allButton.innerHTML = `
        <div class="legend-item-content">
          <!--<span class="legend-dot all-dot"></span>-->
          <span class="legend-label">Todas</span>
        </div>
        <span class="legend-count">${totalAlerts}</span>
      `;
      legendBody.appendChild(allButton);

      alertTypes.forEach(type => {
        if(!type){
            return;
        }
        const button = document.createElement('div');
        button.className = 'legend-item';
        button.setAttribute('data-filter', type);

        let colorClass = 'teal-dot';
        const lowerType = type.toLowerCase();

        if (lowerType.includes('accidente')) {
          colorClass = 'red-dot';
        } else if (lowerType.includes('aglomeracion') || lowerType.includes('restringida') || lowerType.includes('zona')) {
          colorClass = 'orange-dot';
        }

        button.innerHTML = `
          <div class="legend-item-content">
            <!--<span class="legend-dot ${colorClass}"></span>-->
            <span class="legend-label">${type}</span>
          </div>
          <span class="legend-count">${alertCounts[type] || 0}</span>
        `;
        legendBody.appendChild(button);
      });

      legendContainer.appendChild(legendBody);

      // Event listeners para la leyenda
      const toggleBtn = legendHeader.querySelector('.legend-toggle');
      toggleBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        legendContainer.classList.toggle('minimized');
        toggleBtn.textContent = legendContainer.classList.contains('minimized') ? '+' : '‚àí';
      });

      legendHeader.addEventListener('click', function(e) {
        if (e.target === toggleBtn) return;
        if (legendContainer.classList.contains('minimized')) {
          legendContainer.classList.remove('minimized');
          toggleBtn.textContent = '‚àí';
        }
      });

      initLegendEvents();
    }

    function resetModal(type) {
        if (videoPlayer) {
            try {
                videoPlayer.stop();
            } catch (e) {
                log("Error al detener video player:", e);
            }
            videoPlayer = null;
        }

        const videoContainer = document.querySelector("#showVideoModal .video-player-wrapper");
        if (videoContainer) videoContainer.innerHTML = '';

        const personInfoPanel = document.getElementById('person-info-panel');
        const modalDialog = document.getElementById('videoModalDialog');

        if (personInfoPanel && modalDialog) {
            if (type === 'person') {
                personInfoPanel.style.display = 'block';
                modalDialog.classList.add('modal-lg');
            } else {
                personInfoPanel.style.display = 'none';
                modalDialog.classList.remove('modal-lg');
            }
        }

        $('#showVideoModal').off('shown.bs.modal');
    }

    // Eventos del modal
    $("#showVideoModal").on("show.bs.modal", function () {
    // No hay equivalente en gmp-map-3d
    });

    $("#showVideoModal").on("shown.bs.modal", function () {
        // No necesitamos invalidateSize para gmp-map-3d
    });

    $("#showVideoModal").on("hide.bs.modal", function () {
        // No hay equivalente en gmp-map-3d
    });

    $("#showVideoModal").on("hidden.bs.modal", function () {
        resetModal(null);
        if (videoPlayer) {
            try {
                videoPlayer.stop();
            } catch (e) {
                log("Error al detener video player:", e);
            }
        }
        // No necesitamos invalidateSize para gmp-map-3d
    });

    function calculateExtendedMetrics() {
      // Usar initialAlerts en lugar de alertas para KPIs est√°ticos
      if (initialAlerts.length === 0) return null;

      const totalAlerts = initialAlerts.length;

      // Distribuci√≥n por tipos principales (usando initialAlerts)
      const typeCounts = {};
      initialAlerts.forEach(alert => {
        const type = alert.type_event_name;
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });

      const topTypes = Object.entries(typeCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

      // Alertas por c√°mara (Top 5) - usando initialAlerts
      const alertsByCamera = {};
      initialAlerts.forEach(alert => {
        const camera = alert.camera_name || 'Desconocida';
        alertsByCamera[camera] = (alertsByCamera[camera] || 0) + 1;
      });

      const topCameras = Object.entries(alertsByCamera)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const alertsByTarget = {};
        listaAlertas.forEach(alert => {
            const target = alert.nombre_objetivo || 'Desconocido';
            alertsByTarget[target] = (alertsByTarget[target] || 0) + 1;
        });

      const topTargets = Object.entries(alertsByTarget)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);

      return {
        totalAlerts,
        topTypes,
        topCameras,
        trendData: kpiTrendData, // Incluir datos de tendencia
        timestamp: lastKPUpdate ? lastKPUpdate.toLocaleTimeString('es-PE') : 'N/A' // Timestamp
      };
    }

    function updateTargetMetrics(topTargets) {
        const container = document.getElementById('target-metrics');
        if (!container) return;

        if (topTargets.length === 0) {
            container.innerHTML = '<div class="no-data">No hay datos de objetivos</div>';
            return;
        }

        // Encontrar el valor m√°ximo para escalar las barras
        const maxValue = Math.max(...topTargets.map(([_, count]) => count));

        let html = '';
        topTargets.forEach(([target, count]) => {
            const widthPercentage = (count / maxValue) * 100;
            // Acortar el nombre del objetivo para la etiqueta
            const shortTarget = target.length > 25 ? target.substring(0, 22) + '...' : target;
            html += `
                <div class="bar-item" data-target="${target}">
                    <div class="bar-label" title="${target}">${shortTarget}</div>
                    <div class="bar-chart">
                        <div class="bar-fill" style="width: ${widthPercentage}%"></div>
                    </div>
                    <div class="bar-value">${count}</div>
                </div>
            `;
        });

        container.innerHTML = html;

        // A√±adir event listeners para filtrar por objetivo
        container.querySelectorAll('.bar-item').forEach(item => {
            item.addEventListener('click', () => {
                const targetName = item.getAttribute('data-target');
                currentFilter = targetName;
                filteredAlerts = listaAlertas.filter(alert => alert.nombre_objetivo === targetName);
                renderTimelineList(filteredAlerts);

                showClearFiltersButton();
            });
        });
    }

    function updateAlertTypeMetrics(topTypes) {
        const container = document.getElementById('alert-type-metrics');
        if (!container) return;

        if (!topTypes || topTypes.length === 0) {
            container.innerHTML = '<div class="no-data">No hay tipos de alerta</div>';
            return;
        }

        // Encontrar el valor m√°ximo para escalar las barras
        const maxValue = Math.max(...topTypes.map(([_, count]) => count));

        let html = '';
        topTypes.forEach(([type, count]) => {
            const widthPercentage = (count / maxValue) * 100;

            // Determinar el color seg√∫n el tipo de alerta
            let colorClass = 'teal';
            const lowerType = type.toLowerCase();

            if (lowerType.includes('accidente')) {
                colorClass = '#22e6d9';
            } else if (lowerType.includes('aglomeracion') ||
                       lowerType.includes('restringida') ||
                       lowerType.includes('zona')) {
                colorClass = 'teal';
            }

            html += `
                <div class="alert-type-item" data-type="${type}">
                    <div class="alert-type-label" title="${type}">${type}</div>
                    <div class="alert-type-chart">
                        <div class="alert-type-fill ${colorClass}" style="width: ${widthPercentage}%"></div>
                    </div>
                    <div class="alert-type-value ${colorClass}">${count}</div>
                </div>
            `;
        });

        container.innerHTML = html;

        // A√±adir event listeners para filtrar por tipo de alerta
        container.querySelectorAll('.alert-type-item').forEach(item => {
            item.addEventListener('click', () => {
                const alertType = item.getAttribute('data-type');
                currentFilter = alertType;
                applyFilter();
                updateLegendSelection(alertType);

                showClearFiltersButton();
            });
        });
    }

    function clearAllFilters() {
        log('üîÑ Limpiando todos los filtros...');
        
        currentFilter = 'all';
        
        // Resetear filtro de c√°mara tambi√©n
        resetCameraFilter();
        
        // Actualizar la selecci√≥n en la leyenda
        updateLegendSelection('all');
    
        // Ocultar el bot√≥n de limpiar filtros
        hideClearFiltersButton();
        
        // Asegurarse de que el panel de detalles est√© oculto
        const alertDetails = domCache.alertDetails;
        if (alertDetails) {
            alertDetails.style.display = 'none';
        }
        
        log('‚úÖ Todos los filtros limpiados');
    }

    // Funci√≥n para actualizar la selecci√≥n en la leyenda del mapa
    function updateLegendSelection(selectedType) {
        const legendItems = document.querySelectorAll('.map-legend .legend-item');
        legendItems.forEach(item => {
            const filterValue = item.getAttribute('data-filter');
            if (filterValue === selectedType) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
    }

    // Modificar la funci√≥n updateAllMetrics para incluir el nuevo gr√°fico
    function updateAllMetrics() {
      const metrics = calculateExtendedMetrics();
      if (!metrics) return;

      // Actualizar el timestamp en el encabezado
      const timestampElement = document.getElementById('kpi-timestamp');
      if (timestampElement) {
        timestampElement.textContent = `Actualizado: ${metrics.timestamp}`;
      }

      // El resto del c√≥digo permanece igual...
      document.getElementById('total-alerts').textContent = metrics.totalAlerts;
      updateAlertTypeMetrics(metrics.topTypes);
      updateCameraMetrics(metrics.topCameras);
      updateTargetMetrics(metrics.topTargets);
      updateTrendChart(metrics.trendData);
    }

    // Reemplazar las funciones updateCameraMetrics y updateLocationMetrics
    function updateCameraMetrics(topCameras) {
        const container = document.getElementById('camera-metrics');
        if (!container) return;

        if (topCameras.length === 0) {
            container.innerHTML = '<div class="no-data">No hay datos de c√°maras</div>';
            return;
        }

        // Encontrar el valor m√°ximo para escalar las barras
        const maxValue = Math.max(...topCameras.map(([_, count]) => count));

        let html = '';
        topCameras.forEach(([camera, count]) => {
            const widthPercentage = (count / maxValue) * 100;
            html += `
                <div class="bar-item" data-camera="${camera}">
                    <div class="bar-label" title="${camera}">${camera}</div>
                    <div class="bar-chart">
                        <div class="bar-fill" style="width: ${widthPercentage}%"></div>
                    </div>
                    <div class="bar-value">${count}</div>
                </div>
            `;
        });

        container.innerHTML = html;

        container.querySelectorAll('.bar-item').forEach(item => {
            item.addEventListener('click', () => {
                const cameraName = item.getAttribute('data-camera');
                currentFilter = cameraName;
                filteredAlerts = listaAlertas.filter(alert => alert.camera_name === cameraName);
                renderTimelineList(filteredAlerts);

                showClearFiltersButton();
            });
        });
    }

    // A√±adir bot√≥n para resetear los filtros (opcional)
    // Agregar este c√≥digo despu√©s de la inicializaci√≥n de los gr√°ficos de barras
    function addResetFiltersButton() {
        const kpiContainer = document.getElementById('kpi-container');
        if (!kpiContainer) return;

        const resetButton = document.createElement('button');
        resetButton.textContent = 'Restablecer filtros';
        resetButton.className = 'btn btn-accent';
        resetButton.style.marginTop = '10px';
        resetButton.style.width = '100%';
        resetButton.addEventListener('click', () => {
            currentFilter = 'all';
            applyFilter();
        });

        kpiContainer.appendChild(resetButton);
    }

    // Funci√≥n para actualizar la UI con las m√©tricas - MODIFICADA
    function updateKPIs() {
        const metrics = calculateExtendedMetrics(); // Cambiado de calculateMetrics() a calculateExtendedMetrics()
        if (!metrics) return;

        // Actualizar valores en la UI
        document.getElementById('total-alerts').textContent = metrics.totalAlerts;
        // Actualizar lista de tipos principales - NUEVO C√ìDIGO
        const typesContainer = document.getElementById('top-types-list');
        if (typesContainer) {
            typesContainer.innerHTML = '';

            if (metrics.topTypes.length === 0) {
                typesContainer.innerHTML = '<div class="no-types">No hay tipos para mostrar</div>';
            } else {
                metrics.topTypes.forEach(([type, count]) => {
                    const typeItem = document.createElement('div');
                    typeItem.className = 'type-item';
                    typeItem.innerHTML = `
                        <span class="type-name">${type}</span>
                        <span class="type-count">${count}</span>
                    `;
                    typesContainer.appendChild(typeItem);
                });
            }
        }
    }

    // Funci√≥n para aplicar recorte a la imagen de detecci√≥n
    function applyImageCropping(alert) {
      const croppedDetection = document.getElementById('cropped-detection-detail');
      if (!croppedDetection) return;

      croppedDetection.innerHTML = '';
      createCroppedImage(croppedDetection, alert.foto||alert.foto_frame,
                        (alert.person_coords_face || alert.vehicle_coords_plate || alert.coords_face || alert.coords_plate),
                        'Detecci√≥n',
                        (alert.person_coords_obj || alert.vehicle_coords_obj || alert.coords_obj),
                        120, 125);
    }

    // Funci√≥n para crear imagen recortada
    function createCroppedImage(parentElement, imageUrl, coordsString, label, coordsObj, width, height) {
      if (!coordsString) return;

      const coords = coordsString.split(",").map(Number);
      const coords1 = coordsObj.split(",").map(Number);
      const [xf1, yf1, xf2, yf2] = coords;
      const [xb1, yb1] = coords1;

      const containerW = width;
      const containerH = height;

      const x1 = xf1 + xb1;
      const y1 = yf1 + yb1;
      const w = xf2 - xf1;
      const h = yf2 - yf1;

      const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
      const w_obj = xo2 - xo1;
      const h_obj = yo2 - yo1;

      const container = document.createElement('div');
      container.className = 'image-section';

      const img = new Image();
      img.src = imageUrl;
      img.onload = () => {
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;
        const scale = Math.min(containerW / w, containerH / h);
        const bgW = imgW * scale;
        const bgH = imgH * scale;

        const bgX = (containerW - w * scale) / 2 - x1 * scale;
        const bgY = (containerH - h * scale) / 2 - y1 * scale;

        container.style.backgroundImage = `url(${imageUrl})`;
        container.style.backgroundSize = `${bgW}px ${bgH}px`;
        container.style.backgroundPosition = `${bgX}px ${bgY}px`;
        container.style.backgroundRepeat = "no-repeat";
        container.style.width = `${containerW}px`;
        container.style.height = `${containerH}px`;
      };
      parentElement.appendChild(container);
    }

    function createCroppedImageCaracteristicas(parentElement, imageUrl, coordsObj, width, height) {
        if (!coordsObj) return;

        const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
        const w_obj = xo2 - xo1;
        const h_obj = yo2 - yo1;

        const containerW = width;
        const containerH = height;

        const img = new Image();
        img.src = imageUrl;
        img.onload = () => {
            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            const scale = Math.min(containerW / w_obj, containerH / h_obj);
            const bgW = imgW * scale;
            const bgH = imgH * scale;

            const bgX = (containerW - w_obj * scale) / 2 - xo1 * scale;
            const bgY = (containerH - h_obj * scale) / 2 - yo1 * scale;

            parentElement.style.backgroundImage = `url(${imageUrl})`;
            parentElement.style.backgroundSize = `${bgW}px ${bgH}px`;
            parentElement.style.backgroundPosition = `${bgX}px ${bgY}px`;
            parentElement.style.backgroundRepeat = "no-repeat";
            parentElement.style.width = `${containerW}px`;
            parentElement.style.height = `${containerH}px`;
            parentElement.style.borderRadius = "6px";
        };
        img.onerror = () => {
            parentElement.innerHTML = '<div style="color: var(--ink); text-align: center; padding-top: 40px;">Error al cargar imagen</div>';
        };
    }

    function showClearFiltersButton() {
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        if (clearFiltersBtn || currentlySelectedCamera) {
            filtersApplied = true;
            clearFiltersBtn.disabled = false;
            clearFiltersBtn.style.display = 'block';
            
            // Asegurar que tenga el event listener correcto
            clearFiltersBtn.onclick = function() {
                clearAllFilters();
            };
            
            // Forzar estilos para asegurar que sea visible y habilitado
            clearFiltersBtn.style.opacity = '1';
            clearFiltersBtn.style.pointerEvents = 'auto';
            clearFiltersBtn.style.cursor = 'pointer';
            
            // Peque√±o retraso para permitir que la animaci√≥n funcione correctamente
            setTimeout(() => {
                clearFiltersBtn.classList.add('visible');
            }, 10);
        } else {
            console.warn('‚ö†Ô∏è Bot√≥n de limpiar filtros no encontrado');
        }
    }
    
    // Tambi√©n modificar hideClearFiltersButton para ser m√°s espec√≠fico
    function hideClearFiltersButton() {
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        if (clearFiltersBtn) {
            filtersApplied = false;
            clearFiltersBtn.disabled = true;
            clearFiltersBtn.classList.remove('visible');
    
            // Ocultar despu√©s de que termine la animaci√≥n, pero solo si no hay filtros aplicados
            setTimeout(() => {
                if (!filtersApplied && !currentlySelectedCamera) {
                    clearFiltersBtn.style.display = 'none';
                }
            }, 300);
        }
    }
    
    function setupMapClickHandler() {
        map.addEventListener('click', (event) => {
            
            // Verificar si el clic fue en un marcador
            const clickedOnMarker = event.target.closest('gmp-marker-3d') || 
                                   event.target.closest('gmp-marker-3d-interactive');
            
            // Verificar si el clic fue en un popover
            const clickedOnPopover = event.target.closest('gmp-popover');
    
            // Solo resetear si se hace clic directamente en el mapa (no en marcador ni popover)
            if (!clickedOnMarker && !clickedOnPopover) {
                if (currentlySelectedCamera) {
                    resetCameraFilter();
                }
                
                // Cerrar popover abierto si existe
                if (currentlyOpenPopover) {
                    try {
                        currentlyOpenPopover.popover.open = false;
                        currentlyOpenPopover = null;
                    } catch (error) {
                        log('Error cerrando popover:', error);
                    }
                }
            }
    
            // Crear marcador de usuario solo si no hay c√°mara seleccionada y no se clicke√≥ en marcador existente
            if (event.detail && event.detail.latLng && !clickedOnMarker && !currentlySelectedCamera) {
                const lat = event.detail.latLng.lat;
                const lng = event.detail.latLng.lng;
                log(`üìç Creando marcador de usuario en: ${lat}, ${lng}`);
                createUserMarker(lat, lng);
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Precargar Google Maps
        loadGoogleMaps().catch(error => {
            log("Google Maps no se pudo precargar:", error);
        });

        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        if (clearFiltersBtn) {
            clearFiltersBtn.style.display = 'none';
            clearFiltersBtn.disabled = true;
            clearFiltersBtn.addEventListener('click', clearAllFilters);
        }

        const closeButton = document.querySelector('.close-details');
        if (closeButton) {
            closeButton.addEventListener('click', function() {
                const alertDetails = domCache.alertDetails;
                if (alertDetails) {
                    alertDetails.style.display = 'none';
                }
                selectedAlert = null;
            });
        }

        const viewVideoBtn = document.getElementById('view-video-btn');
        if (viewVideoBtn) {
            viewVideoBtn.addEventListener('click', function() {
                if (selectedAlert) {
                    if(selectedAlert.person_coords_face != null || selectedAlert.vehicle_plate != null){
                        verVideoPersona(selectedAlert);
                    } else {
                        verVideo(selectedAlert);
                    }
                }
            });
        }

        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabName = this.getAttribute('data-tab');
                switchTab(tabName);
            });
        });

        // Asegurar que la pesta√±a KPI est√© activa por defecto
        switchTab('kpi');
    });

    function updateTrendChart(trendData) {
        const container = document.getElementById('trend-chart-container');
        if (!container) return;

        if (!trendData || trendData.length === 0) {
            container.innerHTML = '<div class="no-data">No hay datos de tendencia</div>';
            return;
        }

        // Calcular valores m√≠nimos y m√°ximos para una mejor escala
        const values = trendData.map(item => item.count);
        const maxValue = Math.max(...values);
        const minValue = Math.min(...values);
        const valueRange = maxValue - minValue;

        // Usar una escala m√°s inteligente que considere el rango de valores
        const scaleFactor = valueRange > 0 ? 70 / valueRange : 1;
        const baseHeight = 15; // Altura base m√≠nima

        let html = `
            <div style="font-size: 12px; color: var(--teal); margin-bottom: 8px; text-align: center;">
                Tendencia √∫ltimas 4 horas
            </div>
            <div class="trend-chart" style="height: 80px; display: flex; align-items: end; justify-content: space-around; gap: 8px;">
        `;

        trendData.forEach((item, index) => {
            // Calcular altura proporcional al valor dentro del rango
            let barHeight = baseHeight;
            if (valueRange > 0) {
                barHeight = baseHeight + ((item.count - minValue) * scaleFactor);
            }

            // Limitar la altura m√°xima
            barHeight = Math.min(barHeight, 70);

            const isIncreasing = index > 0 && item.count > trendData[index - 1].count;
            const isDecreasing = index > 0 && item.count < trendData[index - 1].count;

            let trendIcon = '‚Üí';
            let trendColor = '#FFC107'; // Amarillo/neutral
            if (isIncreasing) {
                trendIcon = '‚Üë';
                trendColor = '#4CAF50'; // Verde
            }
            if (isDecreasing) {
                trendIcon = '‚Üì';
                trendColor = '#F44336'; // Rojo
            }

            html += `
                <div style="display: flex; flex-direction: column; align-items: center; height: 100%;">
                ${index === trendData.length - 1 ?
                        `<div class="trend-icon" style="font-size: 14px; font-weight: bold; color: ${trendColor}; margin-top: 3px;">${trendIcon}</div>` :
                        '<div style="height: 14px;"></div>'}
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: end; height: 100%;">
                        <div class="trend-value" style="font-size: 11px; color: var(--teal); margin-bottom: 5px; font-weight: bold;">${item.count}</div>
                        <div class="trend-bar" style="width: 20px; background: linear-gradient(to top, var(--teal), #1cb5a9); border-radius: 3px 3px 0 0; height: ${barHeight}px; transition: height 0.3s ease;"></div>
                    </div>
                    <div class="trend-label" style="font-size: 10px; color: var(--ink); margin-top: 5px; text-align: center; max-width: 60px; word-wrap: break-word;">${item.hour}</div>
                </div>
            `;
        });

        html += '</div>';
        container.innerHTML = html;
    }

    // Event listeners para los botones de b√∫squeda
    document.querySelectorAll('#busquedaContent .btn-default[data-search-type]').forEach(button => {
        button.addEventListener('click', function() {
            const searchType = this.getAttribute('data-search-type');
            handleSearchTypeClick(searchType);
        });
    });

    // Funci√≥n para manejar los clics en los botones de b√∫squeda
    function handleSearchTypeClick(searchType) {
        // Ocultar todos los formularios y resultados primero
        document.querySelectorAll('.search-form').forEach(form => {
            form.style.display = 'none';
        });
        domCache.searchResults.innerHTML = '';
        domCache.caracteristicasResults.innerHTML = '';

        // LIMPIAR B√öSQUEDAS ANTERIORES - NUEVO
        currentSearchType = null;
        currentSearchResults = null;
        filteredAlerts = null;
        selectedInteresItem = null;

        returnToAllAlerts();

        // Ocultar bot√≥n de volver
        //domCache.btnBackToAll.style.display = 'none';

        // Restaurar t√≠tulo original
        //domCache.titlePanel.textContent = 'Detecciones Relacionadas';

        switch(searchType) {
            case 'personas':
            case 'vehiculos':
                showInteresModal(searchType);
                break;
            case 'placa':
                currentSearchType = 'placa';
                busqueda = null;
                domCache.placaSearchForm.style.display = 'block';
                document.getElementById('placa-results').innerHTML = '';
                domCache.selectedPersonBox.style.display = 'none';
                break;
            case 'caracteristicas':
                currentSearchType = 'caracteristicas';
                busqueda = null;
                document.getElementById('caracteristicas-search-form').style.display = 'block';
                domCache.caracteristicasResults.innerHTML = '';
                domCache.selectedPersonBox.style.display = 'none';
                break;
            case 'personas-interes':
                showMultiSelectModal();
        }
    }

    function returnToAllAlerts() {
        log('üîÑ Regresando a todas las alertas...');
    
        // **NUEVO: Resetear el estado de b√∫squeda activa**
        currentSearchType = null;
        currentSearchResults = null;
        selectedInteresItem = null;
    
        // Limpiar ruta actual SI EXISTE
        if (currentRoute) {
            clearCurrentRoute();
        }
    
        // Resto del c√≥digo existente...
        busqueda = null;
    
        // Restaurar renderizado autom√°tico de marcadores
        suspendAutoMarkers = false;
    
        // Restaurar t√≠tulo
        domCache.titlePanel.textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
    
        // Ocultar bot√≥n de volver
        domCache.btnBackToAll.style.display = 'none';
    
        // Ocultar resultados de b√∫squeda por placa
        document.getElementById('placa-results').innerHTML = '';
        domCache.placaSearchForm.style.display = 'none';
        document.getElementById('placa-input').value = '';
    
        // Ocultar resultados de b√∫squeda por caracter√≠sticas
        domCache.caracteristicasResults.innerHTML = '';
        document.getElementById('caracteristicas-search-form').style.display = 'none';
    
        // Ocultar el box de persona seleccionada
        domCache.selectedPersonBox.style.display = 'none';
    
        // **MODIFICACI√ìN: Forzar recarga de todas las alertas con null expl√≠cito**
        getAlertas(busqueda);
    
        log('‚úÖ Regreso completado a todas las alertas');
    }

    function loadInteresList() {
        const container = domCache.interesModalContent;
        container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de inter√©s...</div></div>';
        callAPI({
            method: 'gestion/getiperson',
            params: {
                id_lista: 'all',
                nombre: 'all',
                ident_nro: 'all'
            },
            ok: function(data) {
                interesData = data;
                const container = domCache.interesModalContent;
                renderInteresList(data, container);
            },
            error: function(error) {
                log("Error al cargar la lista de inter√©s:", error);
                domCache.interesModalContent.innerHTML =
                    '<div class="loading">Error al cargar la lista</div>';
            }
        });
    }

    function getColors(){
        callAPI({
            method: 'gestion/color',
            ok: function (vals) {
                const seltxtcolorinf = $('#txtcolorinf');
                vals.forEach(obj => {
                    seltxtcolorinf.append(`<option value="${obj.id}"> ${obj.name}</option>`);
                });
                const seltxtcolorsup = $('#txtcolorsup');
                vals.forEach(obj => {
                    seltxtcolorsup.append(`<option value="${obj.id}"> ${obj.name}</option>`);
                });
            }
        });
    }

    function initMapSelectedPersonsPanel() {
        const panel = document.getElementById('selected-persons-map-panel');
        const toggleBtn = panel.querySelector('.selected-persons-map-toggle');

        // Actualizar el panel inicialmente
        updateMapSelectedPersonsPanel();
    }

    function initSelectionsContainer() {
        const container = document.getElementById('selected-persons-container');
        if (container) {
            updateCurrentSelections();
        }
    }

    function updateCurrentSelections() {
        const container = document.getElementById('current-selections-list');
        if (!container) return;
    
        let html = '';
    
        if (multiSelectedItems.length === 0) {
            html = '<div class="selection-placeholder">Haga clic en "Seleccionar" para a√±adir a la lista de inter√©s</div>';
        } else {
            multiSelectedItems.forEach(item => {
                const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                    item.foto : null;
    
                html += `
                    <div class="selection-item" data-id="${item.id}">
                        <div class="selection-item-info">
                        ${foto?`<img src="${foto}" class="selection-item-photo" onerror="this.onerror=null;this.src='/public/images/logowin.png';">`:`<span style="font-size:40px" class="pe-7s-car"></span>`}
                            <div class="selection-item-details">
                                <div class="selection-item-name">${item.personame || item.name || 'N/A'}</div>
                                <div class="selection-item-document">${item.documento || 'Veh√≠culo'}</div>
                            </div>
                        </div>
                        <button type="button" class="btn-remove-selection" data-id="${item.id}" title="Eliminar de la lista">‚úï</button>
                    </div>
                `;
            });
        }
    
        container.innerHTML = html;
    
        // A√±adir event listeners para los botones de eliminar - MEJORADO
        container.querySelectorAll('.btn-remove-selection').forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();
                const id = this.getAttribute('data-id');
                removeFromSelection(id);
    
                // Si el modal de selecci√≥n m√∫ltiple est√° abierto, actualizarlo tambi√©n
                const multiSelectModal = domCache.multiSelectOvl;
                if (multiSelectModal && multiSelectModal.style.display === 'flex') {
                    loadMultiSelectList();
                }
            });
        });
    }

    function updateMapSelectedPersonsPanel() {
        const panelBody = document.getElementById('selected-persons-map-body');
        if (!panelBody) return;
    
        if (!multiSelectedItems || multiSelectedItems.length === 0) {
            panelBody.innerHTML = '';
            return;
        }
    
        // MODIFICACI√ìN: Ordenar items por alertas recientes
        const sortedItems = [...multiSelectedItems].sort((a, b) => {
            const timeA = getLastAlertTimestamp(a, a.foto ? 1 : 2);
            const timeB = getLastAlertTimestamp(b, b.foto ? 1 : 2);
    
            // Los que tienen alertas recientes primero, luego por nombre
            if (timeA > 0 && timeB > 0) {
                return timeB - timeA; // M√°s reciente primero
            } else if (timeA > 0) {
                return -1; // A tiene alerta, B no
            } else if (timeB > 0) {
                return 1; // B tiene alerta, A no
            } else {
                // Ambos sin alertas, ordenar por nombre
                const nameA = (a.personame || a.name || '').toLowerCase();
                const nameB = (b.personame || b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            }
        });
    
        let html = '';
    
        sortedItems.forEach(person => {
            html += `<div class="box-interest" ${person.foto?'style="padding:8px"':''}>`;
            const photoUrl = person.foto && !person.foto.startsWith('@') ?
                person.foto : '/public/images/logowin.png';
            if(person.foto){
                html += `
                    <img src="${photoUrl}"  onclick="getPersonData('${person.id}')"
                         class="selected-person-photo" style="max-width: 50px; min-width: 50px; max-height: 50px;"
                         data-id="${person.id}"
                         title="${person.personame || person.name || 'N/A'}"
                         onerror="this.onerror=null;this.src='/public/images/logowin.png';">
                `;
            }else{
                let placaText = (person.personame || person.name || '').toString().toUpperCase();
                let primeraParte = placaText.substring(0, 3);
                let segundaParte = placaText.substring(3, 6);
                
                html += `
                    <div style="background: url('/public/images/placa.png') no-repeat center center; background-size: contain; text-align:center; display:block !important ; min-height:34px; padding-top:12px; font-size: 12px" onclick="getPersonData('${person.id}')"
                         class="selected-person-photo"
                         data-id="${person.id}"
                         title="${person.personame || person.name || 'N/A'}">
                         <span style="color: #000; font-size: 12px; text-transform: uppercase;">
                             <span>${primeraParte}-${segundaParte}</span>
                         </span>
                    </div>
                `;
            }
            html+=`</div>`;
        });
    
        panelBody.innerHTML = html;
    }

    function renderInteresList(data, container, category) {
        container.style.width='100%';

        if (!data || data.length === 0) {
            container.innerHTML = `<div class="loading">No hay ${category==1?"personas":"veh√≠culos"} de inter√©s</div>`;
            return;
        }

        // Generar un ID √∫nico para la tabla basado en la categor√≠a
        const tableId = `interesTable-${category}`;
        const filterId = `filterInteres-${category}`;

        let html = `
            <div style="margin-bottom: 15px;">
                <input type="text" id="${filterId}" placeholder="Buscar por nombre, apellido, documento, placa, etc..."
                       style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal);background:var(--panel)">
            </div>
            <div style="max-height: 400px; overflow-y: auto;">
                <table class="table table-hover-1" id="${tableId}">
                    <thead>
                        <tr>
                            ${data[0].foto?`<th>Foto</th>`:``}
                            <th>Nombre</th>
                            ${data[0].nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}
                            ${data[0].nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}
                            <th>Lista</th>
                            <th>Raz√≥n</th>
                            <th>Fecha de reporte</th>
                            ${data[0].nombre_propietario?`<th>Documento de propietario</th>`:``}
                            <th>Persona de contacto</th>
                            <th>N√∫mero de contacto</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        data.forEach(item => {
            let foto=null;
            if(item.foto){
                foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}"
                      style="width:40px; height:40px; object-fit:cover; border-radius:8px;"
                      onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                ``;
            }
            const time = new Date(item.fh_crea||item.fecha_robo||item.created_at);
            const formattedTime = time.toLocaleString('es-PE');
            let name = (item.parentesco && item.parentesco!=null?item.parentesco+' - ':'') + (item.persocontacname||item.nombre_propietario?(item.persocontacname||item.nombre_propietario):'')
            html += `
                <tr class="interes-item" data-id="${item.id}" data-tipo="${item.foto?1:2}"
                    style="cursor: pointer; border-bottom: 1px solid rgba(34,230,217,0.2);">
                    ${foto?`<td>${foto}</td>`:``}
                    <td>${item.personame || item.name || 'N/A'}</td>
                    <td>${item.documento || item.marca+" "+item.modelo || 'N/A'}</td>
                    <td>${item.edad || item.color || 'N/A'}</td>
                    <td>${obtainList(item.id_lista.toString(),item.foto?1:2) || 'N/A'}</td>
                    <td>${item.descripcion || 'N/A'}</td>
                    <td>${formattedTime || 'N/A'}</td>
                    ${category==2?(item.nombre_propietario?`<td>${item.tipo_documento+' - '+item.num_documento || 'N/A'}</td>`:`<td>N/A</td>`):``}
                    <td>${name!=''?name:'N/A' || 'N/A'}</td>
                    <td>${item.persocontac || item.contacto_propietario || 'N/A'}</td>
                </tr>
            `;
        });

        html += `
                    </tbody>
                </table>
            </div>
        `;

        container.innerHTML = html;

        // A√±adir event listener para el filtro - CORREGIDO
        const filterInput = document.getElementById(filterId);
        if (filterInput) {
            filterInput.addEventListener('input', function() {
                const filterText = this.value.toLowerCase();
                const rows = container.querySelectorAll(`#${tableId} tbody tr`);

                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    let found = false;

                    cells.forEach(cell => {
                        if (cell.textContent.toLowerCase().includes(filterText)) {
                            found = true;
                        }
                    });

                    row.style.display = found ? '' : 'none';
                });
            });
        }

        // A√±adir event listeners a las filas de la tabla - CORREGIDO
        container.querySelectorAll('.interes-item').forEach(item => {
            item.addEventListener('click', function() {
                const id = this.getAttribute('data-id');
                const tipo = this.getAttribute('data-tipo');
                selectInteresItem(id, tipo, tipo,true);
            });
        });
    }

    function obtainList(id_lista,category){
        switch(id_lista) {
            case "1":
                tipoPersona = 'Veh√≠culo Robado';
                break;
            case "2":
                tipoPersona = category==1?'Persona Sospechosa':'Veh√≠culo Sospechoso';
                break;
            case "3":
                tipoPersona = 'Persona Requisitoriada';
                break;
            case "4":
                tipoPersona = 'Persona Desaparecida';
                break;
            default:
                tipoPersona = 'Tipo no especificado';
        }

        return tipoPersona;
    }

    function selectInteresItem(id, tipo, category, boolean) {

        // NUEVO: Resetear filtro de c√°maras
        filtroCamara = '';
        const inputFiltro = document.getElementById('input-filtro-camara');
        if (inputFiltro) {
            inputFiltro.value = '';
        }

        //showGlobalLoader(true);

        // Establecer el tipo de b√∫squeda activa
        currentSearchType = 'interes';

        domCache.placaSearchForm.style.display = 'none';
        document.getElementById('caracteristicas-search-form').style.display = 'none';
        domCache.caracteristicasResults.innerHTML = '';

        // Limpiar filtros previos
        currentFilter = 'all';

        selectedInteresItem = { id, tipo };
        // INICIALIZAR CORRECTAMENTE EL FILTRO DE C√ÅMARAS
        filteredCamerasByInteres = []; // Inicializar como array vac√≠o

        let itemBusqueda=null;

        if(category==1){
            itemBusqueda = interesData.find(data => data.id.toString() == id.toString());
        }else{
            itemBusqueda = interesDataVehicle.find(data => data.id == id);
        }

        // Ocultar bot√≥n de b√∫squeda avanzada y mostrar el de volver';
        domCache.btnBackToAll.style.display = 'block';

        // Mostrar el box de persona seleccionada
        const selectedPersonBox = domCache.selectedPersonBox;
        const selectedPersonDetails = document.getElementById('selectedPersonDetails');

        const time = new Date(itemBusqueda.fecha_robo|| itemBusqueda.fh_crea || itemBusqueda.created_at);
        const formattedTime = time.toLocaleString('es-PE');

        // Determinar el tipo de persona seg√∫n id_lista
        let tipoPersona = obtainList(itemBusqueda.id_lista.toString(),category);

        // Limpiar resaltado permanente
        alertHighlightedCameras = {};

        if (itemBusqueda) {

            busqueda = itemBusqueda;
            document.getElementById("data-spinner").style.display="none";
            // Obtener alertas asociadas a esta persona de inter√©s
            const nombre = itemBusqueda.name;
            const id = itemBusqueda.id ;
            const precision = null;
            const subzonas = 'all';
            const colorsup = 'all';
            const colorinf = 'all';

            // Paso 1: Obtener la fecha y hora actuales.
            const today = new Date();

            const fechaIniDate = new Date(today);
            fechaIniDate.setHours(0, 0, 0, 0); // Establece la hora a 00:00:00.000

            const fechaIni = fechaIniDate.getTime(); // Obtiene el timestamp UNIX (milisegundos)

            const fechaFinDate = new Date(today);
            fechaFinDate.setHours(23, 59, 59, 999); // Establece la hora a 23:59:59.999

            const fechaFin = fechaFinDate.getTime(); // Obtiene el timestamp UNIX (milisegundos)

            if(category==1){
                callAPI({
                    method: "gestion/getlistpersondetect",
                    params: {
                        nombre: nombre || "all",
                        id: id,
                        precision: precision,
                        subzonas: subzonas,
                        colorsuperior: colorsup,
                        colorinferior: colorinf,
                        persona: 3,
                        fechaini: fechaIni,
                        fechafin: fechaFin,
                        edad: "all",
                        genero: "all"
                    },
                    ok: function (data) {
                        filteredAlerts = data ? [...data] : [];
                        
                        // NUEVO: Renderizar marcadores primero, luego procesar ruta
                        renderMapAndMarkers(filteredAlerts).then(() => {
                            // Luego procesar la ruta
                            if (filteredAlerts && filteredAlerts.length > 0) {
                                processRouteForInteres(filteredAlerts, 'person');
                            }
                        });
                        
                        renderTimelineList(filteredAlerts);
                        updateAllMetrics();
                    },
                    error: function (error) {
                        log("Error al obtener alertas para el inter√©s:", error);
                        filteredAlerts = [];
                        renderTimelineList([]);
                    }
                });
            } else {
                if(boolean){
                    searchByPlaca(itemBusqueda.name, true);
                } else {
                    searchByPlaca(itemBusqueda.name);
                }
            }
        }

        // Llenar los detalles de la persona (siempre mostrar esto)
        let name = (itemBusqueda.parentesco && itemBusqueda.parentesco!=null?itemBusqueda.parentesco+' - ':'') + (itemBusqueda.persocontacname||itemBusqueda.nombre_propietario?(itemBusqueda.persocontacname||itemBusqueda.nombre_propietario):'')
        // En la funci√≥n selectInteresItem, cambiar:
        selectedPersonDetails.innerHTML = `
        <div style="display:flex; gap: 0.6em">
            <div>
            <div><strong>Nombre:</strong> ${itemBusqueda.nombre || itemBusqueda.name || 'N/A'}</div>
            <div><strong>Lista:</strong> ${tipoPersona}</div>
            <div><strong>${itemBusqueda.nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}:</strong> ${itemBusqueda.documento || itemBusqueda.marca+" "+itemBusqueda.modelo || 'N/A'}</div>
            <div><strong>${itemBusqueda.nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}:</strong> ${itemBusqueda.edad || itemBusqueda.color || 'N/A'}</div>
            <div><strong>Reportado:</strong> ${formattedTime || 'N/A'}</div>
            <div><strong>Raz√≥n:</strong> ${itemBusqueda.descripcion || 'N/A'}</div>
            <div><strong>Persona de contacto:</strong> ${name || 'N/A'}</div>
            <div><strong>N√∫mero de contacto:</strong> ${itemBusqueda.persocontac || itemBusqueda.contacto_propietario || 'N/A'}</div>
            </div>
            ${itemBusqueda.foto && !itemBusqueda.foto.startsWith('@') ?
                `<div style="text-align:right;">
                    <img src="${itemBusqueda.foto}" style="max-width: 100px; border-radius: 4px;">
                </div>` : ''}
        <div>

        `;
        selectedPersonBox.style.display = 'block';

        // Cambiar el t√≠tulo del timeline
        domCache.titlePanel.textContent = 'Alertas relacionadas';

        if(boolean){
            // Cerrar el modal
            closeInteresModal();
        }
    }

    function showMultiSelectModal() {
        const modal = domCache.multiSelectOvl;
        modal.style.display = 'flex';

        // Cargar selecciones actuales del localStorage al estado temporal
        loadSavedSelections();
        tempSelectedItems = [...multiSelectedItems];

        // Cargar la lista de personas
        loadMultiSelectList();
    }

    function loadMultiSelectList() {
        const container = document.getElementById('multiSelectModalContent');
        container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de personas...</div></div>';

        callAPI({
            method: 'gestion/get_listas',
            ok: function(data) {
                renderMultiSelectList(data, container);
            },
            error: function(error) {
                log("Error al cargar la lista de inter√©s:", error);
                container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
            }
        });
    }

    // Funci√≥n para cargar selecciones del localStorage
    function loadSavedSelections() {
        try {
            const saved = localStorage.getItem('personasInteresSeleccionadas');
            if (saved) {
                multiSelectedItems = JSON.parse(saved);
            } else {
                multiSelectedItems = [];
            }
            initSelectionsContainer();
            // A√ëADIDO: Actualizar tambi√©n el panel del mapa
            updateMapSelectedPersonsPanel();
        } catch (e) {
            multiSelectedItems = [];
            initSelectionsContainer();
            updateMapSelectedPersonsPanel();
        }
    }

    // Funci√≥n para cerrar el modal de selecci√≥n m√∫ltiple
    function closeMultiSelectModal() {
        const modal = domCache.multiSelectOvl;
        modal.style.display = 'none';
    }

    // Event listeners para el nuevo modal
    document.getElementById('closeMultiSelectModal').addEventListener('click', closeMultiSelectModal);
    domCache.multiSelectOvl.addEventListener('click', function(e) {
        if (e.target === this) {
            closeMultiSelectModal();
        }
    });
    
    
    // Funci√≥n para remover una persona de la selecci√≥n temporal
    function removeFromTempSelection(id) {
        tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
        updateTempSelectionsDisplay();
    }
    
    // Funci√≥n para actualizar la visualizaci√≥n de selecciones temporales en el modal
    function updateTempSelectionsDisplay() {
        const container = document.querySelector('#multiSelectModalContent #current-selections');
        if (!container) return;
    
        let html = '';
    
        if (tempSelectedItems.length === 0) {
            html = '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
        } else {
            tempSelectedItems.forEach(item => {
                const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                    `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                    ``;
    
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            ${foto}
                            <div>
                                <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                                <div style="color: var(--ink); font-size: 12px;">${item.documento || 'N/A'}</div>
                            </div>
                        </div>
                        <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">‚úï</button>
                    </div>
                `;
            });
        }
    
        container.innerHTML = html;
    
        // Re-a√±adir event listeners para los botones de eliminar
        container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();
                const id = this.getAttribute('data-id');
                removeFromTempSelection(id);
    
                // Recargar la lista completa
                loadMultiSelectList();
            });
        });
    }
    // Event listener para el bot√≥n de guardar - MODIFICADO
    document.getElementById('saveMultiSelection').addEventListener('click', function() {
        // Guardar las selecciones temporales en la variable principal y en localStorage
        multiSelectedItems = [...tempSelectedItems];
    
        if (saveSelectionsToLocalStorage()) {
            // Actualizar todas las visualizaciones
            updateCurrentSelections();
            updateMapSelectedPersonsPanel();
            closeMultiSelectModal();
        } else {
            
        }
    });

    function checkAlertsAgainstInteres(nuevasAlertas) {
        // Cargar selecciones guardadas
        loadSavedSelections();
    
        if (!multiSelectedItems || multiSelectedItems.length === 0 || !nuevasAlertas || nuevasAlertas.length === 0) {
            return null;
        }
    
        let lastMatchingAlert = null;
        let lastTimestamp = 0;
    
        nuevasAlertas.forEach(alert => {
            multiSelectedItems.forEach(persona => {
                if ((persona.id && alert.matched_ident && persona.id.toString() === alert.matched_ident.toString()) ||
                    (persona.id && alert.dni && persona.id.toString() === alert.dni.toString())) {
    
                    const alertTime = new Date(alert.init_time_frame).getTime();
                    if (alertTime > lastTimestamp) {
                        lastTimestamp = alertTime;
                        lastMatchingAlert = alert;
                    }
    
                    // A√ëADIDO: Activar resaltado de la persona
                    setTimeout(() => {
                        highlightPersonWithAlert(persona.id);
                    }, 500);
                }
            });
        });
    
        return lastMatchingAlert;
    }
    
    

    // Funci√≥n para renderizar la lista de selecci√≥n m√∫ltiple
    function renderMultiSelectList(data, container) {
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="loading">No hay seleccionados de inter√©s</div>';
            return;
        }
    
        // Usar tempSelectedItems en lugar de multiSelectedItems
        const currentSelectionIds = tempSelectedItems.map(item => item.id);
    
        // Mostrar selecciones actuales en la parte superior
        let html = `
            <div style="margin-bottom: 20px; padding: 15px; background: var(--bg); border-radius: 8px; border: 1px solid var(--teal);">
                <h5 style="color: var(--teal); margin-top: 0; margin-bottom: 10px;">Selecciones Actuales</h5>
                <div id="current-selections" style="max-height: 150px; overflow-y: auto;">
        `;
    
        if (tempSelectedItems.length === 0) {
            html += '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
        } else {
            tempSelectedItems.forEach(item => {
                const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                    `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:8px;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                    `<span style="font-size:40px" class="pe-7s-car"></span>`;
    
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            ${foto}
                            <div>
                                <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                                <div style="color: var(--ink); font-size: 12px;">${item.documento || 'Veh√≠culo'}</div>
                            </div>
                        </div>
                        <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">‚úï</button>
                    </div>
                `;
            });
        }
    
        html += `
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <input type="text" id="filterMultiSelect" placeholder="Buscar por nombre, apellido, documento..."
                       style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
            </div>
            <div id="multiSelectTableContainer" style="max-height: 400px; overflow-y: auto;">
                <table class="table table-hover-1" id="multiSelectTable" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(34,230,217,0.1);">
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Seleccionar</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Foto</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Nombre/Placa</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Documento</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Edad</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Lista</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Raz√≥n</th>
                            <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Fecha de reporte</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
    
        data.forEach(item => {
            const isChecked = currentSelectionIds.includes(item.id);
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                `<span style="font-size:40px" class="pe-7s-car"></span>`;
    
            const time = new Date(item.fecha_robo || item.fh_crea || item.created_at);
            const formattedTime = time.toLocaleString('es-PE');
    
            html += `
                <tr class="multi-select-item" data-id="${item.id}" style="cursor: pointer; border-bottom: 1px solid rgba(34,230,217,0.1);">
                    <td style="padding: 10px;">
                        <input type="checkbox" class="person-checkbox" data-id="${item.id}" ${isChecked ? 'checked' : ''}
                               style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--teal);">
                    </td>
                    <td style="padding: 10px;">${foto}</td>
                    <td style="padding: 10px; color: var(--ink-strong);">${item.personame || item.name || 'N/A'}</td>
                    <td style="padding: 10px; color: var(--ink);">${item.documento || 'N/A'}</td>
                    <td style="padding: 10px; color: var(--ink);">${item.edad || 'N/A'}</td>
                    <td style="padding: 10px; color: var(--ink);">${obtainList(item.id_lista.toString(), item.foto?1:2) || 'N/A'}</td>
                    <td style="padding: 10px; color: var(--ink);">${item.descripcion || 'N/A'}</td>
                    <td style="padding: 10px; color: var(--ink);">${formattedTime || 'N/A'}</td>
                </tr>
            `;
        });
    
        html += `
                    </tbody>
                </table>
            </div>
        `;
    
        container.innerHTML = html;
    
        // Event listener para el filtro
        const filterInput = document.getElementById('filterMultiSelect');
        if (filterInput) {
            filterInput.addEventListener('input', function() {
                const filterText = this.value.toLowerCase();
                const rows = container.querySelectorAll('#multiSelectTable tbody tr');
    
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    let found = false;
    
                    cells.forEach(cell => {
                        if (cell.textContent.toLowerCase().includes(filterText)) {
                            found = true;
                        }
                    });
    
                    row.style.display = found ? '' : 'none';
                });
            });
        }
    
        // Event listeners para los checkboxes - MODIFICADO: Usar tempSelectedItems
        container.querySelectorAll('.person-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const id = this.getAttribute('data-id');
                const isChecked = this.checked;
    
                if (isChecked) {
                    // Agregar a la selecci√≥n temporal
                    const item = data.find(d => d.id == id);
                    if (item && !tempSelectedItems.some(selected => selected.id == id)) {
                        tempSelectedItems.push(item);
                    }
                } else {
                    // Remover de la selecci√≥n temporal
                    tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
                }
    
                // Actualizar la lista de selecciones actuales INMEDIATAMENTE (solo en el modal)
                updateTempSelectionsDisplay();
    
                // NO actualizar el localStorage ni las listas principales aqu√≠
            });
        });
    
        // Event listener para hacer clic en toda la fila
        container.querySelectorAll('.multi-select-item').forEach(row => {
            row.addEventListener('click', function(e) {
                if (e.target.type === 'checkbox') return;
    
                const checkbox = this.querySelector('.person-checkbox');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    const event = new Event('change');
                    checkbox.dispatchEvent(event);
                }
            });
    
            // Efecto hover
            row.addEventListener('mouseenter', function() {
                this.style.backgroundColor = 'rgba(34, 230, 217, 0.1)';
            });
    
            row.addEventListener('mouseleave', function() {
                this.style.backgroundColor = '';
            });
        });
    
        // Event listeners para los botones de eliminar en la secci√≥n de selecciones actuales (temporal)
        container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();
                const id = this.getAttribute('data-id');
                removeFromTempSelection(id);
                // Volver a renderizar la lista completa
                renderMultiSelectList(data, container);
            });
        });
    }

    function searchByPlaca(placa,isModal) {
        // Establecer el tipo de b√∫squeda activa

        const resultsContainer = document.getElementById('placa-results');

        if(!isModal){
            resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"></div><div>Buscando veh√≠culos con placa: ' + placa + '</div></div>';
        }else{
            resultsContainer.innerHTML = '';
        }
        // Ocultar el panel de selecci√≥n
        domCache.selectedPersonBox.style.display = 'none';

        // Mostrar bot√≥n de volver
        domCache.btnBackToAll.style.display = 'block';

        busqueda = interesDataVehicle.find(data => data.name == placa)||{name: placa};

        callAPI({
            method: "gestion/dolistseguimiento",
            params: {placa: placa},
            ok: (data) => {
                filteredAlerts = data ? [...data] : [];
                
                // NUEVO: Renderizar marcadores primero, luego procesar ruta
                renderMapAndMarkers(filteredAlerts).then(() => {
                    // Luego procesar la ruta
                    if (filteredAlerts && filteredAlerts.length > 0) {
                        processRouteForInteres(filteredAlerts, 'vehicle');
                    }
                });
                
                renderTimelineList(filteredAlerts);
                updateAllMetrics();
    /*
                        // **ACTUALIZAR filteredCamerasByInteres CON LAS C√ÅMARAS FILTRADAS**
                        if (alertasInteres && alertasInteres.length > 0) {
                            const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];
                            filteredCamerasByInteres = camerasData.filter(cam =>
                                cameraNames.includes(cam.camera_id)
                            );

                            // Resaltar c√°maras con alertas del inter√©s
                            cameraNames.forEach(cameraName => {
                                highlightCameraForAlert(cameraName);
                            });
                        } else {
                            // Si no hay alertas, mantener como array vac√≠o
                            filteredCamerasByInteres = [];
                        }
    */
                        // **CORRECCI√ìN: Renderizar con las alertas filtradas**
                        renderTimelineList(filteredAlerts);

                        // **CORRECCI√ìN: Actualizar KPIs con las alertas filtradas**
                        updateAllMetrics();

                // Actualizar el contenedor de resultados con un mensaje
                if(!isModal){
                    resultsContainer.innerHTML = `
                        <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                            <h5 style="color: var(--teal); margin-top: 0;">B√∫squeda completada</h5>
                            <div style="font-size: 14px;">
                                Se encontraron ${filteredAlerts ? filteredAlerts.length : 0} resultados para la placa: ${placa}
                            </div>
                            <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                                Los resultados se muestran en la lista de alertas a la derecha.
                            </div>
                        </div>
                    `;
                }
            },
            error: (error) => {
                //showGlobalLoader(false);
                log("Error en b√∫squeda por placa:", error);
                resultsContainer.innerHTML = `
                    <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                        <h5 style="color: var(--orange); margin-top: 0;">Error en la b√∫squeda</h5>
                        <div style="font-size: 14px;">
                            No se pudieron obtener resultados para la placa: ${placa}
                        </div>
                    </div>
                `;
            }
        });
    }

    // Event listener para b√∫squeda por placa
    document.getElementById('search-placa-btn').addEventListener('click', function() {
        const placa = document.getElementById('placa-input').value.trim();
        if (!placa) {
            alert('Por favor ingrese un n√∫mero de placa');
            return;
        }
        searchByPlaca(placa);
    });

    // Event listener para b√∫squeda por caracter√≠sticas
    document.getElementById('search-caracteristicas-btn').addEventListener('click', function() {
        searchByCaracteristicas();
    });

    function searchByCaracteristicas(paramsBusqueda) {
        /*
        let routesCheckbox = document.getElementById('label-routes');
        routesCheckbox.style.display = 'none';
        */
        // Establecer el tipo de b√∫squeda activa
        currentSearchType = 'caracteristicas';
        const resultsContainer = domCache.caracteristicasResults;

        resultsContainer.innerHTML = '';

        // Obtener valores del formulario
        busqueda = paramsBusqueda||getvalues();
        // Validar que al menos un campo est√© completado
        if (busqueda.colorsuperior === 'all') {
            resultsContainer.innerHTML = `<div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--red); margin-top: 15px;">
                        <h5 style="color: var(--red); margin-top: 0;">Error</h5>
                        <div style="font-size: 14px;color: var(--red);">
                            La prenda superior es obligatoria
                        </div>
                    </div>`;
            toastr["error"]("Escoja un color de prenda superior.","Error");
            return;
        }else if (!busqueda.fechaini && !busqueda.fechafin){
            resultsContainer.innerHTML = `<div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--red); margin-top: 15px;">
                        <h5 style="color: var(--red); margin-top: 0;">Error</h5>
                        <div style="font-size: 14px; color: var(--red);">
                            Debes ingresar un rango de fecha.
                        </div>
                    </div>`;
            toastr["error"]("Escoja un rango de fecha.","Error");
            return;
        }

        resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"></div><div>Buscando personas con caracter√≠sticas...</div></div>';

        // Mostrar loader global
        //showGlobalLoader(true);

        // Ocultar el panel de selecci√≥n
        domCache.selectedPersonBox.style.display = 'none';

        // Mostrar bot√≥n de volver
        domCache.btnBackToAll.style.display = 'block';

        callAPI({
            method: "gestion/getlistpersoncaract",
            params: busqueda,
            ok: (data)=>{
                document.getElementById('data-spinner').style.display = 'none';
                //showGlobalLoader(false);

                // FILTRO: Conservar solo las detecciones cuya c√°mara contenga "UTEC"
                if (data && Array.isArray(data)) {
                    data = data.filter(item => item.id_area && item.id_area == areaSeleccionada);
                }

                // **MODIFICACI√ìN: Guardar los resultados de la b√∫squeda y actualizar timeline**
                currentSearchResults = data;

                // Mostrar resultados en la timeline
                showresultsearch(data);

                // Actualizar el contenedor de resultados con un mensaje
                resultsContainer.innerHTML = `
                    <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                        <h5 style="color: var(--teal); margin-top: 0;">B√∫squeda completada</h5>
                        <div style="font-size: 14px;">
                            Se encontraron ${data ? data.length : 0} resultados para la b√∫squeda por caracter√≠sticas.
                        </div>
                        <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                            Los resultados se muestran en la lista de alertas a la derecha.
                        </div>
                    </div>
                `;
            },
            error: (error) => {
                //showGlobalLoader(false);
                log("Error en b√∫squeda por caracter√≠sticas:", error);
                resultsContainer.innerHTML = `
                    <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                        <h5 style="color: var(--orange); margin-top: 0;">Error en la b√∫squeda</h5>
                        <div style="font-size: 14px;">
                            No se pudieron obtener resultados para la b√∫squeda por caracter√≠sticas.
                        </div>
                    </div>
                `;
            }
        });
    }

    function getvalues() {
        const fechaIni = $('#txtFechaIni').val()
        ? new Date($('#txtFechaIni').val()).getTime()
        : "";

        const fechaFin = $('#txtFechaFin').val()
            ? new Date($('#txtFechaFin').val()).getTime()
            : "";

        let subzonasList = obtenerSubzonas();
        let stringList = JSON.stringify(subzonasList);

        return {
            subzonas: stringList,
            colorsuperior: $('#txtcolorsup').val().trim(),
            colorinferior: $('#txtcolorinf').val().trim(),
            sexo: $('#txtsexo').val().trim(),
            edad: $("#txtedad").val(),
            precision: null,
            fechaini: fechaIni,
            fechafin: fechaFin,
        }
    }

    // Si necesitas convertir el string de subzonas de vuelta a array
    function obtenerSubzonas() {
        let subzonas = [];
        areasData.forEach (area => {
            subzonas.push(area.id_subzona);
        });
        return subzonas;
    }

    let areasData = [];

    function loadAreas() {
        log('üîÑ Cargando √°reas del servidor...');
        
        callAPI({
            method: 'gestion/getbuilding',
            ok: function(areas) {
                if (areas && areas.length > 0) {
                    log(`‚úÖ Se recibieron ${areas.length} √°reas del servidor`);
                    areasData = areas;
                    
                    // Probar con diferentes configuraciones:
                    
                    // OPCI√ìN A: Rojo muy transparente
                    setTimeout(() => {
                        drawAreasOnMap(areas);
                    }, 1000);
                    
                } else {
                    log('‚ùå No se recibieron √°reas del servidor');
                }
            },
            error: function(error) {
                log('‚ùå Error al cargar las √°reas:', error);
            }
        });
    }
    
    function forceDrawAreas(areas, maxAttempts = 10, delay = 1000) {
        let attempts = 0;
        
        function attemptDraw() {
            attempts++;
            log(`üîÑ Intento ${attempts} de dibujar √°reas...`);
            
            if (!map) {
                log('‚ùå Mapa no disponible');
                if (attempts < maxAttempts) {
                    setTimeout(attemptDraw, delay);
                }
                return;
            }
            
            try {
                drawAreasOnMap(areas);
                log('‚úÖ √Åreas dibujadas exitosamente');
            } catch (error) {
                log(`‚ùå Error en intento ${attempts}:`, error);
                if (attempts < maxAttempts) {
                    setTimeout(attemptDraw, delay);
                }
            }
        }
        
        attemptDraw();
    }
    
    function clearExistingPolygons() {
        if (window.drawnPolygons && window.drawnPolygons.length > 0) {
            log(`üóëÔ∏è Limpiando ${window.drawnPolygons.length} elementos (pol√≠gonos y etiquetas)`);
            window.drawnPolygons.forEach(element => {
                try {
                    if (element.parentNode === map) {
                        // Cerrar popovers antes de eliminarlos
                        if (element.open !== undefined) {
                            element.open = false;
                        }
                        map.removeChild(element);
                    }
                } catch (error) {
                    log('Error eliminando elemento:', error);
                }
            });
            window.drawnPolygons = [];
        }
    }

    domCache.btnBackToAll.addEventListener('click', function() {
        returnToAllAlerts();
    });

    // ==========================
    // Funci√≥n para obtener timestamp de √∫ltima alerta - NUEVA
    // ==========================
    function getLastAlertTimestamp(item, category) {
        if (!alertas || alertas.length === 0) return 0;
    
        let relevantAlerts = [];
    
        if (category === 1) { // Persona
            relevantAlerts = alertas.filter(alert => alert.matched_ident == item.id);
        } else { // Veh√≠culo
            relevantAlerts = alertas.filter(alert => alert.matched_plate == item.name);
        }
    
        if (relevantAlerts.length === 0) return 0;
    
        // Ordenar por fecha descendente y tomar la m√°s reciente
        relevantAlerts.sort((a, b) => new Date(b.init_time_frame) - new Date(a.init_time_frame));
        return new Date(relevantAlerts[0].init_time_frame).getTime();
    }

    function getPersonData(personId){
        switchTab('busqueda');
        const personObject = multiSelectedItems.find(p => p.id === personId);

        let category = 1;
        if(personObject.fecha_robo){
            category = 2;
        }
        selectInteresItem(personObject.id, personObject.tipo, category,false);
    }

    function highlightPersonWithAlert(personId) {
        const idStr = String(personId);
        
        function applyHighlight() {
            const photoElement = document.querySelector(`#civix-neo .selected-person-photo[data-id="${idStr}"]`);
            
            if (photoElement) {
                
                // Remover primero y luego agregar para forzar repintado
                photoElement.classList.remove('active-alert');
                void photoElement.offsetWidth; // Forzar reflow
                photoElement.classList.add('active-alert');
                
                // Aplicar estilos inline como respaldo
                photoElement.style.setProperty('border', '3px solid #FFD700', 'important');
                photoElement.style.setProperty('box-shadow', '0 0 12px #FFD700', 'important');
                photoElement.style.setProperty('padding', '2px', 'important');
                
                // Limpiar timer anterior
                if (activeAlertTimers[personId]) {
                    clearTimeout(activeAlertTimers[personId]);
                }
    
                // Timer para remover
                activeAlertTimers[personId] = setTimeout(() => {
                    photoElement.classList.remove('active-alert');
                    // Remover estilos inline
                    photoElement.style.removeProperty('border');
                    photoElement.style.removeProperty('box-shadow');
                    photoElement.style.removeProperty('padding');
                    delete activeAlertTimers[personId];
                }, 15000);
                
                return true;
            }
            return false;
        }
        
        // Intentar aplicar inmediatamente
        if (!applyHighlight()) {
            
            // Si no se encuentra, esperar a que est√© disponible
            const observer = new MutationObserver(() => {
                if (applyHighlight()) {
                    observer.disconnect();
                }
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Timeout por si nunca aparece
            setTimeout(() => {
                observer.disconnect();
                log('‚ùå Timeout: Elemento no encontrado despu√©s de 5 segundos');
            }, 5000);
        }
    }
    
    function isInSearchMode() {
        return currentSearchType === 'interes' || selectedInteresItem !== null || currentSearchResults !== null;
    }
    
    function filterByCamera(cameraId, cameraName) {
        // Si estamos en modo b√∫squeda, no aplicar filtro
        if (isInSearchMode()) {
            log('üîç Modo b√∫squeda activo - omitiendo filtro de c√°mara');
            return;
        }
        
        // Si ya est√° seleccionada esta c√°mara, hacer reset
        if (currentlySelectedCamera === cameraId) {
            log('üîÑ Ya est√° seleccionada, haciendo reset...');
            resetCameraFilter();
            return;
        }
    
        //log(`üîç Filtrando alertas por c√°mara: ${cameraId}`);
        
        // Quitar selecci√≥n anterior restaurando todos los marcadores
        alertMarkers.forEach(({ marker, isCamera }) => {
            if (isCamera && marker) {
                try {
                    marker.setAttribute('color', '#22e6d9'); // Color normal
                } catch (error) {
                    log('Error restaurando marcador:', error);
                }
            }
        });
    
        // Establecer nueva c√°mara seleccionada
        currentlySelectedCamera = cameraId;
        
        // Encontrar y resaltar el marcador seleccionado
        const markerData = alertMarkers.find(marker => 
            marker.cameraId === cameraId && marker.isCamera
        );
        
        if (markerData && markerData.marker) {
            try {
                markerData.marker.setAttribute('color', '#ffaa00'); // Color de selecci√≥n
                currentlySelectedMarker = markerData.marker;
            } catch (error) {
                log('Error resaltando marcador:', error);
            }
        } else {
            console.warn('‚ö†Ô∏è No se encontr√≥ el marcador para resaltar');
        }
    
        // Filtrar las alertas por la c√°mara seleccionada
        const filtered = alertas.filter(alert => {
            const matches = alert.camera_id === cameraId;
            return matches;
        });
        
        filteredAlerts = filtered;
        
        // Renderizar la lista de alertas filtradas
        renderTimelineList(filteredAlerts);
        renderMapAndMarkers(filteredAlerts).then(() => {
            //buildLegend(uniqueAlertTypes);
            //updateAllMetrics();
        }).catch(error => {
            log('Error renderizando marcadores:', error);
            //buildLegend(uniqueAlertTypes);
            //updateAllMetrics();
        });
        
        // Mostrar el bot√≥n para limpiar filtros
        showClearFiltersButton();
        
        // Actualizar el t√≠tulo del panel para reflejar el filtro
        domCache.titlePanel.textContent = `Alertas - C√°mara: ${cameraName}`;
        
        //log(`‚úÖ Filtrado completado para c√°mara: ${cameraName}`);
    }
    
    // Funci√≥n para resetear filtro de c√°mara
    function resetCameraFilter() {
    
        // Detener todas las actualizaciones de c√°mara
        if (currentlySelectedCamera) {
            stopCameraUpdates(currentlySelectedCamera);
        }
        
        // Limpiar todos los intervalos (por si acaso)
        cameraUpdateIntervals.forEach((interval, cameraId) => {
            clearInterval(interval);
        });
        cameraUpdateIntervals.clear();
        
        // Cerrar el popover si est√° abierto
        if (currentlyOpenPopover) {
            try {
                currentlyOpenPopover.popover.open = false;
            } catch (error) {
                log('Error cerrando popover:', error);
            }
            currentlyOpenPopover = null;
        }
        
        // Restaurar color de todos los marcadores
        alertMarkers.forEach(({ marker, isCamera, cameraId }) => {
            if (isCamera && marker) {
                try {
                    marker.setAttribute('color', '#22e6d9'); // Color normal
                } catch (error) {
                    log('Error restaurando color del marcador:', error);
                }
            }
        });
        
        currentlySelectedMarker = null;
        currentlySelectedCamera = null;
        filteredAlerts = [...alertas];
        
        // Renderizar todas las alertas
        renderTimelineList(filteredAlerts);
        renderMapAndMarkers(filteredAlerts).then(() => {
            //buildLegend(uniqueAlertTypes);
            //updateAllMetrics();
        }).catch(error => {
            log('Error renderizando marcadores:', error);
            //buildLegend(uniqueAlertTypes);
            //updateAllMetrics();
        });
        
        // Restaurar t√≠tulo original
        domCache.titlePanel.textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
        
        // Ocultar bot√≥n de limpiar filtros
        hideClearFiltersButton();
    }
    
    // Funci√≥n para ajustar la vista del mapa a la ruta
    function adjustMapViewForRoute(coordinates) {
        if (!map || coordinates.length === 0) return;
        
        // Calcular bounds
        let minLat = coordinates[0].lat;
        let maxLat = coordinates[0].lat;
        let minLng = coordinates[0].lng;
        let maxLng = coordinates[0].lng;
        
        coordinates.forEach(coord => {
            minLat = Math.min(minLat, coord.lat);
            maxLat = Math.max(maxLat, coord.lat);
            minLng = Math.min(minLng, coord.lng);
            maxLng = Math.max(maxLng, coord.lng);
        });
        
        // Calcular centro y rango
        const centerLat = (minLat + maxLat) / 2;
        const centerLng = (minLng + maxLng) / 2;
        
        // Calcular distancia aproximada para el zoom
        const latRange = maxLat - minLat;
        const lngRange = maxLng - minLng;
        const maxRange = Math.max(latRange, lngRange);
        
        let range = 1000; // default
        if (maxRange > 0.01) range = 2000;
        if (maxRange > 0.05) range = 5000;
        if (maxRange < 0.001) range = 300;
        
        // Aplicar al mapa
        map.setAttribute('center', `${centerLat},${centerLng}`);
        map.setAttribute('range', range.toString());
    }
    
    // Funci√≥n para mostrar informaci√≥n de la ruta
    // MODIFICAR: Mejorar showRouteInfo para mostrar m√°s informaci√≥n
    function showRouteInfo(directionsResult, coordinates, type) {
        const distance = calculateRouteDistance(coordinates);
        const duration = calculateRouteDuration(coordinates[0].timestamp, coordinates[coordinates.length - 1].timestamp);
        
        const routeInfo = `
            <div style="background: #1a2b3c; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid ${type === 'person' ? '#22e6d9' : '#FF6B6B'};">
                <h4 style="color: ${type === 'person' ? '#22e6d9' : '#FF6B6B'}; margin: 0 0 10px 0;">
                    ${type === 'person' ? 'üë§ Ruta de Persona' : 'üöó Ruta de Veh√≠culo'}
                </h4>
                <div style="font-size: 12px; color: #e8f4f8;">
                    <div><strong>Puntos de detecci√≥n:</strong> ${coordinates.length}</div>
                    <div><strong>Duraci√≥n total:</strong> ${duration}</div>
                    <div><strong>Distancia aproximada:</strong> ${distance}</div>
                    <div><strong>Primera detecci√≥n:</strong> ${coordinates[0].time}</div>
                    <div><strong>√öltima detecci√≥n:</strong> ${coordinates[coordinates.length - 1].time}</div>
                    <div style="margin-top: 8px; font-size: 11px; color: #ccc;">
                        Los n√∫meros en los marcadores indican el orden cronol√≥gico
                    </div>
                </div>
                <button onclick="clearCurrentRoute()" style="
                    background: #ff6b6b;
                    color: white;
                    border: none;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 8px;
                ">‚ùå Ocultar Ruta</button>
            </div>
        `;
    
        const searchResults = domCache.searchResults;
        if (searchResults) {
            searchResults.innerHTML = routeInfo;
        }
    }
    
    // Funci√≥n auxiliar para calcular duraci√≥n de la ruta
    function calculateRouteDuration(startTime, endTime) {
        const start = new Date(startTime);
        const end = new Date(endTime);
        const diffMs = end - start;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            return `${diffHours}h ${diffMins % 60}m`;
        } else {
            return `${diffMins}m`;
        }
    }
    
    // Funci√≥n auxiliar para calcular distancia aproximada
    function calculateRouteDistance(coordinates) {
        let totalDistance = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
            const prev = coordinates[i-1];
            const curr = coordinates[i];
            
            // Usar la funci√≥n de geometr√≠a de Google Maps si est√° disponible
            if (google && google.maps && google.maps.geometry) {
                const prevLatLng = new google.maps.LatLng(prev.lat, prev.lng);
                const currLatLng = new google.maps.LatLng(curr.lat, curr.lng);
                totalDistance += google.maps.geometry.spherical.computeDistanceBetween(prevLatLng, currLatLng);
            } else {
                // Fallback a la f√≥rmula Haversine
                totalDistance += calculateDistance(prev.lat, prev.lng, curr.lat, curr.lng) * 1000; // Convertir a metros
            }
        }
        
        if (totalDistance < 1000) {
            return `${Math.round(totalDistance)} metros`;
        } else {
            return `${(totalDistance / 1000).toFixed(2)} km`;
        }
    }
    
    // Funci√≥n para calcular distancia entre dos puntos (f√≥rmula Haversine)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radio de la Tierra en km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a =
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }
    
    // NUEVA: Funci√≥n para verificar si Directions Service est√° disponible
    function isDirectionsServiceAvailable() {
        return !!(window.google && 
                  google.maps && 
                  google.maps.DirectionsService &&
                  typeof google.maps.DirectionsService === 'function');
    }
    
    function obtainLastFrame(cameraId = null, targetElement = null) {
        const cameraToUse = cameraId || currentlySelectedCamera;
    
        if (!cameraToUse) {
            log('‚ùå No hay c√°mara seleccionada');
            return;
        }
    
        // Verificar si el targetElement est√° visible/activo
        if (targetElement && !isContainerInOpenPopover(targetElement)) {
            log('üîÑ Popover cerrado, omitiendo obtainLastFrame');
            return;
        }
    
        callAPI({
            method: 'dashboards/lastframe',
            params: { camera_id: cameraToUse },
            ok: function (vals) {
                if (!vals || !vals.foto) {
                    log('‚ùå No se recibi√≥ URL de imagen v√°lida');
                    if (targetElement && isContainerInOpenPopover(targetElement)) {
                        const placeholder = targetElement.querySelector('.camera-placeholder');
                        if (placeholder) {
                            placeholder.innerHTML = '<div style="color: #ff6b6b; text-align: center; padding: 20px;">Error: No hay imagen disponible</div>';
                            placeholder.style.display = 'flex';
                        }
                    }
                    return;
                }
    
                // Si se proporcion√≥ un elemento target, actualizar la imagen solo si est√° activo
                if (targetElement && isContainerInOpenPopover(targetElement)) {
                    updateCameraImage(targetElement, vals.foto);
                }
    
                return vals.foto;
            },
            error: function (error) {
                log("‚ùå Error al obtener datos de la c√°mara: ", error);
                // Si hay un elemento target, mostrar error solo si est√° activo
                if (targetElement && isContainerInOpenPopover(targetElement)) {
                    const placeholder = targetElement.querySelector('.camera-placeholder');
                    if (placeholder) {
                        placeholder.innerHTML = `
                            <div style="color: #ff6b6b; text-align: center; padding: 20px;">
                                <div>‚ùå Error cargando imagen</div>
                                <div style="font-size: 11px; margin-top: 5px;">${error.message || 'Error de conexi√≥n'}</div>
                            </div>
                        `;
                        placeholder.style.display = 'flex';
                    }
                }
            }
        });
    }
    
    // A√ëADIR: Funci√≥n para actualizar la imagen en el DOM
    function updateCameraImage(container, imageUrl) {
        if (!container || !imageUrl) {
            log('‚ùå updateCameraImage: container o imageUrl faltante');
            return;
        }
    
        // Verificar si este contenedor est√° actualmente en un popover ABIERTO
        const isInOpenPopover = isContainerInOpenPopover(container);
        
        // Si el popover no est√° abierto, no actualizar la imagen
        if (!isInOpenPopover) {
            log('üîÑ Popover cerrado, omitiendo actualizaci√≥n de imagen');
            return;
        }
    
        // Crear o actualizar la imagen
        let imgElement = container.querySelector('.camera-live-image');
    
        if (!imgElement) {
            imgElement = document.createElement('img');
            imgElement.className = 'camera-live-image';
            imgElement.style.width = '100%';
            
            imgElement.style.objectFit = 'cover';
            imgElement.style.borderRadius = '4px';
            imgElement.style.display = 'block';
    
            // A√±adir estilos de carga
            imgElement.style.opacity = '0';
            imgElement.style.transition = 'opacity 0.3s ease';
    
            container.appendChild(imgElement);
        }
    
        // Ocultar placeholder temporalmente
        const placeholder = container.querySelector('.camera-placeholder');
        if (placeholder) {
            placeholder.style.display = 'none';
        }
    
        // Mostrar la imagen
        imgElement.style.display = 'block';
    
        // Configurar eventos de carga/error
        imgElement.onload = function() {
            imgElement.style.opacity = '1';
            
            // Verificar nuevamente si el popover sigue abierto
            if (!isContainerInOpenPopover(container)) {
                log('üîÑ Popover cerrado durante carga, ocultando imagen');
                imgElement.style.display = 'none';
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            }
        };
    
        imgElement.onerror = function() {
            log('‚ùå Error cargando imagen');
            imgElement.style.display = 'none';
    
            // Mostrar placeholder de error solo si el popover est√° abierto
            if (placeholder && isContainerInOpenPopover(container)) {
                placeholder.innerHTML = `
                    <div style="color: #ff6b6b;">
                        <div>‚ùå Error cargando imagen</div>
                        <div style="font-size: 11px; margin-top: 5px;">Intente nuevamente</div>
                    </div>
                `;
                placeholder.style.display = 'flex';
            }
        };
    
        // Forzar recarga evitando cache - CORREGIDO
        const separator = imageUrl.includes('?') ? '&' : '?';
        const urlWithTimestamp = `${imageUrl}${separator}t=${Date.now()}`;
    
        // Aplicar la URL
        imgElement.src = urlWithTimestamp;
        imgElement.alt = `Vista en tiempo real - ${new Date().toLocaleTimeString()}`;
    }
    
    function isContainerInOpenPopover(container) {
        if (!container) return false;
        
        // Buscar el popover padre
        const popover = container.closest('gmp-popover');
        if (!popover) return false;
        
        // Verificar si el popover est√° abierto
        return popover.open === true;
    }
    
    // MODIFICAR: processRouteForInteres para limpiar marcadores existentes
    async function processRouteForInteres(alerts, type) {
        log('üîÑ Procesando ruta con √∫ltima detecci√≥n por c√°mara...');
    
        // Limpiar ruta anterior Y marcadores de alertas existentes
        clearCurrentRoute();
        clearAlertMarkers();
    
        // INICIALIZAR currentRoute PRIMERO
        currentRoute = {
            type: type,
            coordinates: [],
            routeMarkers: [],
            popovers: []
        };
    
        currentRouteType = type;
    
        // Agrupar alertas por c√°mara y tomar solo la √∫ltima detecci√≥n de cada c√°mara
        const alertsByCamera = {};
        
        alerts.forEach(alert => {
            const cameraId = alert.camera_id;
            if (!alertsByCamera[cameraId]) {
                alertsByCamera[cameraId] = [];
            }
            alertsByCamera[cameraId].push(alert);
        });
    
        // Para cada c√°mara, tomar solo la alerta m√°s reciente
        const latestAlerts = [];
        Object.keys(alertsByCamera).forEach(cameraId => {
            const cameraAlerts = alertsByCamera[cameraId];
            // Ordenar por fecha descendente y tomar la m√°s reciente
            cameraAlerts.sort((a, b) => {
                const timeA = new Date(a.init_time_frame || a.epoch_frame);
                const timeB = new Date(b.init_time_frame || b.epoch_frame);
                return timeB - timeA;
            });
            latestAlerts.push(cameraAlerts[0]);
        });
    
        // Ordenar las alertas m√°s recientes por tiempo (m√°s antiguo primero para la ruta)
        latestAlerts.sort((a, b) => {
            const timeA = new Date(a.init_time_frame || a.epoch_frame);
            const timeB = new Date(b.init_time_frame || b.epoch_frame);
            return timeA - timeB;
        });
    
        log(`üìç Encontradas ${latestAlerts.length} c√°maras con detecciones`);
    
        // Extraer coordenadas v√°lidas
        const routeCoordinates = [];
    
        latestAlerts.forEach((alert, index) => {
            if (alert.latitud && alert.longitud) {
                const lat = parseFloat(alert.latitud);
                const lng = parseFloat(alert.longitud);
    
                if (!isNaN(lat) && !isNaN(lng)) {
                    // Formatear hora exacta para mostrar
                    const detectionTime = new Date(alert.init_time_frame || alert.epoch_frame);
                    const timeString = detectionTime.toLocaleTimeString('es-PE', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    const dateString = detectionTime.toLocaleDateString('es-PE');
                    routeCoordinates.push({
                        lat: lat,
                        lng: lng,
                        altitude: 0,
                        alert: alert,
                        timestamp: alert.init_time_frame || alert.epoch_frame,
                        camera_name: alert.cameraname || alert.camera_name,
                        camera_id: alert.camera_id,
                        order: index + 1,
                        time: timeString,
                        date: dateString,
                        count: 1,
                        location: alert.location,
                        isLatest: true // Marcar como √∫ltima detecci√≥n
                    });
                }
            }
        });
    
        log('üìç Coordenadas para ruta (√∫ltima detecci√≥n por c√°mara):', routeCoordinates.length);
    
        if (routeCoordinates.length > 1) {
            // SUSPENDER el renderizado autom√°tico de marcadores
            suspendAutoMarkers = true;
    
            // Actualizar coordinates en currentRoute
            currentRoute.coordinates = routeCoordinates;
    
            // Para PERSONAS: crear ruta directa (caminando)
            // Para VEH√çCULOS: intentar usar Directions Service si est√° disponible
            if (type === 'person') {
                createWalkingRoute(routeCoordinates);
            } else {
                await createDrivingRoute(routeCoordinates);
            }
    
            // Crear marcadores con informaci√≥n cronol√≥gica
            createChronologicalMarkers(routeCoordinates, type);
            
            showRouteInfoPanel(routeCoordinates, type);
    
            log(`‚úÖ Ruta creada con ${routeCoordinates.length} puntos (√∫ltima detecci√≥n por c√°mara)`);
            
            // Centrar el mapa en la ruta
            adjustMapViewForRoute(routeCoordinates);
            
        } else if (routeCoordinates.length === 1) {
            suspendAutoMarkers = true;
            currentRoute.coordinates = routeCoordinates;
            createSinglePointMarker(routeCoordinates[0], type);
            
            // Centrar en este punto
            map.setAttribute('center', `${routeCoordinates[0].lat},${routeCoordinates[0].lng}`);
            map.setAttribute('range', '500');
        } else {
            log('‚ùå No hay coordenadas v√°lidas para la ruta');
            suspendAutoMarkers = false;
        }
    }
    
    // A√ëADIR: Funci√≥n para ruta de persona (caminando - l√≠nea directa)
    async function createWalkingRoute(coordinates) {
        log('üö∂ Creando ruta para persona (caminando por calles)...');
        
        // Intentar usar Directions Service para rutas peatonales
        if (window.google && google.maps && google.maps.DirectionsService) {
            await createWalkingRouteWithDirections(coordinates);
        } else {
            // Fallback a ruta optimizada para peatones
            createOptimizedWalkingRoute(coordinates);
        }
    }
    
    async function createWalkingRouteWithDirections(coordinates) {
        log('üó∫Ô∏è Calculando ruta peatonal por calles...');
        
        try {
            const directionsService = new google.maps.DirectionsService();
            
            // Configurar waypoints (puntos intermedios)
            const waypoints = coordinates.slice(1, -1).map(coord => ({
                location: new google.maps.LatLng(coord.lat, coord.lng),
                stopover: true
            }));
    
            const origin = new google.maps.LatLng(coordinates[0].lat, coordinates[0].lng);
            const destination = new google.maps.LatLng(
                coordinates[coordinates.length - 1].lat, 
                coordinates[coordinates.length - 1].lng
            );
    
            const request = {
                origin: origin,
                destination: destination,
                waypoints: waypoints,
                travelMode: google.maps.TravelMode.WALKING, // MODO CAMINANDO
                optimizeWaypoints: false, // Mantener orden cronol√≥gico
                provideRouteAlternatives: false
            };
    
            const result = await new Promise((resolve, reject) => {
                directionsService.route(request, (result, status) => {
                    if (status === google.maps.DirectionsStatus.OK) {
                        resolve(result);
                    } else {
                        reject(new Error(`Directions error: ${status}`));
                    }
                });
            });
    
            log('‚úÖ Ruta peatonal calculada por Directions API');
            renderWalkingPolyline(result, coordinates);
            
        } catch (error) {
            log('‚ùå Error en Directions API para ruta peatonal:', error);
            // Fallback a ruta optimizada para peatones
            createOptimizedWalkingRoute(coordinates);
        }
    }
    
    // A√ëADIR: Renderizar polyline para ruta peatonal
    function renderWalkingPolyline(directionsResult, coordinates) {
        log('üé® Renderizando polyline peatonal con Directions API y degradado...');
        
        const route = directionsResult.routes[0];
        const overviewPath = route.overview_path;
        
        // Convertir el path a coordenadas simples
        const pathCoordinates = overviewPath.map(point => ({
            lat: point.lat(),
            lng: point.lng(),
            altitude: 10
        }));
        
        // Usar la misma funci√≥n de degradado
        createGradientPolyline(pathCoordinates, 'person');
        calculateWalkingStatisticsFromDirections(route, coordinates);
    }
    
    function renderDrivingPolyline(directionsResult, coordinates) {
        log('üé® Renderizando polyline de conducci√≥n con Directions API y degradado...');
        
        const route = directionsResult.routes[0];
        const overviewPath = route.overview_path;
        
        // Convertir el path a coordenadas simples
        const pathCoordinates = overviewPath.map(point => ({
            lat: point.lat(),
            lng: point.lng(),
            altitude: 10
        }));
        
        // Usar la misma funci√≥n de degradado
        createGradientPolyline(pathCoordinates, 'vehicle');
        calculateDrivingStatisticsFromDirections(route, coordinates);
    }
    
    function calculateWalkingStatisticsFromDirections(route, coordinates) {
        let totalDistance = 0;
        let totalDuration = 0;
        
        if (route.legs) {
            route.legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });
        }
        
        const distanceKm = (totalDistance / 1000).toFixed(2);
        const durationMin = Math.round(totalDuration / 60);
        
        currentRoute.statistics = {
            distance: `${distanceKm} km`,
            duration: `${durationMin} minutos`,
            points: coordinates.length,
            type: 'person',
            mode: 'Caminando (Google Maps)'
        };
        
        updateRouteInfoPanel();
    }
    
    // A√ëADIR: Ruta optimizada para peatones (fallback sin Directions API)
    function createOptimizedWalkingRoute(coordinates) {
        log('üö∂ Creando ruta peatonal optimizada con degradado...');
        createGradientPolyline(coordinates, 'person');
        calculateWalkingStatistics(coordinates);
    }
    
    // A√ëADIR: Algoritmo de optimizaci√≥n para rutas peatonales
    function optimizeRouteForWalking(coordinates) {
        log('üìê Optimizando ruta para caminata...');
        
        if (coordinates.length <= 2) {
            return coordinates;
        }
        
        const optimized = [coordinates[0]];
        
        // Para peatones, usar un enfoque m√°s conservador que siga calles principales
        for (let i = 0; i < coordinates.length - 1; i++) {
            const start = coordinates[i];
            const end = coordinates[i + 1];
            
            const distance = calculateDistance(start.lat, start.lng, end.lat, end.lng);
            
            // Para distancias cortas (< 300m), mantener l√≠nea directa (posible misma calle)
            if (distance <= 0.003) {
                optimized.push(end);
            } else {
                // Para distancias m√°s largas, simular que sigue calles
                // A√±adir puntos intermedios que sigan un patr√≥n de cuadr√≠cula
                const intermediatePoints = createGridPath(start, end, Math.floor(distance / 0.001));
                optimized.push(...intermediatePoints);
                optimized.push(end);
            }
        }
        
        log(`üîÑ Ruta peatonal optimizada: ${coordinates.length} ‚Üí ${optimized.length} puntos`);
        return optimized;
    }
    
    // A√ëADIR: Crear ruta en cuadr√≠cula para simular calles
    function createGridPath(start, end, segments) {
        const path = [];
        
        // Calcular direcci√≥n general
        const latDiff = end.lat - start.lat;
        const lngDiff = end.lng - start.lng;
        
        // Para simular calles, primero moverse en una direcci√≥n, luego en la otra
        const midPoint = {
            lat: start.lat + latDiff * 0.5,
            lng: start.lng + lngDiff * 0.5
        };
        
        // Primero moverse en latitud, luego en longitud (o viceversa)
        // Esto simula el patr√≥n de cuadr√≠cula de calles
        const steps = Math.max(2, Math.floor(segments / 2));
        
        // Primera mitad: movimiento principal en una direcci√≥n
        for (let i = 1; i <= steps; i++) {
            const ratio = i / steps;
            const point = {
                lat: start.lat + (midPoint.lat - start.lat) * ratio,
                lng: start.lng + (midPoint.lng - start.lng) * ratio * 0.3, // Menor movimiento en lng
                altitude: 0
            };
            path.push(point);
        }
        
        // Segunda mitad: movimiento en la otra direcci√≥n
        for (let i = 1; i <= steps; i++) {
            const ratio = i / steps;
            const point = {
                lat: midPoint.lat + (end.lat - midPoint.lat) * ratio * 0.3, // Menor movimiento en lat
                lng: midPoint.lng + (end.lng - midPoint.lng) * ratio,
                altitude: 0
            };
            path.push(point);
        }
        
        return path;
    }
    
    // A√ëADIR: Funci√≥n para ruta de veh√≠culo (usando Roads API o l√≥gica simple)
    async function createDrivingRoute(coordinates) {
        log('üöó Creando ruta para veh√≠culo...');
        
        // Si tenemos acceso a Roads API, la usamos, sino creamos ruta optimizada
        if (window.google && google.maps && google.maps.DirectionsService) {
            await createDrivingRouteWithDirections(coordinates);
        } else {
            createOptimizedDrivingRoute(coordinates);
        }
    }
    
    // A√ëADIR: Ruta optimizada para veh√≠culos (sin Directions API)
    function createOptimizedDrivingRoute(coordinates) {
        log('üõ£Ô∏è Creando ruta optimizada para veh√≠culo con degradado...');
        createGradientPolyline(coordinates, 'vehicle');
        calculateDrivingStatistics(coordinates);
    }
    
    function createGradientPolyline(coordinates, type) {
        log('üé® Creando polyline con degradado...');
    
        const baseColor = type === 'person' ? '#22e6d9' : '#FF6B6B';
        
        // Crear segmentos de polyline con opacidad creciente
        for (let i = 0; i < coordinates.length - 1; i++) {
            const start = coordinates[i];
            const end = coordinates[i + 1];
            
            // Calcular opacidad basada en la posici√≥n en la ruta (m√°s reciente = m√°s opaco)
            const opacity = 0.3 + (i / (coordinates.length - 1)) * 0.7;
            
            // Convertir color hexadecimal a rgba con opacidad
            const segmentColor = hexToRgba(baseColor, opacity);
            
            try {
                const polyline3D = document.createElement('gmp-polyline-3d');
                
                // Crear path para este segmento
                const pathString = `${start.lat},${start.lng},0 ${end.lat},${end.lng},0`;
                polyline3D.setAttribute('path', pathString);
                
                // Configurar estilo del segmento
                polyline3D.setAttribute('stroke-color', segmentColor);
                polyline3D.setAttribute('stroke-width', type === 'person' ? '4' : '6');
                polyline3D.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
                
                map.appendChild(polyline3D);
                
                // Guardar referencia para limpiar despu√©s
                if (!currentRoute.polylines) {
                    currentRoute.polylines = [];
                }
                currentRoute.polylines.push(polyline3D);
                
            } catch (error) {
                log(`‚ùå Error creando segmento de polyline ${i}:`, error);
            }
        }
        
        log(`‚úÖ Polyline con degradado creado: ${coordinates.length - 1} segmentos`);
    }
    
    function hexToRgba(hex, opacity) {
        // Eliminar el # si existe
        hex = hex.replace('#', '');
        
        // Convertir hex a rgb
        let r, g, b;
        if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g = parseInt(hex[1] + hex[1], 16);
            b = parseInt(hex[2] + hex[2], 16);
        } else if (hex.length === 6) {
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        } else {
            return `rgba(34, 230, 217, ${opacity})`; // Fallback
        }
        
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    
    // A√ëADIR: Algoritmo para optimizar ruta de conducci√≥n
    function optimizeRouteForDriving(coordinates) {
        log('üìê Optimizando ruta para conducci√≥n...');
        
        if (coordinates.length <= 2) {
            return coordinates; // No hay suficiente puntos para optimizar
        }
        
        const optimized = [coordinates[0]]; // Empezar con el primer punto
        
        // Para cada segmento, a√±adir puntos intermedios para suavizar la ruta
        for (let i = 0; i < coordinates.length - 1; i++) {
            const start = coordinates[i];
            const end = coordinates[i + 1];
            
            // Calcular distancia entre puntos
            const distance = calculateDistance(start.lat, start.lng, end.lat, end.lng);
            
            // Si la distancia es grande, a√±adir puntos intermedios
            if (distance > 0.005) { // Aprox 500 metros
                const intermediatePoints = Math.floor(distance / 0.002); // Puntos cada ~200 metros
                for (let j = 1; j <= intermediatePoints; j++) {
                    const ratio = j / (intermediatePoints + 1);
                    const lat = start.lat + (end.lat - start.lat) * ratio;
                    const lng = start.lng + (end.lng - start.lng) * ratio;
                    optimized.push({ lat, lng, altitude: 0 });
                }
            }
            
            optimized.push(end);
        }
        
        log(`üîÑ Ruta optimizada: ${coordinates.length} ‚Üí ${optimized.length} puntos`);
        return optimized;
    }
    
    // A√ëADIR: Calcular estad√≠sticas de la ruta
    function calculateRouteStatistics(route, coordinates, type) {
        let totalDistance = 0;
        let totalDuration = 0;
        
        if (route.legs) {
            route.legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });
        }
        
        const distanceKm = (totalDistance / 1000).toFixed(2);
        const durationMin = Math.round(totalDuration / 60);
        
        currentRoute.statistics = {
            distance: distanceKm,
            duration: durationMin,
            points: coordinates.length,
            type: type
        };
        
        log(`üìä Estad√≠sticas de ruta: ${distanceKm} km, ${durationMin} min, ${coordinates.length} puntos`);
        
        // Actualizar el panel de informaci√≥n
        updateRouteInfoPanel();
    }
    
    // MODIFICAR: showRouteInfo para mostrar informaci√≥n de Directions
    function updateRouteInfoPanel() {
        if (!currentRoute || !currentRoute.statistics) return;
        
        const stats = currentRoute.statistics;
        const type = stats.type;
        
        const routeInfo = `
            <div style="background: #1a2b3c; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid ${type === 'person' ? '#22e6d9' : '#FF6B6B'};">
                <h4 style="color: ${type === 'person' ? '#22e6d9' : '#FF6B6B'}; margin: 0 0 10px 0;">
                    ${type === 'person' ? 'üë§ Ruta de Persona' : 'üöó Ruta de Veh√≠culo'}
                </h4>
                <div style="font-size: 12px; color: #e8f4f8;">
                    <div><strong>Modo:</strong> ${stats.mode || (type === 'person' ? 'Caminando' : 'Conduciendo')}</div>
                    <div><strong>Distancia:</strong> ${stats.distance}</div>
                    <div><strong>Duraci√≥n estimada:</strong> ${stats.duration}</div>
                    <div><strong>Puntos de detecci√≥n:</strong> ${stats.points}</div>
                    <div><strong>Primera detecci√≥n:</strong> ${currentRoute.coordinates[0].time}</div>
                    <div><strong>√öltima detecci√≥n:</strong> ${currentRoute.coordinates[currentRoute.coordinates.length - 1].time}</div>
                    <div style="margin-top: 8px; font-size: 11px; color: #ccc;">
                        <div>‚Ä¢ Los n√∫meros indican el orden cronol√≥gico</div>
                        <div>‚Ä¢ ${type === 'person' ? 'La ruta sigue calles y aceras' : 'La ruta sigue calles y avenidas'}</div>
                    </div>
                </div>
                <button onclick="clearCurrentRoute()" style="
                    background: #ff6b6b;
                    color: white;
                    border: none;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 8px;
                ">‚ùå Ocultar Ruta</button>
            </div>
        `;
    
        const searchResults = domCache.searchResults;
        if (searchResults) {
            searchResults.innerHTML = routeInfo;
        }
    }
    
    // MODIFICAR: Mejorar clearCurrentRoute para limpiar popovers tambi√©n
    function clearCurrentRoute() {
        log('üóëÔ∏è Limpiando ruta actual...');
    
        // Reanudar renderizado autom√°tico
        suspendAutoMarkers = false;
    
        // Limpiar polyline-3d principal
        if (currentRoute && currentRoute.polyline3D) {
            try {
                const polyline = currentRoute.polyline3D;
                if (polyline.parentNode === map) {
                    map.removeChild(polyline);
                    log('‚úÖ gmp-polyline-3d eliminado');
                }
            } catch (error) {
                log('‚ùå Error eliminando gmp-polyline-3d:', error);
            }
        }
    
        // Limpiar polylines segmentados
        if (currentRoute && currentRoute.polylines) {
            currentRoute.polylines.forEach(polyline => {
                try {
                    if (polyline.parentNode === map) {
                        map.removeChild(polyline);
                    }
                } catch (error) {
                    log('Error eliminando polyline segmentado:', error);
                }
            });
            log(`‚úÖ ${currentRoute.polylines.length} polylines segmentados eliminados`);
        }
    
        // Limpiar marcadores de ruta
        if (currentRoute && currentRoute.routeMarkers) {
            currentRoute.routeMarkers.forEach(markerData => {
                try {
                    // Verificar si es un objeto con propiedad marker o el marker directamente
                    const marker = markerData.marker || markerData;
                    if (marker && marker.parentNode === map) {
                        map.removeChild(marker);
                    }
                } catch (error) {
                    log('Error eliminando marcador de ruta:', error);
                }
            });
            log(`‚úÖ ${currentRoute.routeMarkers.length} marcadores de ruta eliminados`);
        }
    
        // Limpiar popovers de ruta si existen
        if (currentRoute && currentRoute.popovers) {
            currentRoute.popovers.forEach(popover => {
                try {
                    if (popover.parentNode === map) {
                        map.removeChild(popover);
                    }
                } catch (error) {
                    log('Error eliminando popover de ruta:', error);
                }
            });
        }
    
        // Limpiar openPopover de ruta
        if (currentRoute && currentRoute.openPopover) {
            try {
                currentRoute.openPopover.open = false;
            } catch (error) {
                log('Error cerrando popover de ruta:', error);
            }
        }
    
        // Resetear variables
        currentRoute = null;
        routeCoordinates = [];
        routeAnimationProgress = 0;
    
        // Detener animaci√≥n de ruta si existe
        if (routeAnimationInterval) {
            clearInterval(routeAnimationInterval);
            routeAnimationInterval = null;
        }
    
        // Limpiar informaci√≥n de ruta mostrada
        const searchResults = domCache.searchResults;
        if (searchResults) {
            searchResults.innerHTML = '';
        }
        
        cleanupRouteMarkers();
    
    }
    
    // A√ëADIR: Funci√≥n para crear marcadores con orden cronol√≥gico y hora
    function createChronologicalMarkers(coordinates, type) {
        log('üìç Creando marcadores cronol√≥gicos con estilo unificado y n√∫mero...');
    
        if (!currentRoute.routeMarkers) {
            currentRoute.routeMarkers = [];
        }
    
        // A√±adir estilos CSS para los labels
        const style = document.createElement('style');
        style.textContent = `
            gmp-marker-3d::part(label) {
                background: rgba(0, 0, 0, 0.8) !important;
                color: white !important;
                padding: 8px 12px !important;
                border-radius: 6px !important;
                font-size: 12px !important;
                font-weight: 500 !important;
                border: 1px solid rgba(255, 255, 255, 0.3) !important;
                backdrop-filter: blur(4px) !important;
                max-width: 200px !important;
                white-space: pre-line !important;
                text-align: center !important;
            }
        `;
        document.head.appendChild(style);
    
        coordinates.forEach((coord, index) => {
            try {
                const baseColor = type === 'person' ? '#22e6d9' : '#FF6B6B';
                const intensity = 0.3 + (index / coordinates.length) * 0.7;
                const markerColor = applyHeatmapToColor(baseColor, intensity);
    
                const marker = document.createElement('gmp-marker-3d');
                marker.setAttribute('position', `${coord.lat},${coord.lng},2`);
                marker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
                marker.setAttribute('scale', '1.2');
                marker.setAttribute('color', markerColor);
                
                // Texto del label mejor formateado
                const labelText = `${coord.camera_name}\n ${coord.location}\n ${coord.time}`;
                marker.setAttribute('label', labelText);
    
                // Resto del c√≥digo igual...
                if (typeof PinElement !== 'undefined' && PinElement) {
                    try {
                        const pinElement = new PinElement({
                            background: markerColor,
                            borderColor: '#ffffff',
                            glyphColor: '#ffffff',
                            scale: 1.0,
                            glyph: `${coord.order}`
                        });
                        marker.appendChild(pinElement.element);
                    } catch (pinError) {
                        log('‚ùå Error con PinElement, usando fallback:', pinError);
                        createRouteMarkerWithTemplate(marker, markerColor, coord.order, intensity, coord.time);
                    }
                } else {
                    createRouteMarkerWithTemplate(marker, markerColor, coord.order, intensity, coord.time);
                }
    
                marker.setAttribute('data-order', coord.order);
                marker.setAttribute('data-time', coord.time);
                marker.setAttribute('data-route-type', type);
                marker.setAttribute('data-is-route-marker', 'true');
    
                map.appendChild(marker);
    
                currentRoute.routeMarkers.push({
                    marker: marker,
                    coordinates: coord,
                    order: coord.order
                });
    
                log(`‚úÖ Marcador de ruta ${coord.order} creado: ${coord.time}`);
    
            } catch (error) {
                log(`‚ùå Error creando marcador de ruta ${index + 1}:`, error);
            }
        });
    
        log(`üìç ${currentRoute.routeMarkers.length} marcadores de ruta creados`);
    }

    
    function createRouteMarkerWithTemplate(marker, color, order, intensity, time) {
        try {
            const template = document.createElement('template');
    
            // Calcular tama√±o basado en la intensidad
            const baseSize = 28;
            const sizeMultiplier = 0.6 + (intensity * 0.4);
            const markerSize = Math.floor(baseSize * sizeMultiplier);
    
            const opacity = 0.7 + (intensity * 0.3);
    
            template.innerHTML = `
                <div class="custom-marker route-marker" style="
                    width: ${markerSize}px;
                    height: ${markerSize}px;
                    background-color: ${color};
                    border: 2px solid white;
                    border-radius: 50%;
                    box-shadow:
                        0 2px 8px rgba(0,0,0,0.3),
                        0 0 0 ${Math.floor(intensity * 8)}px ${color}33;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: ${Math.floor(markerSize * 0.35)}px;
                    font-family: Arial, sans-serif;
                    cursor: pointer;
                    opacity: ${opacity};
                    transition: all 0.3s ease;
                    text-align: center;
                    line-height: 1.1;
                ">
                    <div>${order}</div>
                    <div style="font-size: ${Math.floor(markerSize * 0.2)}px; font-weight: normal;">${time}</div>
                </div>
            `;
            marker.appendChild(template.content.cloneNode(true));
        } catch (templateError) {
            log('‚ùå Error creando marcador de ruta con template:', templateError);
        }
    }
    
    function createRoutePopoverContent(coord, type) {
        const typeLabel = type === 'person' ? 'Persona' : 'Veh√≠culo';
        
        return `
            <div style="background: #1a2b3c; border-radius: 12px; padding: 15px; color: white; max-width: 280px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border: 2px solid ${type === 'person' ? '#22e6d9' : '#FF6B6B'};">
                <h3 style="margin: 0 0 8px 0; color: ${type === 'person' ? '#22e6d9' : '#FF6B6B'}; text-align: center;">
                    Punto ${coord.order} - ${typeLabel}
                </h3>
                <div style="margin-bottom: 10px; font-size: 13px;">
                    <div><strong>üìç C√°mara:</strong> ${coord.camera_name || 'N/A'}</div>
                    <div><strong>üïê Hora:</strong> ${coord.time}</div>
                    <div><strong>üìÖ Fecha:</strong> ${coord.date}</div>
                    <div><strong>üî¢ Orden:</strong> ${coord.order} de ${currentRoute.coordinates.length}</div>
                    ${coord.isLatest ? '<div style="color: #4CAF50; font-size: 12px; margin-top: 5px;">‚úÖ √öltima detecci√≥n en esta c√°mara</div>' : ''}
                </div>
                <div style="font-size: 11px; color: #ccc; margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                    <div><strong>Coordenadas:</strong></div>
                    <div>${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}</div>
                </div>
                <button onclick="closePopover(this)" style="
                    background: #ff4757;
                    color: white;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 10px;
                    width: 100%;
                ">Cerrar</button>
            </div>
        `;
    }
    
    function handleRouteMarkerClick(coord, popover, interactiveMarker) {
        try {
            // Cerrar popover anterior si existe
            if (currentRoute.openPopover && currentRoute.openPopover !== popover) {
                currentRoute.openPopover.open = false;
            }
            
            // Abrir este popover
            popover.open = true;
            currentRoute.openPopover = popover;
            
        } catch (error) {
            log('‚ùå Error abriendo popover de ruta:', error);
        }
    }
    
    // A√ëADIR: Funci√≥n para cuando solo hay un punto
    function createSinglePointMarker(coord, type) {
        log('üìç Creando marcador para punto √∫nico...');
    
        const baseColor = type === 'person' ? '#22e6d9' : '#FF6B6B';
        const markerColor = applyHeatmapToColor(baseColor, 1.0); // M√°xima intensidad para punto √∫nico
    
        const marker = document.createElement('gmp-marker-3d');
        marker.setAttribute('position', `${coord.lat},${coord.lng},2`);
        marker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
        marker.setAttribute('scale', '1.5');
        marker.setAttribute('color', markerColor);
    
        // Mostrar n√∫mero y hora en el label
        const labelText = `${coord.order}\n${coord.time}`;
        marker.setAttribute('label', labelText);
    
        // Usar el mismo estilo visual
        if (typeof PinElement !== 'undefined' && PinElement) {
            try {
                const pinElement = new PinElement({
                    background: markerColor,
                    borderColor: '#ffffff',
                    glyphColor: '#ffffff',
                    scale: 1.2,
                    glyph: `${coord.order}`
                });
                marker.appendChild(pinElement.element);
            } catch (pinError) {
                createRouteMarkerWithTemplate(marker, markerColor, coord.order, 1.0, coord.time);
            }
        } else {
            createRouteMarkerWithTemplate(marker, markerColor, coord.order, 1.0, coord.time);
        }
    
        marker.setAttribute('data-is-route-marker', 'true');
    
        map.appendChild(marker);
    
        currentRoute = {
            type: type,
            coordinates: [coord],
            routeMarkers: [marker],
            isSinglePoint: true
        };
    
        // Centrar en este punto
        map.setAttribute('center', `${coord.lat},${coord.lng}`);
        map.setAttribute('range', '500');
    
        log('‚úÖ Marcador √∫nico creado');
    }
    
    // A√ëADIR: Renderizar polyline basado en Directions API
    function renderDirectionsPolyline(directionsResult, coordinates, type) {
        log('üé® Renderizando polyline por calles...');
        
        const route = directionsResult.routes[0];
        const overviewPath = route.overview_path;
        
        // Crear polyline 3D con el path de la ruta calculada
        const polyline3D = document.createElement('gmp-polyline-3d');
        
        // Convertir el path a formato string para gmp-polyline-3d
        const pathString = overviewPath.map(point => 
            `${point.lat()},${point.lng()},0`
        ).join(' ');
    
        polyline3D.setAttribute('path', pathString);
        
        // Color y estilo seg√∫n el tipo
        if (type === 'person') {
            polyline3D.strokeColor = '#22e6d9';
            polyline3D.strokeWidth = 4;
        } else {
            polyline3D.strokeColor = '#FF6B6B';
            polyline3D.strokeWidth = 6;
        }
        
        polyline3D.altitudeMode = 'RELATIVE_TO_GROUND';
        
        map.appendChild(polyline3D);
        
        // Guardar referencia
        currentRoute.polyline3D = polyline3D;
        currentRoute.directionsResult = directionsResult;
        
        // Calcular estad√≠sticas de la ruta
        calculateRouteStatistics(route, coordinates, type);
        
        log('‚úÖ Polyline por calles creado');
    }
    
    // A√ëADIR: Implementaci√≥n robusta de Directions Service
    async function createDrivingRouteWithDirections(coordinates) {
        log('üó∫Ô∏è Intentando usar Directions Service...');
        
        try {
            // Verificar que DirectionsService est√© disponible
            if (typeof google === 'undefined' || !google.maps || !google.maps.DirectionsService) {
                throw new Error('Directions Service no disponible');
            }
            
            const directionsService = new google.maps.DirectionsService();
            
            // Configurar waypoints (puntos intermedios)
            const waypoints = coordinates.slice(1, -1).map(coord => ({
                location: new google.maps.LatLng(coord.lat, coord.lng),
                stopover: true
            }));
    
            const origin = new google.maps.LatLng(coordinates[0].lat, coordinates[0].lng);
            const destination = new google.maps.LatLng(
                coordinates[coordinates.length - 1].lat, 
                coordinates[coordinates.length - 1].lng
            );
    
            const request = {
                origin: origin,
                destination: destination,
                waypoints: waypoints,
                travelMode: google.maps.TravelMode.DRIVING,
                optimizeWaypoints: false, // Mantener el orden cronol√≥gico
                provideRouteAlternatives: false
            };
    
            const result = await new Promise((resolve, reject) => {
                directionsService.route(request, (result, status) => {
                    if (status === google.maps.DirectionsStatus.OK) {
                        resolve(result);
                    } else {
                        reject(new Error(`Directions error: ${status}`));
                    }
                });
            });
    
            log('‚úÖ Ruta calculada por Directions Service');
            renderDirectionsPolyline(result, coordinates);
            
        } catch (error) {
            log('‚ùå Error con Directions Service:', error);
            // Fallback a ruta optimizada
            createOptimizedDrivingRoute(coordinates);
        }
    }
    
    // A√ëADIR: Renderizar polyline de direcciones
    function renderDirectionsPolyline(directionsResult, coordinates) {
        log('üé® Renderizando polyline de direcciones...');
        
        const route = directionsResult.routes[0];
        const overviewPath = route.overview_path;
        
        const polyline3D = document.createElement('gmp-polyline-3d');
        
        // Convertir el path a formato string para gmp-polyline-3d
        const pathString = overviewPath.map(point => 
            `${point.lat()},${point.lng()},0`
        ).join(' ');
    
        polyline3D.setAttribute('path', pathString);
        polyline3D.strokeColor = '#FF6B6B';
        polyline3D.strokeWidth = 6;
        polyline3D.altitudeMode = 'RELATIVE_TO_GROUND';
        
        map.appendChild(polyline3D);
        
        currentRoute.polyline3D = polyline3D;
        currentRoute.directionsResult = directionsResult;
        
        calculateDrivingStatisticsFromDirections(route, coordinates);
        
        log('‚úÖ Polyline de direcciones creado');
    }
    
    // A√ëADIR: Funciones de c√°lculo de estad√≠sticas
    function calculateWalkingStatistics(coordinates) {
        const distance = calculateRouteDistance(coordinates);
        const duration = calculateRouteDuration(coordinates[0].timestamp, coordinates[coordinates.length - 1].timestamp);
        
        currentRoute.statistics = {
            distance: distance,
            duration: duration,
            points: coordinates.length,
            type: 'person',
            mode: 'Caminando'
        };
        
        updateRouteInfoPanel();
    }
    
    function calculateDrivingStatistics(coordinates) {
        const distance = calculateRouteDistance(coordinates);
        const duration = calculateRouteDuration(coordinates[0].timestamp, coordinates[coordinates.length - 1].timestamp);
        
        currentRoute.statistics = {
            distance: distance,
            duration: duration,
            points: coordinates.length,
            type: 'vehicle',
            mode: 'Conduciendo'
        };
        
        updateRouteInfoPanel();
    }
    
    function calculateDrivingStatisticsFromDirections(route, coordinates) {
        let totalDistance = 0;
        let totalDuration = 0;
        
        if (route.legs) {
            route.legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });
        }
        
        const distanceKm = (totalDistance / 1000).toFixed(2);
        const durationMin = Math.round(totalDuration / 60);
        
        currentRoute.statistics = {
            distance: `${distanceKm} km`,
            duration: `${durationMin} minutos`,
            points: coordinates.length,
            type: 'vehicle',
            mode: 'Conduciendo (Google Maps)'
        };
        
        updateRouteInfoPanel();
    }
    
    // A√ëADIR: Funciones para manejar actualizaciones de c√°mara en tiempo real
    function startCameraUpdates(cameraId) {
        // Si ya hay un intervalo para esta c√°mara, limpiarlo
        if (cameraUpdateIntervals.has(cameraId)) {
            clearInterval(cameraUpdateIntervals.get(cameraId));
        }
    
        // Iniciar nuevo intervalo
        const interval = setInterval(() => {
            // Buscar el contenedor por ID
            const containerId = `camera-live-${cameraId}`;
            const container = document.getElementById(containerId);
            
            // Solo actualizar si el contenedor existe y est√° en un popover abierto
            //obtainLastFrame(cameraId, container);
            if (container && isContainerInOpenPopover(container)) {
                obtainLastFrame(cameraId, container);
            } else {
                // Si el popover est√° cerrado, podr√≠amos detener las actualizaciones para esta c√°mara
                log(`üîÑ Popover cerrado para c√°mara ${cameraId}, omitiendo actualizaci√≥n`);
            }
        }, 1000); // Actualizar cada 5 segundos
    
        cameraUpdateIntervals.set(cameraId, interval);
    }
    
    function stopCameraUpdates(cameraId) {
        if (!cameraId) {
            log('‚ö†Ô∏è stopCameraUpdates llamado sin cameraId');
            return;
        }
        
        const interval = cameraUpdateIntervals.get(cameraId);
        if (interval) {
            clearInterval(interval);
            cameraUpdateIntervals.delete(cameraId);
        }
    }
    
    // A√ëADIR: Funci√≥n para cerrar popover de c√°mara
    function closeCameraPopover(cameraId) {
        log(`‚ùå Cerrando popover de c√°mara: ${cameraId}`);
        
        // Buscar el popover abierto para esta c√°mara
        if (currentlyOpenPopover && currentlyOpenPopover.cameraId === cameraId) {
            try {
                currentlyOpenPopover.popover.open = false;
                stopCameraUpdates(cameraId);
                currentlyOpenPopover = null;
            } catch (error) {
                log('Error cerrando popover de c√°mara:', error);
            }
        }
        
        resetCameraFilter();
    }
    
    // A√±adir esta funci√≥n para mostrar informaci√≥n de la ruta:
    function showRouteInfoPanel(coordinates, type) {
        const searchResults = domCache.searchResults;
        if (!searchResults) return;
    
        let routeInfo = `
            <div style="background: #1a2b3c; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid ${type === 'person' ? '#22e6d9' : '#FF6B6B'};">
                <h4 style="color: ${type === 'person' ? '#22e6d9' : '#FF6B6B'}; margin: 0 0 10px 0;">
                    ${type === 'person' ? 'üë§ Ruta de Persona' : 'üöó Ruta de Veh√≠culo'}
                </h4>
                <div style="font-size: 12px; color: #e8f4f8;">
                    <div><strong>Puntos de ruta:</strong> ${coordinates.length}</div>
                    <div><strong>Primera detecci√≥n:</strong> ${coordinates[0].date} ${coordinates[0].time}</div>
                    <div><strong>√öltima detecci√≥n:</strong> ${coordinates[coordinates.length - 1].date} ${coordinates[coordinates.length - 1].time}</div>
                    <div style="margin-top: 8px; font-size: 11px; color: #ccc;">
                        <div>‚Ä¢ Los n√∫meros en los marcadores indican el orden cronol√≥gico</div>
                        <div>‚Ä¢ La hora muestra la √∫ltima detecci√≥n en cada c√°mara</div>
                    </div>
                </div>
                <button onclick="clearCurrentRoute()" style="
                    background: #ff6b6b;
                    color: white;
                    border: none;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 8px;
                ">‚ùå Ocultar Ruta</button>
            </div>
        `;
    
        searchResults.innerHTML = routeInfo;
    }
    
    function cleanupRouteMarkers() {
        // Verificar que el mapa exista antes de intentar limpiar
        if (!map) {
            log('‚ùå Mapa no disponible para limpiar marcadores de ruta');
            return;
        }
    
        try {
            // Buscar y eliminar cualquier marcador de ruta que pueda haber quedado
            const routeMarkers = map.querySelectorAll('[data-is-route-marker="true"]');
            if (routeMarkers.length > 0) {
                routeMarkers.forEach(marker => {
                    try {
                        if (marker.parentNode === map) {
                            map.removeChild(marker);
                        }
                    } catch (error) {
                        log('Error eliminando marcador de ruta residual:', error);
                    }
                });
                log(`‚úÖ ${routeMarkers.length} marcadores de ruta residuales eliminados`);
            }
        } catch (error) {
            log('‚ùå Error en cleanupRouteMarkers:', error);
        }
    }
    
    // Funci√≥n para guardar selecciones en localStorage
    function saveSelectionsToLocalStorage() {
        try {
            localStorage.setItem('personasInteresSeleccionadas', JSON.stringify(multiSelectedItems));
            return true;
        } catch (e) {
            log('Error al guardar en localStorage:', e);
            return false;
        }
    }
    
    // La funci√≥n removeFromSelection permanece igual (para eliminaci√≥n desde el panel principal)
    function removeFromSelection(id) {
        multiSelectedItems = multiSelectedItems.filter(item => item.id != id);
        updateCurrentSelections();
        saveSelectionsToLocalStorage();
        updateMapSelectedPersonsPanel();
    }
    
    // Versi√≥n alternativa si ARGB no funciona (usando RGBA)
    function drawAreasOnMap(areas) {
        if (!map || !areas || areas.length === 0) {
            log('‚ùå No hay mapa o √°reas para dibujar');
            return;
        }
    
        log(`üó∫Ô∏è Dibujando ${areas.length} √°reas en el mapa`);
        window.areasData = areas;
    
        clearExistingPolygons();
    
        let polygonsDrawn = 0;
        let labelsDrawn = 0;
        let clickableMarkers = 0;
    
        areas.forEach((area, index) => {
            try {
                let coordinates = [];
    
                if (area.poligono_area && typeof area.poligono_area === 'string') {
                    try {
                        const coordsArray = JSON.parse(area.poligono_area);
    
                        if (Array.isArray(coordsArray) && coordsArray.length > 0) {
                            coordinates = coordsArray.map(coord => {
                                if (Array.isArray(coord) && coord.length >= 2) {
                                    return {
                                        lat: parseFloat(coord[0]),
                                        lng: parseFloat(coord[1]),
                                        altitude: 5
                                    };
                                }
                                return null;
                            }).filter(coord => coord !== null);
                        }
                    } catch (e) {
                        log(`‚ùå Error parseando coordenadas:`, e);
                    }
                }
    
                if (coordinates.length === 0) return;
    
                // Guardar coordenadas para el √°rea
                area.polygonCoordinates = coordinates.map(coord => [coord.lat, coord.lng]);
    
                // 1. DIBUJAR POL√çGONO VISIBLE
                const polygon3D = document.createElement('gmp-polygon-3d');
                const pathString = coordinates.map(coord =>
                    `${coord.lat},${coord.lng},${coord.altitude}`
                ).join(' ');
    
                const colorOptions = [
                    { fill: 'rgba(255, 51, 51, 0.2)', stroke: 'rgba(204, 0, 0, 0.5)' },
                    { fill: 'rgba(51, 102, 255, 0.2)', stroke: 'rgba(0, 51, 204, 0.5)' },
                    { fill: 'rgba(51, 204, 51, 0.2)', stroke: 'rgba(0, 153, 0, 0.5)' },
                    { fill: 'rgba(255, 153, 51, 0.2)', stroke: 'rgba(204, 102, 0, 0.5)' },
                    { fill: 'rgba(153, 102, 255, 0.2)', stroke: 'rgba(102, 0, 204, 0.5)' },
                    { fill: 'rgba(255, 102, 204, 0.2)', stroke: 'rgba(204, 51, 153, 0.5)' }
                ];
    
                const color = colorOptions[index % colorOptions.length];
    
                polygon3D.setAttribute('path', pathString);
                polygon3D.setAttribute('fill-color', color.fill);
                polygon3D.setAttribute('stroke-color', color.stroke);
                polygon3D.setAttribute('stroke-width', '2');
                polygon3D.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
                polygon3D.setAttribute('fill-opacity', '1.0');
                polygon3D.setAttribute('stroke-opacity', '1.0');
    
                polygon3D.setAttribute('data-area-id', area.id_area || index);
                polygon3D.setAttribute('data-area-name', area.nombre_area || `√Årea ${index + 1}`);
                polygon3D.setAttribute('data-type', 'area');
    
                map.appendChild(polygon3D);
    
                if (!window.drawnPolygons) window.drawnPolygons = [];
                window.drawnPolygons.push(polygon3D);
    
                polygonsDrawn++;
    
                // 2. CREAR MARCADORES INVISIBLES EN LOS V√âRTICES PARA CAPTURAR CLICS
                createClickableAreaVertices(area, coordinates, index);
                clickableMarkers += coordinates.length;
    
                // 3. CREAR ETIQUETA DIRECTAMENTE RENDERIZADA
                createAreaLabelDirect(area, coordinates, index);
                labelsDrawn++;
                
                createClickableAreaVertices(area, coordinates, index);
                clickableMarkers += coordinates.length;
                
                // Enfoque 2: Marcador grande en centro (m√°s f√°cil de clickear)
                createClickableAreaCenter(area, coordinates, index);
                clickableMarkers += 1;
    
                log(`‚úÖ ${area.nombre_area} - Pol√≠gono: S√≠, Marcadores clickeables: ${coordinates.length}, Etiqueta: S√≠`);
    
            } catch (error) {
                log(`‚ùå Error dibujando √°rea:`, error);
            }
        });
    
        log(`üéâ ${polygonsDrawn} pol√≠gonos, ${clickableMarkers} marcadores clickeables, ${labelsDrawn} etiquetas`);
    }
    
    function createClickableAreaVertices(area, coordinates, areaIndex) {
        try {
            // Crear un marcador invisible grande en cada v√©rtice del pol√≠gono
            coordinates.forEach((coord, vertexIndex) => {
                const clickableMarker = document.createElement('gmp-marker-3d');
                clickableMarker.setAttribute('position', `${coord.lat},${coord.lng},${coord.altitude + 1}`);
                clickableMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
                clickableMarker.setAttribute('scale', '15'); // Tama√±o suficiente para capturar clics
                clickableMarker.setAttribute('color', 'rgba(0,0,0,0)'); // Completamente transparente
                clickableMarker.setAttribute('interactive', 'true');
                
                // Usar template vac√≠o para evitar el √≠cono por defecto
                const template = document.createElement('template');
                template.innerHTML = `<div style="display: none;"></div>`;
                clickableMarker.appendChild(template.content.cloneNode(true));
                
                // A√±adir datos del √°rea
                clickableMarker.setAttribute('data-area-id', area.id_area || areaIndex);
                clickableMarker.setAttribute('data-area-name', area.nombre_area || `√Årea ${areaIndex + 1}`);
                clickableMarker.setAttribute('data-type', 'area-vertex-clickable');
                clickableMarker.setAttribute('data-area-data', JSON.stringify(area));
                clickableMarker.setAttribute('data-vertex-index', vertexIndex);
                
                // A√±adir evento gmp-click
                clickableMarker.addEventListener('gmp-click', (event) => {
                    event.stopPropagation();
                    console.log(`üéØ gmp-click en v√©rtice del √°rea: ${area.nombre_area}`);
                    handleAreaClick(area, area.polygonCoordinates, event);
                });
                
                // Tambi√©n a√±adir evento click normal
                clickableMarker.addEventListener('click', (event) => {
                    event.stopPropagation();
                    console.log(`üéØ click en v√©rtice del √°rea: ${area.nombre_area}`);
                    handleAreaClick(area, area.polygonCoordinates, event);
                });
    
                map.appendChild(clickableMarker);
    
                if (!window.drawnPolygons) window.drawnPolygons = [];
                window.drawnPolygons.push(clickableMarker);
            });
    
        } catch (error) {
            log(`‚ùå Error creando marcadores de v√©rtices:`, error);
        }
    }
    
    function createClickableAreaCenter(area, coordinates, areaIndex) {
        try {
            const center = calculatePolygonCenter(coordinates);
            
            // Crear marcador invisible pero MUY grande en el centro
            const clickableMarker = document.createElement('gmp-marker-3d');
            clickableMarker.setAttribute('position', `${center.lat},${center.lng},${center.altitude + 1}`);
            clickableMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            clickableMarker.setAttribute('scale', '50'); // MUY grande para cubrir el √°rea
            clickableMarker.setAttribute('color', 'rgba(0,0,0,0)'); // Completamente transparente
            clickableMarker.setAttribute('interactive', 'true');
            
            // Template vac√≠o
            const template = document.createElement('template');
            template.innerHTML = `<div style="display: none;"></div>`;
            clickableMarker.appendChild(template.content.cloneNode(true));
            
            // A√±adir datos del √°rea
            clickableMarker.setAttribute('data-area-id', area.id_area || areaIndex);
            clickableMarker.setAttribute('data-area-name', area.nombre_area || `√Årea ${areaIndex + 1}`);
            clickableMarker.setAttribute('data-type', 'area-center-clickable');
            clickableMarker.setAttribute('data-area-data', JSON.stringify(area));
            
            // A√±adir eventos
            clickableMarker.addEventListener('gmp-click', (event) => {
                event.stopPropagation();
                console.log(`üéØ gmp-click en √°rea (centro): ${area.nombre_area}`);
                handleAreaClick(area, area.polygonCoordinates, event);
            });
            
            clickableMarker.addEventListener('click', (event) => {
                event.stopPropagation();
                console.log(`üéØ click en √°rea (centro): ${area.nombre_area}`);
                handleAreaClick(area, area.polygonCoordinates, event);
            });
    
            map.appendChild(clickableMarker);
    
            if (!window.drawnPolygons) window.drawnPolygons = [];
            window.drawnPolygons.push(clickableMarker);
    
            log(`‚úÖ Marcador central clickeable creado para: ${area.nombre_area}`);
    
        } catch (error) {
            log(`‚ùå Error creando marcador central:`, error);
        }
    }
    
    function createClickableAreaMarker(area, coordinates, index) {
        try {
            const center = calculatePolygonCenter(coordinates);
            
            // Crear marcador invisible pero clickeable
            const clickableMarker = document.createElement('gmp-marker-3d');
            clickableMarker.setAttribute('position', `${center.lat},${center.lng},${center.altitude + 1}`);
            clickableMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            clickableMarker.setAttribute('scale', '30'); // √Årea de click grande
            clickableMarker.setAttribute('color', 'rgba(0,0,0,0)'); // Completamente transparente
            clickableMarker.setAttribute('interactive', 'true');
            
            // Usar PinElement para evitar errores de consola
            if (typeof PinElement !== 'undefined') {
                const pinElement = new PinElement({
                    background: 'transparent',
                    borderColor: 'transparent',
                    glyphColor: 'transparent',
                    scale: 0.1 // Muy peque√±o
                });
                clickableMarker.appendChild(pinElement.element);
            }
            
            // A√±adir datos del √°rea
            clickableMarker.setAttribute('data-area-id', area.id_area || index);
            clickableMarker.setAttribute('data-area-name', area.nombre_area || `√Årea ${index + 1}`);
            clickableMarker.setAttribute('data-type', 'area-clickable');
            clickableMarker.setAttribute('data-area-data', JSON.stringify(area));
            
            // A√±adir evento gmp-click
            clickableMarker.addEventListener('gmp-click', (event) => {
                event.stopPropagation();
                console.log(`üéØ gmp-click en √°rea: ${area.nombre_area}`);
                handleAreaClick(area, area.polygonCoordinates, event);
            });
            
            // Tambi√©n a√±adir evento click normal por si acaso
            clickableMarker.addEventListener('click', (event) => {
                event.stopPropagation();
                console.log(`üéØ click en √°rea: ${area.nombre_area}`);
                handleAreaClick(area, area.polygonCoordinates, event);
            });
    
            map.appendChild(clickableMarker);
    
            if (!window.drawnPolygons) window.drawnPolygons = [];
            window.drawnPolygons.push(clickableMarker);
    
        } catch (error) {
            log(`‚ùå Error creando marcador clickeable:`, error);
        }
    }
    
    function createAreaLabelDirect(area, coordinates, index) {
        try {
            const center = calculatePolygonCenter(coordinates);
            const areaName = area.nombre_area || `√Årea ${index + 1}`;
    
            // Usar directamente gmp-popover sin marcador
            const labelPopover = document.createElement('gmp-popover');
            
            // Configurar posici√≥n
            labelPopover.setAttribute('position', `${center.lat},${center.lng},${center.altitude + 25}`);
            labelPopover.setAttribute('open', 'true');
            labelPopover.setAttribute('interactive', 'false');
            
            // Crear contenido de solo texto
            const template = document.createElement('template');
            template.innerHTML = `
                <div style="
                    color: white;
                    font-size: 12px;
                    font-weight: bold;
                    background: rgba(0, 0, 0, 0.9);
                    padding: 6px 12px;
                    border-radius: 6px;
                    white-space: nowrap;
                    pointer-events: none;
                    font-family: Arial, sans-serif;
                    text-align: center;
                    border: 2px solid rgba(255, 255, 255, 0.5);
                    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
                    backdrop-filter: blur(4px);
                    text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
                    z-index: 1000;
                ">${areaName}</div>
            `;
            
            labelPopover.appendChild(template.content.cloneNode(true));
    
            // A√±adir datos
            labelPopover.setAttribute('data-area-id', area.id_area || index);
            labelPopover.setAttribute('data-area-name', areaName);
            labelPopover.setAttribute('data-type', 'area-label');
    
            // A√±adir al mapa
            map.appendChild(labelPopover);
    
            // Guardar referencia
            if (!window.drawnPolygons) window.drawnPolygons = [];
            window.drawnPolygons.push(labelPopover);
    
            log(`‚úÖ Etiqueta directa creada: ${areaName}`);
    
        } catch (error) {
            log(`‚ùå Error creando etiqueta directa:`, error);
        }
    }
    
    function createAreaLabelFallback(area, coordinates, index) {
        try {
            const center = calculatePolygonCenter(coordinates);
            const areaName = area.nombre_area || `√Årea ${index + 1}`;
    
            // M√©todo alternativo usando marker con escala casi cero
            const labelMarker = document.createElement('gmp-marker-3d');
            labelMarker.setAttribute('position', `${center.lat},${center.lng},${center.altitude + 15}`);
            labelMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            labelMarker.setAttribute('scale', '0.001'); // Casi invisible
            labelMarker.setAttribute('color', 'transparent');
            labelMarker.setAttribute('interactive', 'false');
            
            // Configurar solo el label
            labelMarker.setAttribute('label', areaName);
            labelMarker.setAttribute('background-color', 'rgba(0, 0, 0, 0.8)');
            labelMarker.setAttribute('font-color', '#FFFFFF');
            labelMarker.setAttribute('font-size', '11px');
            labelMarker.setAttribute('font-weight', 'bold');
    
            // A√±adir datos
            labelMarker.setAttribute('data-area-id', area.id_area || index);
            labelMarker.setAttribute('data-area-name', areaName);
            labelMarker.setAttribute('data-type', 'area-label');
    
            map.appendChild(labelMarker);
    
            if (!window.drawnPolygons) window.drawnPolygons = [];
            window.drawnPolygons.push(labelMarker);
    
            log(`‚úÖ Etiqueta fallback creada: ${areaName}`);
    
        } catch (error) {
            log(`‚ùå Error en fallback de etiqueta:`, error);
        }
    }
    
    function createAreaLabel(area, coordinates, index) {
        try {
            const center = calculatePolygonCenter(coordinates);
            const areaName = area.nombre_area || `√Årea ${index + 1}`;
    
            // Crear un marcador 3D pero configurado para mostrar SOLO el texto
            const textMarker = document.createElement('gmp-marker-3d');
            textMarker.setAttribute('position', `${center.lat},${center.lng},${center.altitude + 10}`);
            textMarker.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            
            // Configurar SOLO el texto del label
            textMarker.setAttribute('label', areaName);
            
            // Ocultar completamente el √≠cono del marcador
            textMarker.setAttribute('scale', '0.001'); // Casi invisible
            textMarker.setAttribute('color', 'transparent'); // Color transparente
            
            // Configurar estilo del texto
            textMarker.setAttribute('background-color', 'rgba(0, 0, 0, 0.7)');
            textMarker.setAttribute('font-color', '#FFFFFF');
            textMarker.setAttribute('font-size', '11px');
            textMarker.setAttribute('font-weight', 'bold');
    
            // A√±adir datos para identificarla
            textMarker.setAttribute('data-area-id', area.id_area || index);
            textMarker.setAttribute('data-area-name', areaName);
            textMarker.setAttribute('data-type', 'area-label');
    
            // A√±adir al mapa
            map.appendChild(textMarker);
    
            // Guardar referencia para limpiar despu√©s
            if (!window.drawnPolygons) window.drawnPolygons = [];
            window.drawnPolygons.push(textMarker);
    
            log(`‚úÖ Etiqueta de √°rea a√±adida: ${areaName}`);
    
        } catch (error) {
            log(`‚ùå Error creando etiqueta de √°rea:`, error);
        }
    }
    
    function createAbsoluteLabel(area, coordinates, index) {
        try {
            const center = calculatePolygonCenter(coordinates);
            const areaName = area.nombre_area || `√Årea ${index + 1}`;
    
            // Crear un div absoluto sobre el mapa (esto puede ser complicado con coordenadas)
            const labelDiv = document.createElement('div');
            labelDiv.textContent = areaName;
            labelDiv.style.cssText = `
                position: absolute;
                color: white;
                font-size: 11px;
                font-weight: bold;
                white-space: nowrap;
                text-align: center;
                font-family: Arial, sans-serif;
                text-shadow: 
                    2px 2px 4px rgba(0,0,0,0.8),
                    -2px -2px 4px rgba(0,0,0,0.8),
                    2px -2px 4px rgba(0,0,0,0.8),
                    -2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
                user-select: none;
                z-index: 1000;
                background: transparent;
                border: none;
                padding: 0;
                margin: 0;
            `;
    
            // NOTA: Esta aproximaci√≥n requiere convertir coordenadas a p√≠xeles
            // lo cual es complejo en Google Maps 3D. Mejor usar el m√©todo anterior.
            
            log(`‚ö†Ô∏è Usando fallback absoluto para: ${areaName}`);
    
        } catch (error) {
            log(`‚ùå Error en fallback absoluto:`, error);
        }
    }
    
    // A√±adir esta funci√≥n para inicializar los estilos de √°rea
    function initAreaLabelStyles() {
        if (document.querySelector('#area-label-global-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'area-label-global-styles';
        style.textContent = `
            /* Eliminar completamente el estilo de popover para las etiquetas de √°rea */
            gmp-popover[data-type="area-label"] {
                --gmp-popover--background-color: transparent !important;
                --gmp-popover--border: none !important;
                --gmp-popover--box-shadow: none !important;
                --gmp-popover--padding: 0 !important;
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            gmp-popover[data-type="area-label"]::part(container) {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            gmp-popover[data-type="area-label"]::part(content) {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                padding: 0 !important;
                margin: 0 !important;
            }
        `;
        document.head.appendChild(style);
    }
    
    function calculatePolygonCenter(coordinates) {
        if (!coordinates || coordinates.length === 0) {
            return { lat: 0, lng: 0, altitude: 0 };
        }
    
        let sumLat = 0;
        let sumLng = 0;
        let sumAlt = 0;
    
        coordinates.forEach(coord => {
            sumLat += coord.lat;
            sumLng += coord.lng;
            sumAlt += coord.altitude;
        });
    
        const count = coordinates.length;
        return {
            lat: sumLat / count,
            lng: sumLng / count,
            altitude: sumAlt / count
        };
    }
    
    function drawPolygon(polygonString, fillColor, fillOpacity, strokeWidth, type) {
        try {
            // Parsear el string del pol√≠gono
            const coordinates = JSON.parse(polygonString);
            
            // Crear el elemento polygon-3d
            const polygon = document.createElement('gmp-polygon-3d');
            
            // Configurar las propiedades del pol√≠gono
            polygon.setAttribute('paths', JSON.stringify(coordinates.map(coord => ({
                lat: coord[0],
                lng: coord[1]
            }))));
            polygon.setAttribute('fill-color', fillColor);
            polygon.setAttribute('fill-opacity', fillOpacity.toString());
            polygon.setAttribute('stroke-color', fillColor);
            polygon.setAttribute('stroke-width', strokeWidth.toString());
            polygon.setAttribute('stroke-opacity', '0.8');
            polygon.setAttribute('altitude', '5'); // Peque√±a elevaci√≥n para evitar solapamiento
            polygon.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            polygon.setAttribute('data-type', type);
            
            // A√±adir tooltip informativo
            polygon.setAttribute('title', `Tipo: ${type}`);
            
            // A√±adir al mapa
            map.appendChild(polygon);
            
            // Guardar referencia para poder limpiar despu√©s
            if (!window.drawnPolygons) {
                window.drawnPolygons = [];
            }
            window.drawnPolygons.push(polygon);
            
        } catch (error) {
            log(`‚ùå Error dibujando pol√≠gono (${type}):`, error);
        }
    }
    
    function drawPolygonFromPoints(points, fillColor, fillOpacity, strokeWidth, type) {
        try {
            // Crear el elemento polygon-3d desde puntos
            const polygon = document.createElement('gmp-polygon-3d');
            
            // Configurar las propiedades del pol√≠gono
            polygon.setAttribute('paths', JSON.stringify(points.map(point => ({
                lat: point.lat,
                lng: point.lon
            }))));
            polygon.setAttribute('fill-color', fillColor);
            polygon.setAttribute('fill-opacity', fillOpacity.toString());
            polygon.setAttribute('stroke-color', fillColor);
            polygon.setAttribute('stroke-width', strokeWidth.toString());
            polygon.setAttribute('stroke-opacity', '0.8');
            polygon.setAttribute('altitude', '2');
            polygon.setAttribute('altitude-mode', 'RELATIVE_TO_GROUND');
            polygon.setAttribute('data-type', type);
            
            // A√±adir tooltip informativo
            polygon.setAttribute('title', `Tipo: ${type}`);
            
            // A√±adir al mapa
            map.appendChild(polygon);
            
            // Guardar referencia
            if (!window.drawnPolygons) {
                window.drawnPolygons = [];
            }
            window.drawnPolygons.push(polygon);
            
        } catch (error) {
            log(`‚ùå Error dibujando pol√≠gono desde puntos (${type}):`, error);
        }
    }
    
    function clearExistingPolygons() {
        if (window.drawnPolygons && window.drawnPolygons.length > 0) {
            log(`üóëÔ∏è Limpiando ${window.drawnPolygons.length} elementos (pol√≠gonos y etiquetas)`);
            window.drawnPolygons.forEach(element => {
                try {
                    if (element.parentNode === map) {
                        map.removeChild(element);
                    }
                } catch (error) {
                    log('Error eliminando elemento:', error);
                }
            });
            window.drawnPolygons = [];
        }
    }
    
    // Funci√≥n para mostrar/ocultar etiquetas
    function toggleAreaLabels(show = true) {
        if (!window.drawnPolygons) return;
        
        window.drawnPolygons.forEach(element => {
            try {
                const type = element.getAttribute('data-type');
                if (type === 'area-label') {
                    element.style.display = show ? 'block' : 'none';
                }
            } catch (error) {
                log('Error modificando etiqueta:', error);
            }
        });
        
        log(`üè∑Ô∏è Etiquetas ${show ? 'mostradas' : 'ocultadas'}`);
    }
    
    // Funci√≥n para cambiar el tama√±o de las etiquetas
    function adjustLabelSize(fontSize = '14px') {
        if (!window.drawnPolygons) return;
        
        window.drawnPolygons.forEach(element => {
            try {
                const type = element.getAttribute('data-type');
                if (type === 'area-label') {
                    element.setAttribute('font-size', fontSize);
                }
            } catch (error) {
                log('Error ajustando tama√±o de etiqueta:', error);
            }
        });
        
        log(`üî† Tama√±o de etiquetas ajustado a: ${fontSize}`);
    }
    
    // A√±ade esta funci√≥n para crear controles de capas
    function addPolygonLayerControls() {
        const legend = document.querySelector('.map-legend');
        if (!legend) return;
    
        const layerControls = document.createElement('div');
        layerControls.className = 'layer-controls';
        layerControls.innerHTML = `
            <div class="legend-header">
                <div class="legend-title">Capas de √Åreas</div>
                <button class="legend-toggle">‚àí</button>
            </div>
            <div class="legend-body">
                <div class="layer-control-item">
                    <input type="checkbox" id="toggle-areas" checked>
                    <label for="toggle-areas">√Åreas Principales</label>
                </div>
                <div class="layer-control-item">
                    <input type="checkbox" id="toggle-zonas" checked>
                    <label for="toggle-zonas">Zonas</label>
                </div>
                <div class="layer-control-item">
                    <input type="checkbox" id="toggle-subzonas">
                    <label for="toggle-subzonas">Subzonas</label>
                </div>
                <div class="layer-control-item">
                    <input type="checkbox" id="toggle-cuadrantes">
                    <label for="toggle-cuadrantes">Cuadrantes</label>
                </div>
                <button id="refresh-polygons" class="btn btn-accent" style="margin-top: 10px; width: 100%;">
                    Actualizar Pol√≠gonos
                </button>
            </div>
        `;
    
        legend.parentNode.insertBefore(layerControls, legend.nextSibling);
    
        // Event listeners para los controles
        document.getElementById('toggle-areas').addEventListener('change', toggleLayerVisibility);
        document.getElementById('toggle-zonas').addEventListener('change', toggleLayerVisibility);
        document.getElementById('toggle-subzonas').addEventListener('change', toggleLayerVisibility);
        document.getElementById('toggle-cuadrantes').addEventListener('change', toggleLayerVisibility);
        
        document.getElementById('refresh-polygons').addEventListener('click', function() {
            if (areasData && areasData.length > 0) {
                drawAreasOnMap(areasData);
            }
        });
    }
    
    function toggleLayerVisibility(event) {
        const checkbox = event.target;
        const layerType = checkbox.id.replace('toggle-', '');
        const opacity = checkbox.checked ? (layerType === 'areas' ? 0.2 : layerType === 'zonas' ? 0.15 : layerType === 'subzonas' ? 0.1 : 0.05) : 0;
        
        if (window.drawnPolygons) {
            window.drawnPolygons.forEach(polygon => {
                if (polygon.getAttribute('data-type') === layerType) {
                    polygon.setAttribute('fill-opacity', opacity.toString());
                    polygon.setAttribute('stroke-opacity', checkbox.checked ? '0.8' : '0');
                }
            });
        }
    }
    
    function setupMapClickDetection() {
        if (!map) return;
    
        // SOLO para debug - remover despu√©s de probar
        map.addEventListener('click', (event) => {
            if (event.detail && event.detail.latLng) {
                const lat = event.detail.latLng.lat;
                const lng = event.detail.latLng.lng;
                console.log(`üìç Clic en: ${lat}, ${lng}`);
                
                // Verificar si es un clic en √°rea
                checkAreaClick(lat, lng);
            }
        });
    }
    
    function checkAreaClick(lat, lng) {
        if (!window.areasData || window.areasData.length === 0) return;
        
        let areaClicked = null;
        
        for (const area of window.areasData) {
            if (area.polygonCoordinates && isPointInPolygon(lat, lng, area.polygonCoordinates)) {
                areaClicked = area;
                break;
            }
        }
        
        if (areaClicked) {
            console.log(`üéØ √Årea clickeada: ${areaClicked.nombre_area}`);
            handleAreaClick(areaClicked, areaClicked.polygonCoordinates);
        }
    }
    
    let areaSelectionMode = false;
    
    function toggleAreaSelectionMode() {
        areaSelectionMode = !areaSelectionMode;
        
        if (areaSelectionMode) {
            // Activar modo selecci√≥n
            map.style.cursor = 'crosshair';
            showTempMessage('üîç Modo selecci√≥n de √°reas activado - Haz clic en cualquier √°rea');
            
            // Configurar detector temporal de clics
            setupTemporaryAreaClickDetection();
        } else {
            // Desactivar modo selecci√≥n
            map.style.cursor = '';
            showTempMessage('Modo selecci√≥n de √°reas desactivado');
            
            // Remover detector temporal
            removeTemporaryAreaClickDetection();
        }
    }
    
    function setupTemporaryAreaClickDetection() {
        if (!map) return;
        
        // Guardar referencia a la funci√≥n para poder removerla despu√©s
        window.temporaryAreaClickHandler = (event) => {
            if (event.detail && event.detail.latLng) {
                const lat = event.detail.latLng.lat;
                const lng = event.detail.latLng.lng;
                
                const clickedArea = findAreaAtCoordinates(lat, lng);
                if (clickedArea) {
                    handleAreaClick(clickedArea, clickedArea.polygonCoordinates);
                    // Auto-desactivar modo despu√©s de click exitoso
                    toggleAreaSelectionMode();
                }
            }
        };
        
        map.addEventListener('click', window.temporaryAreaClickHandler);
    }
    
    function removeTemporaryAreaClickDetection() {
        if (window.temporaryAreaClickHandler) {
            map.removeEventListener('click', window.temporaryAreaClickHandler);
            window.temporaryAreaClickHandler = null;
        }
    }
    
    function createAreasPanel() {
    // Verificar si ya existe el panel
        if (document.querySelector('.areas-panel')) return;
        
        const panel = document.createElement('div');
        panel.className = 'areas-panel';
        panel.innerHTML = `
            <div class="panel-header">
                <h3>√Åreas Disponibles</h3>
                <button onclick="toggleAreasPanel()" class="close-btn">√ó</button>
            </div>
            <div class="areas-list" id="areasList">
                <!-- Las √°reas se cargar√°n aqu√≠ -->
            </div>
        `;
        
        panel.style.cssText = `
            position: absolute;
            top: 100px;
            right: 20px;
            width: 300px;
            background: #1a2b3c;
            border: 2px solid #22e6d9;
            border-radius: 8px;
            padding: 15px;
            color: white;
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        `;
        
        document.getElementById('dashboard').appendChild(panel);
        return panel;
    }
    
    function loadAreasIntoPanel() {
        const areasList = document.getElementById('areasList');
        if (!areasList || !window.areasData) return;
        
        let html = '';
        
        window.areasData.forEach((area, index) => {
            const areaName = area.nombre_area || `√Årea ${index + 1}`;
            html += `
                <div class="area-list-item" data-area-index="${index}" 
                     onclick="selectAreaFromList(${index})"
                     style="
                        padding: 10px;
                        margin: 5px 0;
                        background: rgba(34, 230, 217, 0.1);
                        border-radius: 4px;
                        cursor: pointer;
                        border: 1px solid rgba(34, 230, 217, 0.3);
                        transition: all 0.3s ease;
                     "
                     onmouseover="this.style.background='rgba(34, 230, 217, 0.2)';"
                     onmouseout="this.style.background='rgba(34, 230, 217, 0.1)';">
                    <strong>${areaName}</strong>
                    <div style="font-size: 12px; color: #ccc;">
                        Puntos: ${area.polygonCoordinates ? area.polygonCoordinates.length : 0}
                    </div>
                </div>
            `;
        });
        
        areasList.innerHTML = html || '<div style="padding: 10px; text-align: center;">No hay √°reas disponibles</div>';
    }
    
    function selectAreaFromList(index) {
        if (!window.areasData || !window.areasData[index]) return;
        
        const area = window.areasData[index];
        console.log(`üéØ √Årea seleccionada desde lista: ${area.nombre_area}`);
        
        handleAreaClick(area, area.polygonCoordinates);
        
        // Centrar en el √°rea
        const center = calculatePolygonCenter(area.polygonCoordinates.map(coord => ({
            lat: coord[0], 
            lng: coord[1], 
            altitude: 5
        })));
        
        if (map) {
            map.setAttribute('center', `${center.lat},${center.lng}`);
            map.setAttribute('range', '150');
        }
    }
    
    function toggleAreasPanel() {
        const panel = document.querySelector('.areas-panel');
        if (panel) {
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                loadAreasIntoPanel();
            }
        }
    }
    
    // A√±adir bot√≥n para abrir el panel de √°reas
    function addAreasPanelButton() {
        // Verificar si ya existe el bot√≥n
        if (document.querySelector('#areas-panel-button')) return;
        
        const button = document.createElement('button');
        button.id = 'areas-panel-button';
        button.innerHTML = 'üó∫Ô∏è √Åreas';
        button.style.cssText = `
            position: absolute;
            top: 150px;
            right: 20px;
            background: #22e6d9;
            color: #1a2b3c;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1000;
        `;
        button.onclick = toggleAreasPanel;
        
        document.getElementById('dashboard').appendChild(button);
    }
    
    function handleAreaClick(area, coordinates, event) {
        console.log('üéØ √Årea clickeada via marcador:', area.nombre_area);
        
        // Resaltar el √°rea
        highlightClickedArea(area.id_area || area.tempId);
        
        // Mostrar informaci√≥n
        showAreaDetails(area, coordinates);
        
        // Centrar el mapa
        const center = calculatePolygonCenter(coordinates.map(coord => ({lat: coord[0], lng: coord[1], altitude: 5})));
        if (map) {
            map.setAttribute('center', `${center.lat},${center.lng}`);
            map.setAttribute('range', '150');
        }
        
        // Prevenir propagaci√≥n
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
    
    function showAreaDetails(area, coordinates) {
        const panel = document.getElementById('alert-details');
        const content = document.getElementById('alert-details-content');
        
        if (!panel || !content) {
            console.warn('‚ùå No se encontr√≥ el panel de detalles');
            return;
        }
        
        const center = calculatePolygonCenter(coordinates.map(coord => ({lat: coord[0], lng: coord[1], altitude: 5})));
        const areaInfo = `
            <div style="max-width: 350px;">
                <div class="detail-item">
                    <h4 class="person-details-title">${area.nombre_area || '√Årea'}</h4>
                </div>
                <div class="detail-item">
                    <span class="detail-label">ID √Årea:</span>
                    <span class="detail-value">${area.id_area || 'N/A'}</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">ID Subzona:</span>
                    <span class="detail-value">${area.id_subzona || 'N/A'}</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Puntos del pol√≠gono:</span>
                    <span class="detail-value">${coordinates.length}</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">Centro:</span>
                    <span class="detail-value">
                        ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}
                    </span>
                </div>
                ${area.descripcion ? `
                <div class="detail-item">
                    <span class="detail-label">Descripci√≥n:</span>
                    <span class="detail-value">${area.descripcion}</span>
                </div>
                ` : ''}
                <button onclick="zoomToArea(${JSON.stringify(coordinates).replace(/"/g, '&quot;')})" style="
                    background: #22e6d9;
                    color: #1a2b3c;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 10px;
                    width: 100%;
                    font-weight: bold;
                ">üîç Zoom al √Årea</button>
                <button onclick="closeAreaDetails()" style="
                    background: #ff4757;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                    margin-top: 5px;
                    width: 100%;
                ">Cerrar</button>
            </div>
        `;
        
        content.innerHTML = areaInfo;
        panel.style.display = 'block';
    }
    
    function closeAreaDetails() {
        const panel = document.getElementById('alert-details');
        if (panel) {
            panel.style.display = 'none';
        }
        // Quitar highlight del √°rea
        if (window.currentHighlightedArea) {
            const originalFill = window.currentHighlightedArea.getAttribute('data-original-fill');
            const originalStroke = window.currentHighlightedArea.getAttribute('data-original-stroke');
            if (originalFill) {
                window.currentHighlightedArea.setAttribute('fill-color', originalFill);
                window.currentHighlightedArea.setAttribute('stroke-color', originalStroke);
                window.currentHighlightedArea.setAttribute('stroke-width', '3');
            }
            window.currentHighlightedArea = null;
        }
    }
    
    function zoomToArea(coordinates) {
        if (!coordinates || coordinates.length === 0) return;
        
        const center = calculatePolygonCenter(coordinates.map(coord => ({lat: coord[0], lng: coord[1], altitude: 5})));
        if (map) {
            map.setAttribute('center', `${center.lat},${center.lng}`);
            map.setAttribute('range', '100');
        }
    }
    
    function highlightClickedArea(areaId) {
        if (!areaId) return;
        
        // Quitar highlight anterior
        if (window.currentHighlightedArea) {
            const originalFill = window.currentHighlightedArea.getAttribute('data-original-fill');
            const originalStroke = window.currentHighlightedArea.getAttribute('data-original-stroke');
            if (originalFill) {
                window.currentHighlightedArea.setAttribute('fill-color', originalFill);
                window.currentHighlightedArea.setAttribute('stroke-color', originalStroke);
                window.currentHighlightedArea.setAttribute('stroke-width', '3');
            }
        }
        
        // Aplicar highlight al √°rea clickeada
        const clickedArea = document.querySelector(`[data-area-id="${areaId}"][data-type="area"]`);
        if (clickedArea) {
            // Guardar color original si no existe
            if (!clickedArea.getAttribute('data-original-fill')) {
                clickedArea.setAttribute('data-original-fill', clickedArea.getAttribute('fill-color'));
                clickedArea.setAttribute('data-original-stroke', clickedArea.getAttribute('stroke-color'));
            }
            
            // Aplicar highlight permanente
            const newFill = clickedArea.getAttribute('fill-color').replace('0.2', '0.6');
            clickedArea.setAttribute('fill-color', newFill);
            clickedArea.setAttribute('stroke-color', '#FF6B6B');
            clickedArea.setAttribute('stroke-width', '5');
            
            window.currentHighlightedArea = clickedArea;
        }
    }

</script>