<div id="civix-neo">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    {{styleshtml}}

 <div class="splash" id="splash">
     
    <h2 style="color:var(--ink-strong)">Módulo de Alertas</h2>
    <button id="enter" class="btn btn-accent">Ingresar al Dashboard</button>
  </div>
    <!--
  <div class="top-right" id="controls">
    <button id="exit" class="btn btn-accent">Salir de pantalla completa</button>
  </div>
  -->

  <div id="dashboard">
    <div class="grid">
        <div class="panel">
            <div class="tabs-container">
                <div class="tabs-header">
                    <button class="tab-button active" data-tab="kpi">KPI's</button>
                    <button class="tab-button" data-tab="busqueda">Búsqueda</button>
                </div>

                <div class="tabs-content">
                    <!-- Pestaña 1: Personas de Interés -->
                    <div class="tab-pane active" id="tab-kpi">
                        <div id="kpiContent">
                            <div class="kpi-header">
                                <h3>KPIs</h3>
                                <span id="kpi-timestamp" style="font-size: 12px; color: var(--ink);"></span>
                            </div>

                            <div class="kpi-grid">
                                <!-- El resto del contenido permanece igual -->
                                <div class="kpi-card">
                                    <div style="display:flex;justify-content:space-between;align-items:center;">
                                        <h3 class="kpi-title">Total Alertas</h3>
                                        <h3 class="kpi-value" id="total-alerts">0</h3>
                                    </div>
                                </div>

                                <!-- Gráfico de Tendencia -->
                                <div class="kpi-card">
                                  <h3 class="kpi-title">Tendencia (4h)</h3>
                                  <div id="trend-chart-container" class="bar-chart-container">
                                    <div class="loading">Cargando tendencia...</div>
                                  </div>
                                </div>

                                <button id="clear-filters-btn" class="clear-filters-btn" disabled>Limpiar Filtros</button>

                                <div class="kpi-card">
                                  <h3 class="kpi-title">Top Tipos de Alertas</h3>
                                  <div id="alert-type-metrics" class="bar-chart-container">
                                    <div class="loading">Cargando...</div>
                                  </div>
                                </div>

                                <div class="kpi-card">
                                  <h3 class="kpi-title">Top Cámaras</h3>
                                  <div id="camera-metrics" class="bar-chart-container">
                                    <div class="loading">Cargando...</div>
                                  </div>
                                </div>
                              </div>
                        </div>
                    </div>

                    <!-- Pestaña 2: Vehículos -->
                    <div class="tab-pane" id="tab-busqueda">
                        <div id="busquedaContent">
                            <div id="selected-persons-container" style="margin-bottom:20px; border-top: 1px solid rgba(34,230,217,0.2); padding-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <h4 style="color: var(--teal); margin: 0;">Lista de Interés</h4>
                                    <button type="button" class="btn btn-default" data-search-type="personas-interes"
                                            style="padding: 8px 12px; font-size: 12px;">
                                        Seleccionar
                                    </button>
                                </div>
                                <div id="current-selections-list">
                                    <!-- Las selecciones se cargarán aquí dinámicamente -->
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: auto; gap: 10px; margin-bottom: 15px;">
                                <button type="button" class="btn btn-default" data-search-type="personas">
                                    Búsqueda de Personas
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="vehiculos">
                                    Búsqueda de Vehículos
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="placa">
                                    Búsqueda por placa de Vehículos
                                </button>
                                <button type="button" class="btn btn-default" data-search-type="caracteristicas">
                                    Búsqueda por Características
                                </button>
                            </div>

                            <!-- Por este: -->
                            <div id="selectedPersonBox" style="display: none; background: var(--panel); padding: 12px; margin-bottom: 12px; border-radius: 8px; border: 1px solid rgba(34,230,217,0.2);">
                                <div id="selectedPersonDetails"></div>
                            </div>
                            <!-- Formulario de búsqueda por placa -->
                            <div id="placa-search-form" class="search-form" style="display: none;">
                                <h4>Búsqueda por Placa</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                    <input type="text" id="placa-input" placeholder="Ingrese número de placa"
                                           style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
                                    <button type="button" class="btn btn-accent" id="search-placa-btn">Buscar</button>
                                </div>
                                <div id="placa-results"></div>
                            </div>

                            <!-- Formulario de búsqueda por características -->
                            <div id="caracteristicas-search-form" class="search-form" style="display: none;">
                                <h4>Búsqueda por Características</h4>
                                <div>
                                    <small>*Los campos son requeridos</small>
                                </div>
                                <div style="display: grid; grid-template-columns: 48% 48%; gap: 10px; margin-bottom: 15px;">
                                    <div>
                                        <label for="txtFechaIni">Fecha Inicio*</label>
                                        <div class="form-group ">
                                            <input id="txtFechaIni" type="datetime-local" class="form-control">
                                        </div>
                                    </div>

                                    <div>
                                        <label for="txtFechaFin">Fecha Fin*</label>
                                        <div class="form-group ">
                                            <input id="txtFechaFin" type="datetime-local" class="form-control">
                                        </div>
                                    </div>
                                    <div>
                                        <div class=form-group>
                                            <label>Color Prenda Superior*</label>
                                            <select id="txtcolorsup" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <div class=form-group>
                                            <label>Color Prenda Inferior</label>
                                            <select id="txtcolorinf" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label>Edad</label>
                                        <div class=form-group>
                                            <select id="txtedad" class="form-control">
                                                <option value="all" selected>Seleccione Rango</option>
                                                <option value=0>0-2 años</option>
                                                <option value=1>3-6 años</option>
                                                <option value=2>7-13 años</option>
                                                <option value=3>14-22 años</option>
                                                <option value=4>23-35 años</option>
                                                <option value=5>36-46 años</option>
                                                <option value=6>47-56 años</option>
                                                <option value=7>57-100 años</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label>Sexo</label>
                                        <div class=form-group>
                                            <select id="txtsexo" class="form-control">
                                                <option value="all" selected>Seleccione sexo</option>
                                                <option value=0>Mujer</option>
                                                <option value=1>Hombre</option>
                                            </select>
                                        </div>
                                    </div>
                                    <!--
                                    <div style="grid-column: 1 / span 2;">
                                        <label>Zonas/Subzonas</label>
                                        <div class="form-group">
                                            <button type="button" class="btn btn-default" id="btnSeleccionarZonas"
                                                    style="width: 100%; text-align: left; background: var(--panel); border: 1px solid var(--teal); color: var(--ink); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                                Seleccionar Zonas/Subzonas
                                            </button>
                                            <div id="zonas-seleccionadas" style="margin-top: 5px; font-size: 12px; color: var(--ink);">
                                                No hay zonas seleccionadas
                                            </div>
                                        </div>
                                    </div>
                                    -->
                                </div>
                                <button type="button" class="btn btn-accent" id="search-caracteristicas-btn" style="width: 100%;">Buscar por Características</button>
                                <div id="caracteristicas-results" style="margin-top: 15px;"></div>
                            </div>

                            <!-- Contenedor para resultados de listas (personas/vehículos) -->
                            <div id="search-results"></div>

                            <!-- NUEVO: Contenedor de personas seleccionadas en la parte inferior -->

                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
          <h3 id="title-panel">Alertas en tiempo real (Últimas 4 horas)</h3>
            <div style="margin-bottom: 1em;">
                <button id="btnBackToAll" class="btn btn-accent" style="width: 100%; display: none;">Volver a todas las alertas</button>
            </div>
            <div id="data-spinner" style="text-align:center;margin:2em; display:none">
                <div class="spinner"></div>
                <div>Cargando...</div>
            </div>
          <ul class="timeline" id="timelineList">
            <div>
            </div>
          </ul>
        </div>

      <div class="panel" style="overflow-y:hidden; position:relative">
            <canvas id="boardCanvas" width="900" height="600"  style="border:1px solid #333; width:100%; height:95vh; cursor: grab;"></canvas>
            <!-- CORREGIDO: Contenedor para frames en vivo - POSICIONAMIENTO ABSOLUTO DENTRO DEL PANEL -->
            <div id="live-alerts-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></div>
            <div style="display:flex; gap:1em; margin-bottom:1em;position: absolute;top: 1.5em;right: 1.5em;">
              <button id="btnConfig" class="btn btn-link" style="padding: 6px; color: var(--teal);" title="Configuración de visualización">
                ⚙️
              </button>
              <select id="selectPiso" class="form-select">
                <option value="ALL">UTEC Torre</option>
              </select>
              <button id="btnAutoRotate" class="btn btn-accent mb-2">Rotación automática: ON</button>
              <div class="selected-persons-map-panel" id="selected-persons-map-panel">
                <div class="selected-persons-map-body" id="selected-persons-map-body">
                    <div class="selection-placeholder">No hay personas seleccionadas</div>
                </div>
              </div>
            </div>
            <div class="top-left-segment">
                <div class="map-filters" id="map-filters">
                  <h4>Mostrar en mapa</h4>

                  <div class="filter-group">
                    <div class="filter-item">
                      <input type="checkbox" id="show-all">
                      <label for="show-all">Activar Todos</label>
                    </div>
                    <div class="filter-item">
                      <input type="checkbox" id="show-cameras" class="filter-child">
                      <label for="show-cameras">Todas las cámaras</label>
                    </div>
                    <div class="filter-item">
                      <input type="checkbox" id="show-pisos" class="filter-child" checked>
                      <label for="show-pisos">Pisos</label>
                    </div>
                    <div class="filter-item">
                      <input type="checkbox" id="show-ambientes" class="filter-child" checked>
                      <label for="show-ambientes">Ambientes</label>
                    </div>
                    <div class="filter-item">
                      <input type="checkbox" id="show-subzones-text" class="filter-child">
                      <label for="show-subzones-text">Titulos de ambientes</label>
                    </div>
                    <div class="filter-item" id="label-routes">
                      <input type="checkbox" id="show-routes" class="filter-child" checked>
                      <label for="show-routes">Rutas</label>
                    </div>
                    <div class="filter-item">
                      <input type="checkbox" id="show-people" class="filter-child">
                      <label for="show-people">Personas por ambiente</label>
                    </div>
                  </div>
                </div>
                <div class="camera-status-legend" id="camera-status-legend">
                  <h4>Estado de Cámaras</h4>
                  <div class="status-item">
                    <span class="status-dot alertCamera"></span>
                    <span class="status-label">Alertas en los últimos 5 min.</span>
                    <span class="status-count" id="alert-cameras-count">0</span>
                  </div>
                  <div class="status-item">
                    <span class="status-dot alertCamera15"></span>
                    <span class="status-label">Alertas en los últimos 15 min.</span>
                    <span class="status-count" id="alert-cameras-count-15">0</span>
                  </div>
                  <div class="status-item">
                    <span class="status-dot normal"></span>
                    <span class="status-label">Cámaras registradas</span>
                    <span class="status-count" id="normal-cameras-count">0</span>
                  </div>
                </div>
                <div class="person-count-legend" id="person-count-legend">
                  <h4>Personas por Piso</h4>
                  <div id="person-count-list">
                    <div class="person-count-item">
                      <span class="person-count-label">Cargando...</span>
                      <span class="person-count-value">0</span>
                    </div>
                  </div>
                  <div class="total-count" id="total-person-count">
                    Total: 0 personas
                  </div>
                </div>
            </div>
            <div class="map-legend" id="map-legend">
              <div class="legend-header">
                <div class="legend-title">Filtrar alertas</div>
                <button class="legend-toggle">−</button>
              </div>
              <div class="legend-body">
                <div class="loading">Cargando leyenda...</div>
              </div>
            </div>
            <div class="alert-details-panel" id="alert-details">
                <div class="alert-details-header">
                    <h4 class="alert-details-title" id="alert-details-title">Detalles de Alerta</h4>
                    <button class="close-details">&times;</button>
                </div>
                <div class="alert-details-content" id="alert-details-content"></div>
            </div>
      </div>


    </div>
  </div>

  <div class="overlay" id="ovl" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="hdr">
        <h4 id="mtitle">Detalle de alerta</h4>
        <span class="x" id="mclose">&times;</span>
      </div>
      <div id="mbody">...</div>
    </div>
  </div>

  <!-- Modal para mostrar videos (similar al 2D) -->
    <div class="overlay" id="videoOvl" aria-hidden="true" style="display: none;">
      <div class="modal-video" role="dialog" aria-modal="true">
        <div class="modal-content">
          <div class="modal-header text-left" style="display: flex;justify-content: space-between;">
              <div style="width:100%">
                <span class="c-white" style="float:right" id="showtime"></span>
                <h3>Identificador: <span class="c-white" id="showId"></span></h3>
                <h5>Tipo: <span class="c-white" id="showAlert"></span></h5>
                <h5>Cámara: <span class="c-white" id="showcamera"></span></h5>
                <h5>Ubicación: <span class="c-white" id="showUbication"></span></h5>
                <div id="showlocation"></div>
              </div>
            <div id="photo-short">
                  <div class="image-section" style="overflow:hidden;">
                    <div class="image-label">Detección Recortada</div>
                    <div class="image-container" id="cropped-detection"></div>
                  </div>
                  <div class="image-section" id="photo-name" >
                    <div class="image-label">Foto de Referencia</div>
                    <div class="image-container" id="person-photo"></div>
                  </div>
              </div>
          </div>

          <div class="modal-body">
            <div class="video-player-wrapper" style="height:400px;"></div>
            <div class="person-info-panel" id="person-info-panel" style="display: none;">
              <h4>Detección</h4>
              <div id="person-data" style=""></div>
            </div>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-default btn-rounded" id="closeVideoModal">Cerrar</button>
          </div>
        </div>
      </div>
    </div>

    <div class="overlay" id="interesOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="interesModalTitle">Búsqueda Avanzada - Personas de Interés</h4>
                </div>
                <div class="modal-body">
                    <!-- Contenido directo sin pestañas -->
                    <div id="interesModalContent">
                        <div class="loading">Cargando personas de interés...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="closeInteresModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Nuevo modal para selección múltiple -->
    <div class="overlay" id="multiSelectOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="multiSelectModalTitle">Selección de Interés</h4>
                </div>
                <div class="modal-body">
                    <div id="multiSelectModalContent" style="width:100%">
                        <div class="loading">Cargando personas de interés...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="saveMultiSelection">Guardar Selección</button>
                    <button type="button" class="btn btn-default btn-rounded" id="closeMultiSelectModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NUEVO: Modal para selección de zonas/subzonas - CORREGIDO -->
    <div class="overlay" id="zonasModal" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h4>Seleccionar Zonas/Subzonas</h4>
                </div>
                <div class="modal-body">
                    <div style="width:100%">
                        <!-- AÑADIR BOTÓN DE SELECCIONAR TODAS -->
                        <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                            <input type="text" id="filterZonas" placeholder="Buscar zonas..."
                                   style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
                            <button type="button" class="btn btn-default" id="btnSelectAllZonas"
                                    style="padding: 8px 12px; white-space: nowrap;">
                                Seleccionar Todas
                            </button>
                        </div>
                        <div id="lista-zonas" style="max-height: 350px; overflow-y: auto;">
                            <div class="loading">Cargando zonas...</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer" style="border-top: 1px solid rgba(181,214,223,0.2); padding: 16px; text-align: right;">
                    <button type="button" class="btn btn-default btn-rounded" id="btnAplicarZonas">Aplicar</button>
                    <button type="button" class="btn btn-default btn-rounded" id="btnLimpiarZonas" style="background: var(--orange);">Limpiar</button>
                    <button type="button" class="btn btn-default btn-rounded" id="btnCerrarZonas">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MODIFICADO: Modal para configuración de paneles -->
    <div class="overlay" id="configOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h4>Configuración de Paneles</h4>
                </div>
                <div class="modal-body" style="display: block !important;">
                    <div class="config-options">
                        <h5>Mostrar/Ocultar Paneles:</h5>
                        <div class="config-option-group">
                            <div class="config-option-item">
                                <input type="checkbox" id="config-show-map-filters" class="config-checkbox" checked>
                                <label for="config-show-map-filters">Mostrar en Mapa
                                    <br>
                                    <small>Es el panel encargado de poder filtrar lo renderizado en el mapa</small>
                                </label>
                            </div>
                            <div class="config-option-item">
                                <input type="checkbox" id="config-show-camera-status" class="config-checkbox" checked>
                                <label for="config-show-camera-status">Estado de Cámaras
                                    <br>
                                    <small>Es el panel encargado de mostrar la cantidad de cámaras y aquellas con alertas registradas</small>
                                </label>
                            </div>
                            <div class="config-option-item">
                                <input type="checkbox" id="config-show-map-legend" class="config-checkbox" checked>
                                <label for="config-show-map-legend">Filtrar alertas
                                    <br>
                                    <small>Es el panel encargado de mostrar el los tipos de alertas encontrados</small>
                                </label>
                            </div>
                            <div class="config-option-item">
                                <input type="checkbox" id="config-show-selected-persons" class="config-checkbox" checked>
                                <label for="config-show-selected-persons">Lista de interes
                                    <br>
                                    <small>Es el panel encargado de mostrar la lista de interes seleccionada</small>
                                </label>
                            </div>
                            <div class="config-option-item">
                                <input type="checkbox" id="config-show-live-alerts" class="config-checkbox">
                                <label for="config-show-live-alerts">Mostrar alertas en vivo
                                    <br>
                                    <small>Muestra frames en vivo de las cámaras con alertas activas</small>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="closeConfigModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

</div>


<script>

// ==========================''
// Variables para controlar visibilidad de paneles - NUEVO
// ==========================
let showMapFilters = true;
let showCameraStatus = true;
let showMapLegend = true;
let showSelectedPersonsPanel = true;
let showLiveAlerts = false;

let imageUpdateInterval = null;
const IMAGE_UPDATE_INTERVAL_MS = 1000; // Actualizar imágenes cada segundo

// ==========================
// Función para obtener y cachear el frame en vivo de una cámara - MODIFICADA
// ==========================
const cameraImageCache = new Map(); // Cache para almacenar imágenes de cámaras
const personPhotoCache = new Map(); // Cache para almacenar imágenes de cámaras
let processedAlertIds = new Set();

// ==========================
// Variables para alertas en vivo - NUEVO
// ==========================
let liveAlertFrames = [];
let liveAlertUpdateInterval = null;

let showPeople = false;
let personasEnAmbientes = [];

let tempSelectedItems = [];
const hoy = new Date();
const ayer = new Date(hoy);
ayer.setDate(hoy.getDate() - 1);
const formatear = d => {
    const limaDate = new Date(d);
    limaDate.setHours(limaDate.getUTCHours() - 5);
    return limaDate.toISOString().split('T')[0];
};

/* ===== Ventana 6h por defecto ===== */
(function initDateTimeWindow(){
  const now = new Date();
  const start = new Date(now.getTime() - 6*60*60*1000);
  const pad = n => String(n).padStart(2,'0');
  const toLocalDT = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  $('#txtFechaIni').val(toLocalDT(start));
  $('#txtFechaFin').val(toLocalDT(now));
})();

// --- Fullscreen flow
const enterBtn = document.querySelector('#civix-neo #enter');
//const exitBtn = document.querySelector('#civix-neo #exit');
const splash = document.getElementById('splash');
const dashboard = document.getElementById('dashboard');
//const controls = document.getElementById('controls');
const appRoot = document.getElementById('civix-neo');
let forceShowCamera = null;
let selectedInteresItem = null;

// Variable para almacenar el intervalo de actualización
let alertasInterval = null;
let frameInterval = null; // Intervalo para obtainLastFrame
let busqueda = null;
let showCameras = false;
let showPisos = true;
let showAmbientes = true;
let showSubzonesText = false; // NUEVO: Control para texto de subzonas
let showRoutes = true;
let currentTab = 'personas';

// ==========================
// Variables para tracking de offset del canvas
// ==========================
let canvasOffsetX = 0;
let canvasOffsetY = 0;
let canvasScaleX = 1;
let canvasScaleY = 1;

// ==========================
// Variables para controlar el estado de búsqueda
// ==========================
let currentSearchType = null; // 'placa', 'caracteristicas', 'interes', null
let currentSearchResults = null;

// ==========================
// Variables para KPI estático
// ==========================
let initialAlerts = []; // Almacena las alertas iniciales (sin filtros)
let lastKPUpdate = null; // Timestamp de última actualización de KPIs
let kpiTrendData = []; // Datos para el gráfico de tendencia

enterBtn.addEventListener('click', async () => {
    /* ===== Ventana 6h por defecto ===== */
    (function initDateTimeWindow(){
      const now = new Date();
      const start = new Date(now.getTime() - 6*60*60*1000);
      const pad = n => String(n).padStart(2,'0');
      const toLocalDT = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      $('#txtFechaIni').val(toLocalDT(start));
      $('#txtFechaFin').val(toLocalDT(now));
    })();
    try {
        if (!document.fullscreenElement) await appRoot.requestFullscreen({navigationUI: 'hide'});
    } catch (_) {}
    splash.style.display = 'none';
    dashboard.style.display = 'block';

    // NUEVO: Limpiar el cache de imágenes al entrar
    cameraImageCache.clear();

    // ELIMINAR LAS TRANSFORMACIONES AUTOMÁTICAS QUE CAUSAN OFFSET
    // Mantener solo la inicialización básica sin cambios de vista
    offsetX = canvas.width/2;
    offsetY = canvas.height/2;
    zoom = configTablero.zoomInicial;
    yaw = 0 * Math.PI/180;
    pitch = configTablero.pitchInicial * Math.PI/180;

    // NUEVO: Actualizar transformaciones del canvas después de entrar en fullscreen
    setTimeout(() => {
        updateCanvasTransform();
        render();
    }, 100);

    // Cerrar el panel de detalles de alerta al ingresar al dashboard
    const alertDetails = document.getElementById('alert-details');
    if (alertDetails) {
        alertDetails.style.display = 'none';
    }

    // Resetear variables relacionadas con alertas seleccionadas
    highlightedCamera = null;
    forceShowCamera = null;
    selectedAlert = null;

    // Limpiar resaltado de alertas
    alertHighlightedCameras = {};

    // Forzar renderizado inicial
    render();
    
    if(showPeople){
        if (personasUpdateInterval) {
        clearInterval(personasUpdateInterval);
        }
        
        personasUpdateInterval = setInterval(obtenerPersonasEnAmbientes, 2000);
    }else if(personasUpdateInterval && !showPeople){
        clearInterval(personasUpdateInterval);
        personasUpdateInterval = null;
    }

    // Obtener alertas inmediatamente
    getAlertas(busqueda);
    intervaloClean = setInterval(() => {
            cleanNuevasAlertas();
        }, 10000);

    // Iniciar animación
    animate();

});

function cleanNuevasAlertas(){
    if(nuevasAlertas.length>0){
        let now = new Date();
        nuevasAlertas.forEach(item=>{
            let time = new Date(item.timeStamp);
            let formattedTime = time.toLocaleString('es-PE');

            // CALCULAR OPACIDAD BASADA EN EL TIEMPO TRANSCURRIDO
            let timeDiff = now - time; // Diferencia en milisegundos
            let secondsDiff = timeDiff / (1000*60); // Convertir a minutos

            if(secondsDiff>5){
                let index = nuevasAlertas.indexOf(item);
                if (index > -1) { // only splice array when item is found
                  nuevasAlertas.splice(index, 1); // 2nd parameter means remove one item only
                }
            }
        });
    }
}

let intervaloClean = null;

// ==========================
// Función MEJORADA para obtener posición del mouse considerando transformaciones
// ==========================
function getMousePosition(e) {
    const rect = canvas.getBoundingClientRect();

    // Calcular posición relativa al canvas
    const clientX = e.clientX || e.touches?.[0]?.clientX;
    const clientY = e.clientY || e.touches?.[0]?.clientY;

    if (!clientX || !clientY) return { x: 0, y: 0 };

    // Aplicar corrección de offset y escala
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);

    return { x, y };
}

// ==========================
// Función para el checkbox "Activar Todos" - NUEVO
// ==========================
function initShowAllCheckbox() {
  const showAllCheckbox = document.getElementById('show-all');
  const childCheckboxes = [
    'show-cameras',
    'show-pisos', 
    'show-ambientes',
    'show-subzones-text',
    'show-routes',
    'show-people' // NUEVO
];

  if (showAllCheckbox) {
    // Evento cuando se cambia el checkbox "Activar Todos"
    showAllCheckbox.addEventListener('change', function(e) {
      const isChecked = e.target.checked;

      // Marcar o desmarcar todos los checkboxes hijos
      childCheckboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox && isChecked) {
          checkbox.checked = isChecked;
        }
      });

      // Actualizar todas las variables globales
      if(isChecked){
        showCameras = isChecked;
        showPisos = isChecked;
        showAmbientes = isChecked;
        showSubzonesText = isChecked;
        showRoutes = isChecked;
      }

      render();
    });
  }

  // Para cada checkbox hijo, añadir evento para actualizar "Activar Todos"
  childCheckboxes.forEach(id => {
    const checkbox = document.getElementById(id);
    if (checkbox) {
      checkbox.addEventListener('change', function() {
        updateShowAllCheckboxState();
      });
    }
  });
}

// ==========================
// Función para actualizar el estado del checkbox "Activar Todos" - NUEVO
// ==========================
function updateShowAllCheckboxState() {
  const showAllCheckbox = document.getElementById('show-all');
  const childCheckboxes = [
    'show-cameras',
    'show-pisos', 
    'show-ambientes',
    'show-subzones-text',
    'show-routes',
    'show-people' // NUEVO
];


  if (showAllCheckbox) {
    // Verificar si todos los checkboxes hijos están marcados
    const allChecked = childCheckboxes.every(id => {
      const checkbox = document.getElementById(id);
      return checkbox ? checkbox.checked : false;
    });

    // Actualizar el estado del checkbox "Activar Todos"
    showAllCheckbox.checked = allChecked;
  }
}

/*
exitBtn.addEventListener('click', () => {
  if(document.fullscreenElement) document.exitFullscreen();
  hideDash();
});
*/
document.addEventListener('keydown', e => {
  if(e.key==='Escape' && document.fullscreenElement){ document.exitFullscreen(); hideDash(); }
});

document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
        toastr.options.container = document.body; // <-- Restablecer al body
        hideDash();
        stopAlertUpdates();
        // NUEVO: Detener actualización de imágenes
    } else {
        // Al entrar en fullscreen, vuelve al body para que el toastr
        // esté en el nivel más alto del DOM.
        toastr.options.container = document.body; // <-- Restablecer al body

        // El resto de tu lógica para reiniciar animaciones
        if (dashboard.style.display === 'block') {
            setTimeout(() => {
                updateCanvasTransform();
                render();
            }, 100);
            animate();
        }
        startAlertUpdates();
        // MODIFICADO: Iniciar actualización de imágenes solo si showLiveAlerts es true
    }
});


// NUEVO: Actualizar transformaciones cuando cambia el tamaño de la ventana
window.addEventListener('resize', () => {
    if (dashboard.style.display === 'block') {
        updateCanvasTransform();
        render();
    }
});

// ==========================
// Función para actualizar transformaciones del canvas
// ==========================
function updateCanvasTransform() {
    const rect = canvas.getBoundingClientRect();
    canvasOffsetX = rect.left;
    canvasOffsetY = rect.top;
    canvasScaleX = canvas.width / rect.width;
    canvasScaleY = canvas.height / rect.height;
}

// ==========================
function hideDash(){
    // Limpiar intervalo de obtainLastFrame
    if (frameInterval) {
        clearInterval(frameInterval);
        frameInterval = null;
    }
    
    // NUEVO: Detener movimiento de personas
    detenerMovimientoPersonas();
    personasEnAmbientes = [];

    if(intervaloClean) {
        clearInterval(intervaloClean)
        intervaloClean = null;
    }
    
    if(personasUpdateInterval) {
        clearInterval(personasUpdateInterval)
        personasUpdateInterval = null;
    }

    // NUEVO: Detener actualización periódica de imágenes

    // NUEVO: Limpiar el cache de imágenes de cámaras
    cameraImageCache.clear();

    // NUEVO: Resetear filtro de cámaras
    filtroCamara = '';
    const inputFiltro = document.getElementById('input-filtro-camara');
    if (inputFiltro) {
        inputFiltro.value = '';
    }

    // RESETEO DE BÚSQUEDAS ACTIVAS
    currentSearchType = null;
    currentSearchResults = null;

    // Ocultar formularios de búsqueda
    document.getElementById('placa-search-form').style.display = 'none';
    document.getElementById('caracteristicas-search-form').style.display = 'none';
    document.getElementById('search-results').innerHTML = '';
    document.getElementById('caracteristicas-results').innerHTML = '';

    // Limpiar inputs de búsqueda
    document.getElementById('placa-input').value = '';
    document.getElementById('txtFechaIni').value = '';
    document.getElementById('txtFechaFin').value = '';
    document.getElementById('txtsexo').value = 'all';
    document.getElementById('txtcolorsup').value = 'all';
    document.getElementById('txtcolorinf').value = 'all';
    document.getElementById('txtedad').value = 'all';

    // Resto del código existente...
    dashboard.style.display='none';
    splash.style.display='flex';

    closeModal();

    // Cerrar el panel de detalles de alerta al salir del dashboard
    const alertDetails = document.getElementById('alert-details');
    if (alertDetails) {
        alertDetails.style.display = 'none';
    }

    // Detener el intervalo de actualización
    if (alertasInterval) {
        clearInterval(alertasInterval);
        alertasInterval = null;
    }

    // Detener animación de ruta
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }

    currentRoute = null;
    routeAnimationProgress = 0;
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }

    // ==========================
    // RESETEO COMPLETO DEL ESTADO
    // ==========================

    alertas = [];
    filteredAlerts = null; // Resetear a null en lugar de array vacío
    currentFilter = 'all';
    lastAlertIds = new Set();
    filteredCamerasByInteres = null;
    busqueda = null;

    // LIMPIAR VARIABLES DE BÚSQUEDA - NUEVO
    currentSearchType = null;
    currentSearchResults = null;

    // LIMPIAR VARIABLES DE RUTA
    currentRoute = null;
    routeAnimationProgress = 0;

    // Resetear selecciones de interfaz
    highlightedCamera = null;
    forceShowCamera = null;
    selectedInteresItem = null; // <-- AÑADIDO: Resetear la persona de interés seleccionada
    selectedAlert = null;

    // Limpiar resaltado permanente de alertas
    alertHighlightedCameras = {};

  // Cerrar y resetear modal de interés si está abierto
  if (interesOvl.style.display !== 'none') {
    interesOvl.style.display = 'none';
    document.getElementById('interesModalContent').innerHTML = '<div class="loading">Cargando...</div>';
  }

  // Cerrar y resetear modal de video si está abierto
  if (videoOvl.style.display !== 'none') {
    closeVideoModal();
  }

  // RESET CRÍTICO: Limpiar el canvas y forzar re-renderizado
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  render();

  // AÑADIDO: Ocultar el panel de persona seleccionada y restaurar el botón de búsqueda avanzada
  document.getElementById('selectedPersonBox').style.display = 'none';
    document.getElementById('btnBackToAll').style.display = 'none';
    document.getElementById('selectedPersonDetails').innerHTML = 'Seleccione una persona o vehículo para continuar.';

  // AÑADIDO: Restaurar el título del timeline
  document.getElementById('title-panel').textContent = 'Alertas en tiempo real (Últimas 4 horas)';

  if (liveAlertUpdateInterval) {
        clearInterval(liveAlertUpdateInterval);
        liveAlertUpdateInterval = null;
    }
    clearLiveAlertFrames();
}

// --- Modal de la aplicación
const modal = document.querySelector("#civix-neo .modal");
const overlay = document.getElementById("ovl");
const mtitle = document.getElementById("mtitle");
const mbody = document.getElementById("mbody");
const mclose = document.getElementById("mclose");

function showModal(title, content) {
    mtitle.textContent = title;
    mbody.innerHTML = content;
    overlay.style.display = 'flex';
}

function closeModal() {
    overlay.style.display = 'none';
}

mclose.addEventListener('click', closeModal);
overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
        closeModal();
    }
});


// ==========================
// Configuración del tablero
// ==========================
const configTablero = {
  grid: true,
  gridSize: 20,
  colorFondo: "#061922",
  colorLineas: "#ff7a2f88",
  zoomInicial: 1.5,
  pitchInicial: -20
};

// ==========================
// Parámetros de cámara
// ==========================
const canvas = document.getElementById("boardCanvas");
const ctx = canvas.getContext("2d");

let yaw = 0 * Math.PI/180;
let pitch = configTablero.pitchInicial * Math.PI/180;
let zoom = configTablero.zoomInicial;
let offsetX = 0;
let offsetY = 0;

let autoRotate = true;
let rotateSpeed = 0.001;

let screenPolygons=[];
let pisoActivo="ALL";
let highlightedCamera = null; // Cámara seleccionada manualmente
let alertHighlightedCameras = {}; // Cámaras con alertas recientes
let alertHighlightTimers = {};

let camerasData = []; // Variable global para almacenar las cámaras
let filteredCamerasByInteres = null;
let currentRoute = null;
let routeAnimation = null;
let routeAnimationProgress = 0;

let filtroCamara = '';

// ==========================
// Funciones utilitarias
// ==========================
function rotateY([x,y,z], a){ const c=Math.cos(a),s=Math.sin(a); return [x*c+z*s,y,-x*s+z*c]; }
function rotateX([x,y,z], a){ const c=Math.cos(a),s=Math.sin(a); return [x,y*c-z*s,y*s+z*c]; }
function project([x,y,z]){
  // Aplicar rotaciones
  [x,y,z] = rotateY([x,y,z], yaw);
  [x,y,z] = rotateX([x,y,z], pitch);

  // Aplicar perspectiva
  const d = 600;
  const scale = (d * zoom) / (d + z);

  // Aplicar offset y centrado
  const projectedX = x * scale + offsetX;
  const projectedY = -y * scale + offsetY;

  return [projectedX, projectedY];
}

// ==========================
// Función inversa para obtener coordenadas del mundo desde coordenadas de pantalla - NUEVA
// ==========================
function unproject(screenX, screenY, targetZ = 0) {
  // Convertir coordenadas de pantalla a coordenadas normalizadas del mundo
  const normalizedX = (screenX - offsetX) / zoom;
  const normalizedY = -(screenY - offsetY) / zoom;

  // Aplicar rotaciones inversas (simplificado para targetZ = 0)
  // Para un sistema completo necesitaríamos las matrices inversas, pero para clics en el "piso" esto funciona
  const worldX = normalizedX * Math.cos(-yaw) - targetZ * Math.sin(-yaw);
  const worldZ = normalizedX * Math.sin(-yaw) + targetZ * Math.cos(-yaw);
  const worldY = normalizedY;

  return [worldX, worldY, worldZ];
}
function hexToRgba(hex, alpha=0.5){
  const bigint=parseInt(hex.replace("#",""),16);
  const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

// ==========================
// Función para transformar el JSON del edificio - COMPLETAMENTE MODIFICADA
// ==========================
function transformarNuevoEdificio(nuevoJSON) {
    const edificioTransformado = {
        pisos: []
    };

    // Verificar que hay datos
    if (!nuevoJSON || nuevoJSON.length === 0) {
        log("No hay datos de edificio en la respuesta");
        return obtenerEdificioEjemplo();
    }

    const area = nuevoJSON[0];

    if (!area.zonas || area.zonas.length === 0) {
        log("No hay zonas en el área");
        return obtenerEdificioEjemplo();
    }

    // Mapear zonas a pisos
    area.zonas.forEach((zona) => {
        // CORRECCIÓN: Calcular altura basada en el nombre del piso
        let altura = 0;
        const nombrePiso = zona.nombre_zona;

        // Asignar altura según el nombre del piso
        if (nombrePiso.includes('Sótano') || nombrePiso.includes('Sotano')) {
            if (nombrePiso.includes('1')) altura = -40;
            else if (nombrePiso.includes('2')) altura = -80;
            else if (nombrePiso.includes('3')) altura = -120;
            else altura = -40; // Por defecto
        } else if (nombrePiso.includes('Piso')) {
            if (nombrePiso.includes('1')) altura = 0;
            else if (nombrePiso.includes('2')) altura = 40;
            else if (nombrePiso.includes('3')) altura = 80;
            else if (nombrePiso.includes('4')) altura = 120;
            else if (nombrePiso.includes('5')) altura = 160;
            else altura = 0; // Por defecto
        }

        // CORRECCIÓN: Crear un objeto piso limpio sin referencias cíclicas
        const pisoTransformado = {
            nombre: nombrePiso,
            altura: altura,
            ambientes: []
        };

        // PRIMERO: Crear ambiente para la ZONA completa
        if (zona.poligono_zona) {
            let verticesZona;
            try {
                verticesZona = JSON.parse(zona.poligono_zona);
                // CORRECCIÓN: Validar que verticesZona sea un array válido
                if (!Array.isArray(verticesZona) || verticesZona.length === 0) {
                    throw new Error("Polígono de zona no es un array válido");
                }
            } catch (e) {
                log('Error al parsear polígono de zona:', zona.poligono_zona, e);
                verticesZona = calcularBoundingBoxDeSubzonas(zona.subzonas);
            }

            // CORRECCIÓN: Aplicar la altura correcta a todos los vértices
            const verticesZona3D = verticesZona.map(vertice => {
                if (Array.isArray(vertice) && vertice.length === 2) {
                    return [vertice[0], pisoTransformado.altura, vertice[1]];
                } else if (Array.isArray(vertice) && vertice.length === 3) {
                    // Si ya tiene 3 dimensiones, mantener X y Z pero corregir Y (altura)
                    return [vertice[0], pisoTransformado.altura, vertice[2]];
                }
                return vertice;
            });

            // CORRECCIÓN: Crear objeto ambiente sin referencia cíclica
            const ambienteZona = {
                nombre: `${zona.nombre_zona}`,
                color: '#aaaaaa',
                vertices: verticesZona3D,
                id_zona: zona.id_zona,
                tipo: 'zona'
            };

            pisoTransformado.ambientes.push(ambienteZona);
        }

        // SEGUNDO: Mapear subzonas a ambientes - CORREGIDO
        if (zona.subzonas && zona.subzonas.length > 0) {
            zona.subzonas.forEach(subzona => {
                let vertices;
                try {
                    vertices = JSON.parse(subzona.poligono_subzona);
                    // CORRECCIÓN: Validar que vertices sea un array válido
                    if (!Array.isArray(vertices) || vertices.length === 0) {
                        throw new Error("Polígono de subzona no es un array válido");
                    }
                } catch (e) {
                    log('Error al parsear polígono de subzona:', subzona.poligono_subzona, e);
                    vertices = [[-10, -10], [10, -10], [10, 10], [-10, 10]]; // Cuadrado por defecto
                }

                // CORRECCIÓN: Aplicar la misma altura del piso a las subzonas
                const vertices3D = vertices.map(vertice => {
                    if (Array.isArray(vertice) && vertice.length === 2) {
                        return [vertice[0], pisoTransformado.altura, vertice[1]];
                    } else if (Array.isArray(vertice) && vertice.length === 3) {
                        // Si ya tiene 3 dimensiones, mantener X y Z pero corregir Y (altura)
                        return [vertice[0], pisoTransformado.altura, vertice[2]];
                    }
                    return vertice;
                });

                // CORRECCIÓN: Crear objeto subzona sin referencia cíclica
                const ambienteSubzona = {
                    nombre: subzona.nombre_subzona || `Subzona ${subzona.id_subzona}`,
                    color: generarColorAleatorio(),
                    vertices: vertices3D,
                    id_subzona: subzona.id_subzona,
                    tipo: 'subzona',
                    piso: pisoTransformado.nombre // Añadir referencia al piso
                };

                pisoTransformado.ambientes.push(ambienteSubzona);

                // TERCERO: Mapear cuadrantes dentro de las subzonas - CORREGIDO
                if (subzona.cuadrantes && subzona.cuadrantes.length > 0) {
                    subzona.cuadrantes.forEach(cuadrante => {
                        if (cuadrante.puntos_cuadrante && cuadrante.puntos_cuadrante.length > 0) {
                            const puntosCuadrante = cuadrante.puntos_cuadrante.map(punto => {
                                // USAR LAS COORDENADAS REALES DEL CUADRANTE
                                const x = punto.x || punto.lat || 0;
                                const z = punto.y || punto.lon || 0;
                                return [x, pisoTransformado.altura, z];
                            });

                            // CREAR EL CUADRANTE CON SUS VÉRTICES REALES
                            const ambienteCuadrante = {
                                nombre: cuadrante.nombre_cuadrante || `Cuadrante ${cuadrante.id_cuadrante}`,
                                color: generarColorAleatorio(),
                                vertices: puntosCuadrante,
                                id_cuadrante: cuadrante.id_cuadrante,
                                id_subzona: subzona.id_subzona,
                                tipo: 'cuadrante',
                                piso: pisoTransformado.nombre
                            };

                            pisoTransformado.ambientes.push(ambienteCuadrante);

                            //log(`Cuadrante registrado: ${cuadrante.id_cuadrante} con ${puntosCuadrante.length} puntos`);
                        }
                    });
                }
            });
        }

        edificioTransformado.pisos.push(pisoTransformado);
        //log(`Piso registrado: ${pisoTransformado.nombre} (altura: ${pisoTransformado.altura}) con ${pisoTransformado.ambientes.length} ambientes`);
    });

    return edificioTransformado;
}

function obtenerEdificioEjemplo() {
    return {
        "pisos": [
            {
                "nombre": "Sótano 1",
                "altura": -40,
                "ambientes": [
                    {
                        "nombre": "Estacionamientos S1",
                        "color": "#aaaaaa",
                        "vertices": [[-100,-40,-60],[100,-40,-60],[100,-40,60],[-100,-40,60]]
                    }
                ]
            },
            {
                "nombre": "Piso 1",
                "altura": 0,
                "ambientes": [
                    {
                        "nombre": "Piso 1",
                        "color": "#b8b8b8",
                        "vertices": [[-100,0,-60],[100,0,-60],[100,0,60],[-100,0,60]]
                    }
                ]
            }
            // ... otros pisos básicos
        ]
    };
}

// ==========================
// Función para calcular el bounding box de las subzonas
// ==========================
function calcularBoundingBoxDeSubzonas(subzonas) {
    if (!subzonas || subzonas.length === 0) {
        return [[-10, -10], [10, -10], [10, 10], [-10, 10]];
    }

    let minX = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxZ = -Infinity;

    subzonas.forEach(subzona => {
        if (subzona.poligono_subzona) {
            try {
                const vertices = JSON.parse(subzona.poligono_subzona);
                if (Array.isArray(vertices)) {
                    vertices.forEach(vertice => {
                        const x = vertice[0] || 0;
                        const z = vertice[1] || 0;
                        minX = Math.min(minX, x);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxZ = Math.max(maxZ, z);
                    });
                }
            } catch (e) {
                log('Error al parsear subzona para bounding box:', e);
            }
        }
    });

    // Si no se encontraron coordenadas válidas, usar valores por defecto
    if (minX === Infinity) {
        return [[-10, -10], [10, -10], [10, 10], [-10, 10]];
    }

    // Agregar un margen
    const margin = 5;
    return [
        [minX - margin, minZ - margin],
        [maxX + margin, minZ - margin],
        [maxX + margin, maxZ + margin],
        [minX - margin, maxZ + margin]
    ];
}

function generarColorAleatorio() {
    const colores = [
        '#66aaff', '#99ccff', '#cc9966', '#ffcc66', '#ff9966',
        '#cc6699', '#993366', '#66ccff', '#ff5252', '#77dd77',
        '#aaaaaa', '#8888ff', '#ffcc00', '#cc0000', '#b8b8b8',
        '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4',
        '#8BC34A', '#FF5722', '#607D8B', '#795548', '#E91E63'
    ];
    return colores[Math.floor(Math.random() * colores.length)];
}

function actualizarSelectorPisos() {
    const selectPiso = document.getElementById('selectPiso');

    if (!selectPiso) {
        log("Selector de pisos no encontrado");
        return;
    }

    // Limpiar opciones existentes
    selectPiso.innerHTML = '';

    // Agregar opciones basadas en las áreas, agrupadas por id_area
    if (areasData && areasData.length > 0) {
        // Crear un mapa para agrupar por id_area
        const areasAgrupadas = new Map();

        areasData.forEach(area => {
            if (!areasAgrupadas.has(area.id_area)) {
                areasAgrupadas.set(area.id_area, area);
            }
        });

        // Crear opciones para cada área única
        areasAgrupadas.forEach((area, id_area) => {
            const option = document.createElement('option');
            option.value = area.id_area;
            option.textContent = area.nombre_area;
            selectPiso.appendChild(option);
        });
    } else {
        log("No hay áreas para mostrar en el selector");
        // Opcional: cargar los datos si no están disponibles
        loadEdificiosData();
    }

    // NUEVO: Añadir filtro de cámaras si no existe
    if (!document.getElementById('filtro-camaras-container')) {
        const filtroContainer = document.createElement('div');
        filtroContainer.id = 'filtro-camaras-container';

        filtroContainer.innerHTML = `
            <input type="text"
                   id="input-filtro-camara"
                   placeholder="Buscar cámara"
                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
        `;

        // Insertar después del selector de pisos
        selectPiso.parentNode.insertBefore(filtroContainer, selectPiso.nextSibling);

        // Añadir event listener para el filtro
        document.getElementById('input-filtro-camara').addEventListener('input', function(e) {
            filtroCamara = e.target.value;
            render();
        });
    }
}


// ==========================
// Dibujo del edificio y cámaras
// ==========================
function drawEdificio(){
    screenPolygons = [];

    // Verificar que el edificio esté cargado
    if (!edificio || !edificio.pisos || edificio.pisos.length === 0) {
        ctx.fillStyle = "var(--teal)";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Cargando edificio...", canvas.width/2, canvas.height/2);
        return;
    }

    // CORRECCIÓN CRÍTICA: Usar las alertas que realmente se están mostrando en el timeline
    const alertsToUse = currentSearchResults !== null ? currentSearchResults :
                       (filteredAlerts !== null ? filteredAlerts : alertas);

    // CORRECCIÓN: Calcular correctamente las cámaras con alertas basadas en lo que se muestra
    const camerasWithAlerts = new Set();
    const cameraAlertTimes = new Map(); // NUEVO: Almacenar tiempo de última alerta por cámara

    if (alertsToUse && alertsToUse.length > 0) {
        alertsToUse.forEach(alert => {
            if (alert.camera_name || alert.cameraname) {
                const cameraName = alert.camera_name || alert.cameraname;
                camerasWithAlerts.add(cameraName);

                // NUEVO: Guardar el tiempo más reciente de alerta para esta cámara
                const alertTime = new Date(alert.init_time_frame || alert.epoch_frame).getTime();
                const currentTime = new Date().getTime();
                const minutesAgo = (currentTime - alertTime) / (1000 * 60);

                if (!cameraAlertTimes.has(cameraName) || minutesAgo < cameraAlertTimes.get(cameraName)) {
                    cameraAlertTimes.set(cameraName, minutesAgo);
                }
            }
        });
    }

    // ==========================
    // BLOQUE 1: DIBUJAR PISOS/ZONAS (LÓGICA SEPARADA)
    // ==========================
    if (showPisos) {
        for (const piso of edificio.pisos){
            if(pisoActivo !== "ALL" && piso.nombre !== pisoActivo) continue;

            // SOLO DIBUJAR LAS ZONAS (fondo de piso)
            for (const amb of piso.ambientes){
                if (amb.tipo !== 'zona') continue;

                // VERIFICAR: Que la zona pertenezca a este piso
                if (amb.piso && amb.piso !== piso.nombre) {
                    log(`Zona ${amb.nombre} no pertenece al piso ${piso.nombre}`);
                    continue;
                }

                const poly2D = amb.vertices.map(v => project(v));

                // Polígono de ZONA (fondo más oscuro)
                ctx.beginPath();
                poly2D.forEach(([px,py],i) => {
                    if(i === 0) ctx.moveTo(px,py);
                    else ctx.lineTo(px,py);
                });
                ctx.closePath();

                ctx.fillStyle = hexToRgba(amb.color, 0.3);
                ctx.fill();
                ctx.strokeStyle = amb.color;
                ctx.lineWidth = 1;
                ctx.stroke();

                screenPolygons.push({amb, poly2D, piso});

                // Texto de las ZONAS (más grande y centrado)
                let cx=0, cy=0, cz=0;
                for(const v of amb.vertices){
                    cx += v[0];
                    cy += v[1];
                    cz += v[2];
                }
                cx /= amb.vertices.length;
                cy /= amb.vertices.length;
                cz /= amb.vertices.length;
                const [tx, ty] = project([cx, cy, cz]);

                const xs3D = amb.vertices.map(v => v[0]);
                const zs3D = amb.vertices.map(v => v[2]);
                const width3D = Math.max(...xs3D) - Math.min(...xs3D);
                const height3D = Math.max(...zs3D) - Math.min(...zs3D);
                const size3D = Math.min(width3D, height3D);

                const fontSize = Math.min(24, Math.max(12, size3D * zoom * 0.1));

                let alpha = (pisoActivo === "ALL" ? 0.5 : 0.8);
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(amb.nombre, tx, ty);
                ctx.restore();
            }
        }
    }

    // ==========================
    // BLOQUE 2: DIBUJAR AMBIENTES/SUBZONAS (LÓGICA SEPARADA)
    // ==========================
    if (showAmbientes) {
        for (const piso of edificio.pisos){
            if(pisoActivo !== "ALL" && piso.nombre !== pisoActivo) continue;

            // DIBUJAR SUBZONAS principales
            for (const amb of piso.ambientes){
                // SOLO dibujar subzonas, NO cuadrantes en este nivel
                if (amb.tipo !== 'subzona') continue;

                // VERIFICAR: Que la subzona pertenezca a este piso
                if (amb.piso && amb.piso !== piso.nombre) {
                    log(`Subzona ${amb.nombre} no pertenece al piso ${piso.nombre}`);
                    continue;
                }

                const poly2D = amb.vertices.map(v => project(v));

                // Polígono de SUBZONA (más visible)
                ctx.beginPath();
                poly2D.forEach(([px,py],i) => {
                    if(i === 0) ctx.moveTo(px,py);
                    else ctx.lineTo(px,py);
                });
                ctx.closePath();

                ctx.fillStyle = hexToRgba(amb.color, 0.6);
                ctx.fill();
                ctx.strokeStyle = amb.color;
                ctx.lineWidth = 1;
                ctx.stroke();

                screenPolygons.push({amb, poly2D, piso});

                // NUEVO: Texto para subzonas principales - CONTROLADO POR showSubzonesText
                if (showSubzonesText && showAmbientes) {
                    // Solo mostrar texto si tanto showSubzonesText como showAmbientes están activos
                    let cx=0, cy=0, cz=0;
                    for(const v of amb.vertices){
                        cx += v[0];
                        cy += v[1];
                        cz += v[2];
                    }
                    cx /= amb.vertices.length;
                    cy /= amb.vertices.length;
                    cz /= amb.vertices.length;
                    const [tx, ty] = project([cx, cy, cz]);

                    const xs3D = amb.vertices.map(v => v[0]);
                    const zs3D = amb.vertices.map(v => v[2]);
                    const width3D = Math.max(...xs3D) - Math.min(...xs3D);
                    const height3D = Math.max(...zs3D) - Math.min(...zs3D);
                    const size3D = Math.min(width3D, height3D);

                    const fontSize = Math.min(14, Math.max(8, size3D * zoom * 0.15));

                    let alpha = (pisoActivo === "ALL" ? 0.7 : 0.9);
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.font = `${fontSize}px Arial`;
                    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(amb.nombre, tx, ty);
                    ctx.restore();
                }
            }

            // DIBUJAR CUADRANTES
            for (const amb of piso.ambientes){
                if (amb.tipo !== 'cuadrante') continue;

                const poly2D = amb.vertices.map(v => project(v));

                // Polígono de CUADRANTE (muy transparente, solo borde)
                ctx.beginPath();
                poly2D.forEach(([px,py],i) => {
                    if(i === 0) ctx.moveTo(px,py);
                    else ctx.lineTo(px,py);
                });
                ctx.closePath();

                // Cuadrantes muy sutiles, solo para referencia
                ctx.fillStyle = hexToRgba(amb.color, 0.05);
                ctx.fill();
                ctx.strokeStyle = hexToRgba(amb.color, 0.3);
                ctx.lineWidth = 0.5;
                ctx.stroke();

                screenPolygons.push({amb, poly2D, piso});
            }
        }
    }

    let camerasToShow = [];

    // CORRECCIÓN: PRIORIDAD 1 - Si hay una cámara forzada (selección manual)
    if (forceShowCamera) {
        camerasToShow = [forceShowCamera];
    }
    // CORRECCIÓN: PRIORIDAD 2 - Si hay un interés seleccionado
    else if (selectedInteresItem !== null && filteredCamerasByInteres !== null) {
        camerasToShow = [...filteredCamerasByInteres];
    }
    // CORRECCIÓN: PRIORIDAD 3 - Si hay resultados de búsqueda activa
    else if (currentSearchResults !== null) {
        // Mostrar cámaras de los resultados de búsqueda activa
        const searchCameraNames = [...new Set(currentSearchResults
            .filter(alert => alert.camera_name || alert.cameraname)
            .map(alert => alert.camera_name || alert.cameraname))];

        camerasToShow = camerasData.filter(cam =>
            searchCameraNames.includes(cam.camera_id)
        );
    }
    // CORRECCIÓN: PRIORIDAD 4 - Si hay un filtro activo (no es 'all')
    else if (currentFilter !== 'all') {
        const baseAlerts = filteredAlerts !== null ? filteredAlerts : alertas;
        const isAlertType = baseAlerts.some(alert => alert.type_event_name === currentFilter);

        if (isAlertType) {
            const cameraNamesInFilter = [...new Set(baseAlerts
                .filter(alert => alert.type_event_name === currentFilter)
                .map(alert => alert.camera_name))];
            camerasToShow = camerasData.filter(cam => cameraNamesInFilter.includes(cam.camera_id));
        } else {
            camerasToShow = camerasData.filter(cam => cam.camera_id === currentFilter);
        }
    }
    // CORRECCIÓN: PRIORIDAD 5 - Caso normal: mostrar cámaras con alertas + normales
    else {
        // Comportamiento original: mostrar cámaras con alertas + normales
        camerasWithAlerts.forEach(cameraName => {
          const cam = camerasData.find(c => c.camera_id === cameraName);
          if (cam) {
            camerasToShow.push(cam);
          }
        });

        // Añadir cámaras normales solo si showCameras es true
        if (showCameras) {
          camerasData.forEach(cam => {
            if (!camerasWithAlerts.has(cam.camera_id) &&
                !camerasToShow.some(existingCam => existingCam.camera_id === cam.camera_id)) {
              camerasToShow.push(cam);
            }
          });
        }

    }

    // CORRECCIÓN: Aplicar filtro de piso correctamente
    camerasToShow = camerasToShow.filter(cam => {
        if (pisoActivo === "ALL") return true;

        // Buscar la cámara en la estructura del edificio para verificar su piso
        for (const piso of edificio.pisos) {
            for (const ambiente of piso.ambientes) {
                if (ambiente.tipo === 'cuadrante' && ambiente.id_cuadrante &&
                    cam.id_cuadrante && ambiente.id_cuadrante.toString() === cam.id_cuadrante.toString()) {
                    return piso.nombre === pisoActivo;
                }
                if (ambiente.tipo === 'subzona' && ambiente.id_subzona &&
                    cam.id_cuadrante && ambiente.id_subzona.toString() === cam.id_cuadrante.toString()) {
                    return piso.nombre === pisoActivo;
                }
            }
        }

        // Fallback: usar la propiedad piso de la cámara
        return cam.piso && cam.piso.includes(pisoActivo);
    });

    // NUEVO: Aplicar filtro de búsqueda de cámara
    if (filtroCamara) {
        camerasToShow = camerasToShow.filter(cam =>
            cam.camera_id.toLowerCase().includes(filtroCamara.toLowerCase())
        );
    }

    // Contadores para la leyenda
    let alertCamerasCount5 = 0;
    let alertCamerasCount15 = 0;
    let normalCamerasCount = 0;
    normalCamerasCount = camerasData.length;

    // Obtener tiempo actual para efectos de animación
    const currentTime = new Date().getTime();

    // CORRECCIÓN: Dibujar cámaras con lógica mejorada
    clickableCameras = []; // Reiniciar array de cámaras clickeables

    camerasToShow.forEach(cam => {
        let cameraCoords = cam.coords;
    
        // SI LA CÁMARA NO TIENE COORDENADAS, BUSCAR EN EL CUADRANTE ASIGNADO
        if (!cameraCoords && cam.id_cuadrante) {
            for (const piso of edificio.pisos) {
                for (const ambiente of piso.ambientes) {
                    // Buscar por id_cuadrante
                    if (ambiente.tipo === 'cuadrante' && ambiente.id_cuadrante &&
                        ambiente.id_cuadrante.toString() === cam.id_cuadrante.toString()) {
    
                        // Calcular centro del cuadrante
                        const vertices = ambiente.vertices;
                        const xCoords = vertices.map(v => v[0]);
                        const zCoords = vertices.map(v => v[2]);
    
                        const centerX = (Math.min(...xCoords) + Math.max(...xCoords)) / 2;
                        const centerZ = (Math.min(...zCoords) + Math.max(...zCoords)) / 2;
                        const y = vertices[0][1]; // Altura del piso
    
                        cameraCoords = [centerX, y, centerZ];
                        cam.coords = cameraCoords; // Actualizar coordenadas de la cámara
                        break;
                    }
    
                    // Si no encuentra cuadrante, buscar por subzona
                    if (ambiente.tipo === 'subzona' && ambiente.id_subzona &&
                        ambiente.id_subzona.toString() === cam.id_cuadrante.toString()) {
    
                        // Calcular centro de la subzona
                        const vertices = ambiente.vertices;
                        const xCoords = vertices.map(v => v[0]);
                        const zCoords = vertices.map(v => v[2]);
    
                        const centerX = (Math.min(...xCoords) + Math.max(...xCoords)) / 2;
                        const centerZ = (Math.min(...zCoords) + Math.max(...zCoords)) / 2;
                        const y = vertices[0][1];
    
                        cameraCoords = [centerX, y, centerZ];
                        cam.coords = cameraCoords;
                        break;
                    }
                }
                if (cameraCoords) break;
            }
        }
    
        // Si aún no hay coordenadas, usar fallback
        if (!cameraCoords) {
            // Asignar posición por defecto basada en el piso
            const pisoObj = edificio.pisos.find(p => p.nombre === (cam.piso || pisoActivo));
            const altura = pisoObj ? pisoObj.altura : 0;
            cameraCoords = [Math.random() * 100 - 50, altura, Math.random() * 100 - 50];
            cam.coords = cameraCoords;
        }
    
        const [x, y, z] = cameraCoords;
        const [px, py] = project([x, y, z]);
    
        // Guardar posición proyectada para detección de clic
        cam.screenPos = { x: px, y: py };
    
        // CORRECCIÓN: Determinar correctamente si la cámara tiene alertas
        const hasAlerts = camerasWithAlerts.has(cam.camera_id);
        let isManuallyHighlighted = false;
    
        if(highlightedCamera){
            isManuallyHighlighted = cam.camera_id === highlightedCamera.camera_id;
        }
    
        // NUEVO: Determinar el tiempo de la última alerta
        let minutesSinceLastAlert = null;
        if (hasAlerts && cameraAlertTimes.has(cam.camera_id)) {
            minutesSinceLastAlert = cameraAlertTimes.get(cam.camera_id);
        }
    
        // NUEVA LÓGICA: Si hay búsqueda activa, todas las cámaras en resultados muestran pulso dorado
        
        const isInSearchResults = busqueda !== null;
        
        if (hasAlerts) {
            // Asumiendo que camera.lastAlertTime es el timestamp de la última alerta
            if (minutesSinceLastAlert <= 5) {
                // Alertas de hasta 5 minutos
                alertCamerasCount5++;
            } else if (minutesSinceLastAlert <= 15) {
                // Alertas de hasta 15 minutos
                alertCamerasCount15++; // Contador adicional para alertas muy recientes
            }
            // Las alertas más antiguas de 15 minutos no se cuentan
        }
    
        if (isManuallyHighlighted) {
          // Estilo resaltado manual (selección de usuario) - DORADO FIJO
          ctx.beginPath();
          ctx.arc(px, py, 10, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
          ctx.fill();
    
          const pulseStrong = Math.sin(currentTime / 100) * 0.5 + 0.5;
    
          // ANILLO EXTERIOR CIRCULAR - CORREGIDO
          ctx.beginPath();
          ctx.arc(px, py, 16 + pulseStrong * 8, 0, 2 * Math.PI);
          ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + pulseStrong * 0.4})`;
          ctx.lineWidth = 3;
          ctx.stroke();
    
          // Añadir etiqueta con nombre de cámara
          ctx.fillStyle = 'white';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(cam.camera_id, px, py - 25);
        }
        // NUEVA CONDICIÓN: Si está en resultados de búsqueda, mostrar con pulso dorado
        else if (isInSearchResults) {
          // PULSO DORADO para cámaras en resultados de búsqueda (sin importar el tiempo)
          const pulse = Math.sin(currentTime / 200) * 0.5 + 0.5;
    
          // Círculo interior con pulso
          ctx.beginPath();
          ctx.arc(px, py, 6 + pulse * 3, 0, 2 * Math.PI);
          ctx.fillStyle = `rgba(255, 215, 0, ${0.8 + pulse * 0.2})`;
          ctx.fill();
    
          // Anillo exterior con pulso
          ctx.beginPath();
          ctx.arc(px, py, 10 + pulse * 8, 0, 2 * Math.PI);
          ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + pulse * 0.3})`;
          ctx.lineWidth = 3;
          ctx.stroke();
    
          // Añadir etiqueta con nombre de cámara
          if (zoom > 1.2) {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(cam.camera_id, px, py - 25);
            ctx.restore();
          }
        }
        else if (hasAlerts && minutesSinceLastAlert !== null) {
          // NUEVO: Lógica de pulsos basada en el tiempo de la alerta
          const pulse = Math.sin(currentTime / 200) * 0.5 + 0.5;
    
          if (minutesSinceLastAlert <= 5) {
            // PULSO ROJO para alertas dentro de 5 minutos
            // Círculo interior con pulso
            ctx.beginPath();
            ctx.arc(px, py, 6 + pulse * 3, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(255, 0, 0, ${0.8 + pulse * 0.2})`;
            ctx.fill();
    
            // Anillo exterior con pulso
            ctx.beginPath();
            ctx.arc(px, py, 10 + pulse * 8, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(255, 0, 0, ${0.4 + pulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
    
          } else if (minutesSinceLastAlert <= 15) {
            // PULSO DORADO para alertas dentro de 15 minutos
            // Círculo interior con pulso
            ctx.beginPath();
            ctx.arc(px, py, 6 + pulse * 3, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(255, 215, 0, ${0.8 + pulse * 0.2})`;
            ctx.fill();
    
            // Anillo exterior con pulso
            ctx.beginPath();
            ctx.arc(px, py, 10 + pulse * 8, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + pulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
          } else {
            // Alertas mayores a 15 minutos - sin pulso, solo si showCameras es true
            if (showCameras) {
              ctx.beginPath();
              ctx.arc(px, py, 5, 0, 2 * Math.PI);
              ctx.fillStyle = '#22e6d9';
              ctx.fill();
              ctx.strokeStyle = '#22e6d9';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          }
    
          // Añadir etiqueta con nombre de cámara para cámaras con alertas recientes
          if (zoom > 1.2 && minutesSinceLastAlert <= 15) {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(cam.camera_id, px, py - 25);
            ctx.restore();
          }
        }
        else {
          // Cámaras normales - ROJO sin pulso (solo si showCameras es true)
          if (showCameras) {
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#22e6d9';
            ctx.fill();
            ctx.strokeStyle = '#22e6d9';
            ctx.lineWidth = 2;
            ctx.stroke();
    
            // Añadir etiqueta con nombre de cámara (solo si está cerca)
            if (zoom > 1.5) {
              ctx.save();
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.fillStyle = 'white';
              ctx.font = '10px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(cam.camera_id, px, py - 15);
              ctx.restore();
            }
          }
        }
        clickableCameras.push({
            cam: cam,
            screenX: px,
            screenY: py,
            // Radio dinámico basado en el tipo de visualización
            radius: getCameraClickRadius(cam, hasAlerts, isManuallyHighlighted)
        });
    });

    // Actualizar contadores en la leyenda
    updateCameraLegendCounts(alertCamerasCount5, normalCamerasCount, alertCamerasCount15);
}

function getCameraClickRadius(cam, hasAlerts, isHighlighted) {
    if (isHighlighted) {
        return 25; // Cámaras resaltadas manualmente (dorado con pulso fuerte)
    } else if (hasAlerts) {
        return 22; // Cámaras con alertas (dorado con pulso)
    } else {
        return 18; // Cámaras normales (rojo)
    }
}


function obtainLastFrame(){
    if(highlightedCamera){
        callAPI({
            method: 'dashboards/lastframe',
            params: { camera_id: highlightedCamera.id||highlightedCamera.camera_id  },
            ok: function (vals) {
                updateDetailContent(vals);
            },
            error: function (error) {
                log("Error al obtener datos de la cámara: ", error);
            }
        });
    }
}

let areaSeleccionada = null;

function obtainEdificio(id_area) {
    callAPI({
        method: 'gestion/getbuilding',
        params: { id_area: id_area }, // Añadir parámetro id_area
        ok: function (vals) {
            // Transformar los datos del API a la estructura esperada
            edificio = transformarNuevoEdificio(vals);

            areaSeleccionada = id_area;

            // NORMALIZAR COORDENADAS - NUEVO
            edificio = normalizarCoordenadasEdificio(edificio);

            //log("Edificio normalizado:", edificio);

            // Ya no llamamos a actualizarSelectorPisos aquí
            // porque ahora se maneja por separado

            setTimeout(() => getCamaras(), 1000);
            //log("Edificio cargado, transformado y normalizado exitosamente");
        },
        error: function (error) {
            log("Error al obtener el edificio:", error);

            // En caso de error, usar datos de ejemplo
            edificio = obtenerEdificioEjemplo();

            log("Usando datos de ejemplo debido a error en la API");
        }
    });
}

function render() {
    // Limpiar el canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dibujar fondo
    ctx.fillStyle = configTablero.colorFondo;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dibujar edificio
    drawEdificio();

    drawGrid();

    // NUEVO: Dibujar personas
    if(showPeople){
        drawPeople();
    }

    // Dibujar conexiones de alertas en vivo con imágenes solo si showLiveAlerts es true
    if (showLiveAlerts) {
        drawLiveAlertConnections();
    }

    // ACTUALIZAR CÁMARAS CLICKEABLES EN CADA FRAME
    updateClickableCameras();

    // Dibujar rutas solo si showRoutes es true
    if (showRoutes) {
        drawRoute();
    }
}

function drawGrid(){
  if (!configTablero.grid) return;
  const size=configTablero.gridSize, half=200;
  ctx.strokeStyle=configTablero.colorLineas; ctx.lineWidth=1;

  // SOLO DIBUJAR LÍNEAS HORIZONTALES - ELIMINAR VERTICALES
  for(let z=-half;z<=half;z+=size){
    const p1=project([-half,0,z]), p2=project([half,0,z]);
    ctx.beginPath(); ctx.moveTo(...p1); ctx.lineTo(...p2); ctx.stroke();
  }

  // ELIMINADO: Líneas verticales que causan superposición
  for(let x=-half;x<=half;x+=size){
    const p1=project([x,0,-half]), p2=project([x,0,half]);
    ctx.beginPath(); ctx.moveTo(...p1); ctx.lineTo(...p2); ctx.stroke();
  }
}

// ==========================
// Detección de clic mejorada
// ==========================
function pointInPolygon(x, y, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i][0], yi = poly[i][1];
    const xj = poly[j][0], yj = poly[j][1];

    // Check if the point is exactly on a vertex
    if ((xi === x && yi === y) || (xj === x && yj === y)) return true;

    // Check if the point is on a horizontal edge
    if (yi === yj && yi === y && x > Math.min(xi, xj) && x < Math.max(xi, xj)) return true;

    // Check if the point is on a vertical edge
    if (xi === xj && xi === x && y > Math.min(yi, yj) && y < Math.max(yi, yj)) return true;

    // Check if the point is inside using the ray casting algorithm
    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// ==========================
// Sistema de detección de clics MEJORADO - NUEVO
// ==========================

let clickableCameras = [];

function updateClickableCameras() {
    clickableCameras = [];

    // SI HAY UNA CÁMARA SELECCIONADA, SOLO ESA DEBE SER CLICKEABLE
    if (highlightedCamera) {
        // Solo procesar la cámara seleccionada
        const cam = highlightedCamera;
        if (!cam.coords) return;

        const [x, y, z] = cam.coords;
        const [px, py] = project([x, y, z]);

        // Determinar el radio basado en el tipo de visualización
        const hasAlerts = false; // Cuando hay cámara seleccionada, no importan las alertas
        const isHighlighted = true; // Siempre está resaltada

        let radius = 25; // Radio mayor para cámara seleccionada

        // Ajustar radio basado en el zoom para mejor usabilidad
        radius = radius * (1 + (zoom - 1) * 0.3);

        clickableCameras.push({
            cam: cam,
            screenX: px,
            screenY: py,
            radius: radius,
            worldCoords: cam.coords
        });
        return; // Salir de la función, no procesar más cámaras
    }

    // CÓDIGO ORIGINAL (solo se ejecuta cuando NO hay cámara seleccionada)
    let camerasToShow = [];

    // CORRECCIÓN: Usar las alertas que realmente se están mostrando en el timeline
    const alertsToUse = currentSearchResults !== null ? currentSearchResults :
                       (filteredAlerts !== null ? filteredAlerts : alertas);

    // CORRECCIÓN: Calcular correctamente las cámaras con alertas basadas en lo que se muestra
    const camerasWithAlerts = new Set();
    if (alertsToUse && alertsToUse.length > 0) {
        alertsToUse.forEach(alert => {
            if (alert.camera_name || alert.cameraname) {
                camerasWithAlerts.add(alert.camera_name || alert.cameraname);
            }
        });
    }

    // Determinar cámaras a mostrar (lógica existente simplificada)
    if (forceShowCamera) {
        camerasToShow = [forceShowCamera];
    } else if (selectedInteresItem !== null && filteredCamerasByInteres !== null) {
        camerasToShow = [...filteredCamerasByInteres];
    } else if (currentSearchResults !== null) {
        const searchCameraNames = [...new Set(currentSearchResults
            .filter(alert => alert.camera_name || alert.cameraname)
            .map(alert => alert.camera_name || alert.cameraname))];

        camerasToShow = camerasData.filter(cam =>
            searchCameraNames.includes(cam.camera_id)
        );
    } else {
            // Comportamiento original
            camerasWithAlerts.forEach(cameraName => {
                const cam = camerasData.find(c => c.camera_id === cameraName);
                if (cam) {
                    camerasToShow.push(cam);
                }
            });

            // Añadir cámaras normales solo si showCameras es true
            if (showCameras) {
                camerasData.forEach(cam => {
                    if (!camerasWithAlerts.has(cam.camera_id) &&
                        !camerasToShow.some(existingCam => existingCam.camera_id === cam.camera_id)) {
                        camerasToShow.push(cam);
                    }
                });
            }

    }

    if (filtroCamara) {
        camerasToShow = camerasToShow.filter(cam =>
            cam.camera_id.toLowerCase().includes(filtroCamara.toLowerCase())
        );
    }

    // Proyectar cada cámara y guardar información clickeable
    camerasToShow.forEach(cam => {
        if (!cam.coords) return;

        const [x, y, z] = cam.coords;
        const [px, py] = project([x, y, z]);

        // Determinar el radio basado en el tipo de visualización
        const hasAlerts = camerasWithAlerts.has(cam.camera_id);
        const isHighlighted = false; // No hay cámara seleccionada manualmente

        let radius = 15; // Radio base
        if (isHighlighted) radius = 25;
        else if (hasAlerts) radius = 22;
        else radius = 18;

        // Ajustar radio basado en el zoom para mejor usabilidad
        radius = radius * (1 + (zoom - 1) * 0.3);

        clickableCameras.push({
            cam: cam,
            screenX: px,
            screenY: py,
            radius: radius,
            worldCoords: cam.coords
        });
    });
}

// ==========================
// Detección de clic MEJORADA - considera transformaciones actuales
// ==========================
function getCameraAtClick(mouseX, mouseY) {
    let closestCamera = null;
    let minDistance = Infinity;

    clickableCameras.forEach(cameraData => {
        const distance = Math.sqrt(
            Math.pow(mouseX - cameraData.screenX, 2) +
            Math.pow(mouseY - cameraData.screenY, 2)
        );

        if (distance < cameraData.radius && distance < minDistance) {
            minDistance = distance;
            closestCamera = cameraData;
        }
    });

    return closestCamera ? { camera: closestCamera.cam, distance: minDistance } : null;
}

// ==========================
// Event listener para clic en el canvas - SIMPLIFICADO (solo cámaras)
// ==========================
canvas.addEventListener("click", e => {
    if(busqueda || showLiveAlerts){
        return;
    }
    const {x: mx, y: my} = getMousePosition(e);

    //log(`Click en: (${mx.toFixed(1)}, ${my.toFixed(1)})`);

    // SI YA HAY UNA CÁMARA SELECCIONADA, VERIFICAR SI SE HIZO CLIC EN ELLA O NO
    if (highlightedCamera) {

        document.getElementById('title-panel').textContent = 'Alertas en tiempo real (Últimas 4 horas)';
        const cameraResult = getCameraAtClick(mx, my);

        // Si se hizo clic en la cámara seleccionada, no hacer nada (mantener selección)
        if (cameraResult && cameraResult.distance < 25 &&
            cameraResult.camera.camera_id === highlightedCamera.camera_id) {
            //log("Clic en cámara ya seleccionada - manteniendo selección");
            return;
        }

        // Si se hizo clic fuera de la cámara seleccionada, DESELECCIONAR
        //log("Clic fuera de cámara seleccionada - deseleccionando");
        highlightedCamera = null;

        isLastFrame = null;

        // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }

        selectedAlert = null;

        /*
        //Reactivar Rotación automática
        if (!autoRotate) {
            autoRotate = true;
            document.getElementById("btnAutoRotate").textContent = "Rotación automática: ON";
        }
        */

        if(currentFilter != null || currentFilter != 'all'){
            currentFilter = 'all';
            applyFilter();
        }

        closeDetailsAlert();
        render();
        return;
    }

    // BUSCAR CÁMARAS CLICKEADAS (solo cuando no hay cámara seleccionada)
    const cameraResult = getCameraAtClick(mx, my);

    if (cameraResult && cameraResult.distance < 25) {

        // RESALTAR LA CÁMARA SELECCIONADA
        highlightedCamera = cameraResult.camera;

        document.getElementById('title-panel').textContent = 'Alertas de la cámara '+highlightedCamera.camera_id;

        currentFilter = highlightedCamera.camera_id;

        applyFilter();

        isLastFrame = true;
        // Pausar rotación automática temporalmente
        const wasAutoRotating = autoRotate;
        if (autoRotate) {
            autoRotate = false;
            document.getElementById("btnAutoRotate").textContent = "Rotación automática: OFF";
        }

        showAlertFotoframe();

        obtainLastFrame();

        // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }

        frameInterval = setInterval(() => {
            obtainLastFrame();
        }, 1000);

        render();
        return;
    }

    // Si no se clickeó ninguna cámara y no hay cámara seleccionada, limpiar resaltados
    highlightedCamera = null;

    isLastFrame = null;

    // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
    if (frameInterval) {
        clearInterval(frameInterval);
        frameInterval = null;
    }

    selectedAlert = null;

    if(currentFilter != null || currentFilter != 'all'){
        currentFilter = 'all';
        applyFilter();
    }

    document.getElementById('btnBackToAll').style.display = 'none';

    closeDetailsAlert();

    /*
    //Reactivar Rotación automática
    if (!autoRotate) {
        autoRotate = true;
        document.getElementById("btnAutoRotate").textContent = "Rotación automática: ON";
    }
    */

    //log("No se clickeó ninguna cámara");
    render();
});

// ==========================
// Event listeners para hover - NUEVO
// ==========================
canvas.addEventListener("mousemove", e => {
    if (dragging) return;

    const {x: mx, y: my} = getMousePosition(e);

    // Buscar cámaras bajo el cursor
    let cameraUnderCursor = false;

    clickableCameras.forEach(({screenX, screenY, radius}) => {
        const dist = Math.hypot(mx - screenX, my - screenY);

        if (dist < radius) {
            cameraUnderCursor = true;
            canvas.style.cursor = 'pointer';
            return;
        }
    });

    if (!cameraUnderCursor) {
        canvas.style.cursor = dragMode === "pan" ? "move" : "grab";
    }
});

// Restaurar cursor al salir del canvas
canvas.addEventListener("mouseleave", () => {
    canvas.style.cursor = "grab";
});

// ==========================
// Animación automática
// ==========================
function animate(){
  if(autoRotate){
    yaw += rotateSpeed;
  }

  if (dashboard.style.display !== 'none') {
    render();
    requestAnimationFrame(animate);
  }
}

// ==========================
// Interacción mouse
// ==========================
let dragging=false,lastX=0,lastY=0;
let dragMode=null;

canvas.addEventListener("mousedown", e=>{
    dragging=true;
    const {x: mx, y: my} = getMousePosition(e);
    lastX = mx;
    lastY = my;
    dragMode=(e.button===2?"pan":"rotate");
    canvas.style.cursor=(dragMode==="pan"?"move":"grabbing");
});

["mouseup","mouseleave"].forEach(ev=>canvas.addEventListener(ev,()=>{
    dragging=false; dragMode=null; canvas.style.cursor="grab";
}));

let panSensitivity = 0.3; // Valor por defecto (ajustable)

function setPanSensitivity(sensitivity) {
    panSensitivity = Math.max(0.1, Math.min(1.0, sensitivity)); // Limitar entre 0.1 y 1.0
}

// En el event listener de mousemove para drag, usar la variable:
canvas.addEventListener("mousemove", e=>{
    if(!dragging) return;
    const {x: mx, y: my} = getMousePosition(e);
    const dx = mx - lastX, dy = my - lastY;

    if(dragMode==="pan"){
        // USAR LA VARIABLE DE SENSIBILIDAD
        offsetX += dx * panSensitivity;
        offsetY += dy * panSensitivity;
    }
    else if(dragMode==="rotate"){
        yaw -= dx * 0.01;
        pitch -= dy * 0.01;
        const limit=Math.PI/2-0.1;
        if(pitch>limit) pitch=limit;
        if(pitch<-limit) pitch=-limit;
    }
    lastX = mx;
    lastY = my;
    render();
});

// Función para probar diferentes sensibilidades desde la consola
window.adjustPanSensitivity = function(sensitivity) {
    setPanSensitivity(sensitivity);
};

canvas.addEventListener("contextmenu", e=>e.preventDefault());

// ==========================
// Zoom
// ==========================
canvas.addEventListener("wheel", e=>{
    e.preventDefault();
    const prev=zoom;
    zoom*=(e.deltaY>0?0.9:1.1);
    zoom=Math.max(0.25,Math.min(5.0,zoom));

    const {x: mx, y: my} = getMousePosition(e);
    offsetX=mx-(mx-offsetX)*(zoom/prev);
    offsetY=my-(my-offsetY)*(zoom/prev);
    render();
},{passive:false});

// ==========================
// Botones y filtros
// ==========================
/*
document.getElementById("btnFullscreen").addEventListener("click",()=>{
  if(!document.fullscreenElement) canvas.requestFullscreen(); else document.exitFullscreen();
});
*/
document.getElementById("btnAutoRotate").addEventListener("click",()=>{
  autoRotate=!autoRotate;
  document.getElementById("btnAutoRotate").textContent="Rotación automática: "+(autoRotate?"ON":"OFF");
});

// Reemplazar el event listener existente del selectPiso
document.getElementById("selectPiso").addEventListener("change", e => {
    const id_area = e.target.value;

    // Cargar el edificio correspondiente al área seleccionada
    obtainEdificio(id_area);

    // Resetear la vista del mapa
    pisoActivo = "ALL"; // Mostrar todos los pisos del edificio
    zoom = configTablero.zoomInicial;
    offsetX = canvas.width/2;
    offsetY = canvas.height/2;

    render();
});

// Variable global para almacenar las alertas
let alertas = [];

// Función para renderizar la lista de alertas
function renderTimelineList(data) {
    const timelineList = document.getElementById('timelineList');
    if (!data || data.length === 0) {
        timelineList.innerHTML = '<div class="loading">No hay alertas disponibles</div>';
        return;
    }

    timelineList.innerHTML = '';

    // Ordenar por fecha más reciente primero
    const sortedData = [...data].sort((a, b) => new Date(b.init_time_frame) - new Date(a.init_time_frame));
    const now = new Date();

    sortedData.forEach(item => {
        const li = document.createElement('li');
        li.setAttribute('data-id', item.main_id||item.id);
        li.setAttribute('data-type', item.type_event_name?item.type_event_name.toLowerCase():"Detección");

        const time = new Date(item.init_time_frame||item.epoch_frame);
        const formattedTime = time.toLocaleString('es-PE');

        // CALCULAR TIEMPO TRANSCURRIDO Y CATEGORÍA
        const timeDiff = now - time;
        const minutesDiff = timeDiff / (1000 * 60);

        // Determinar categoría de tiempo
        let timeCategory = 'old'; // Más de 15 minutos
        if (minutesDiff <= 5) {
            timeCategory = 'recent';
        } else if (minutesDiff <= 15) {
            timeCategory = 'medium';
        }

        // Añadir clase de categoría de tiempo
        li.classList.add(`time-${timeCategory}`);

        // Opacidad (manteniendo tu lógica original)
        const opacity = Math.max(0.3, 1 - (Math.floor(minutesDiff / 10) * 0.15));
        li.style.opacity = opacity;

        li.innerHTML = `
            <strong>${(item.main_id||item.id) + " - " +(item.type_event_name?item.type_event_name:'Detección') || 'Alerta'}</strong>
            <strong>${formattedTime}</strong>
            ${item.camera_name||item.cameraname} · ${item.location || 'Ubicación no especificada'}
            <div id='data-frame-${item.main_id||item.id}'></div>
        `;

        li.addEventListener('click', () => {
            showExpandedData(item);
        });

        timelineList.appendChild(li);
    });

    if (selectedAlert) {
        let expandedAlert = null;
        if(selectedAlert.main_id){
            expandedAlert = sortedData.find(a => a.main_id == selectedAlert.main_id);
        }else{
            expandedAlert = sortedData.find(a => a.id == selectedAlert.id);
        }
        if (expandedAlert) {
            setTimeout(() => {
                showExpandedData(expandedAlert);
            }, 200);
        }
    }
}

function isValidParam(value) {
    return value !== null &&
           value !== undefined &&
           value.toString().trim() !== '' &&
           value.toString().toLowerCase() !== 'null' &&
           value.toString().toLowerCase() !== 'undefined';
}

function showExpandedData(alert) {

  const frameContainer = document.getElementById('data-frame-' + (alert.main_id||alert.id));
  const li = document.querySelector(`#timelineList li[data-id="${alert.main_id||alert.id}"]`);
  if (!frameContainer || !li) return;

  // ✅ Si ya está expandida → colapsar
  if (frameContainer.classList.contains('expanded')) {
    frameContainer.innerHTML = '';
    frameContainer.classList.remove('expanded');
    li.classList.remove('highlighted');

    // 🔹 Restaurar opacidad original
    if (li.dataset.originalOpacity) {
      li.style.opacity = li.dataset.originalOpacity;
    }

    expandedAlertId = null;
    selectedAlert = null;
    return;
  }

  if(selectedAlert && (selectedAlert.main_id||selectedAlert.id)!=(alert.main_id||alert.id)){
      let idToSearch = null;
      if(selectedAlert.main_id){
        idToSearch = selectedAlert.main_id;
      }else{
        idToSearch = selectedAlert.id;
      }
      let containerExpanded = document.getElementById('data-frame-' + idToSearch);
      let segment = document.querySelector(`#timelineList li[data-id="${selectedAlert.main_id||selectedAlert.id}"]`);
      if(containerExpanded && segment){
        containerExpanded.innerHTML = '';
        containerExpanded.classList.remove('expanded');
        segment.classList.remove('highlighted');
        segment.style.opacity = segment.dataset.originalOpacity;
      }
  }

    selectedAlert = alert;

  // 🔹 Expandir alerta actual e iluminarla
  frameContainer.classList.add('expanded');
  li.classList.add('highlighted');
  expandedAlertId = alert.main_id||alert.id;

  // 🔹 Guardar opacidad original y dejar opacidad completa al expandir
  if (!li.dataset.originalOpacity) {
    li.dataset.originalOpacity = li.style.opacity || 1;
  }
  li.style.opacity = 1;

  // 🔹 Render dinámico del contenido
  if (alert.coords_face || alert.person_coords_face || alert.coords_plate || alert.vehicle_coords_plate) {
    const personName = alert.nombre ? `${alert.nombre} ${alert.apellido}` : alert.vehicle_plate || alert.plate;
    const personTitle = alert.nombre ? "Persona Detectada" : "Vehículo Detectado";
    const subTitle = alert.nombre ? "Nombre:" : "Placa:";
    const regTime = new Date(alert.fecha_registro || alert.fecha_robo || alert.list_fecha_robo);
    const formattedRegTime = regTime.toLocaleString('es-PE');

    frameContainer.innerHTML = `
      <div class="">
        <h4 class="person-details-title">${personTitle}</h4>
        <div class="detail-item">${subTitle} ${personName}</div>
        ${alert.documento_contacto || alert.num_documento || alert.list_num_documento ?
          `<div class="detail-item">${alert.tipo_documento || alert.vtipo_documento}: ${alert.documento_contacto || alert.num_documento || alert.list_num_documento}</div>` : ''}
        <div class="detail-item">Reportado: ${formattedRegTime}</div>
        <div class="detail-item">Precisión: ${alert.person_accuracy || alert.vehicle_accuracy || alert.acc_parecido || alert.accuracy_obj}%</div>
        ${alert.persona_contacto || alert.nombre_propietario || alert.list_nombre_propietario ?
          `<div class="detail-item">Contacto: ${alert.parentesco || 'Propietario'} - ${alert.persona_contacto || alert.nombre_propietario || alert.list_nombre_propietario}</div>` : ''}
        ${alert.numero_contacto || alert.contacto_propietario || alert.list_contacto_propietario ?
          `<div class="detail-item">Teléfono: ${alert.numero_contacto || alert.contacto_propietario || alert.list_contacto_propietario}</div>` : ''}
        <div class="person-details-images">
          <div class="person-image-container">
            <div class="person-image-label">Detección Recortada</div>
            <div id="cropped-detection-detail" class="person-image"></div>
          </div>
          <div class="person-image-container">
            <div class="person-image-label">Foto de Referencia</div>
            <div id="person-detection-detail" class="person-image"
              style="background-image: url(${alert.person_coords_face || alert.coords_face ?
                `/personimages/inputs/${alert.matched_ident || alert.id}.jpg` :
                alert.foto_frame || alert.foto})">
            </div>
          </div>
        </div>
      </div>
      <button
        style="width:100%"
        class="btn btn-success"
        onclick="event.stopPropagation(); seleccionVideo('${alert.main_id||alert.id}')">
        ▶ Ver video
      </button>
    `;
  } else {
    frameContainer.innerHTML = `
      <div class="">
        <img src="${alert.foto_frame || alert.foto}" style="width:100%; border-radius:8px; margin-bottom:8px;">
        <button
          style="width:100%"
          class="btn btn-success"
          onclick="event.stopPropagation(); seleccionVideo('${alert.main_id||alert.id}')">
          ▶ Ver video
        </button>
      </div>
    `;
  }

  // 🔹 Si hay detección recortada, aplicar recorte luego
  if ((alert.tracking_id || alert.xtracking_id) && (alert.foto || alert.foto_frame)) {
    setTimeout(() => applyImageCropping(alert), 100);
  }
}

let nuevasAlertas = [];

// ==========================
// Función getAlertas MODIFICADA
// ==========================
function getAlertas(item) {
    // MOSTRAR LOADER - MEJORADO
    const timelineList = document.getElementById('timelineList');

    // NO mostrar loader si hay una búsqueda activa de placa o características
    if (!(currentSearchType === 'placa' && item === null) &&
        !(currentSearchType === 'caracteristicas' && item === null)) {
        if (timelineList) {
            //timelineList.innerHTML = '<div style="text-align:center;margin:2em; display:flex; flex-direction:column; align-items:center; justify-content:center;"><div class="spinner"></div><div>Cargando alertas...</div></div>';
        }
    }

    // Crear objeto de parámetros base
    let params = {};

    // Agregar parámetros solo si son válidos
    if (item && isValidParam(item.matched_plate)) {
        params.matched_plate = item.matched_plate;
    }

    if (item && isValidParam(item.id)) {
        params.matched_ident = item.id;
    }

    if(areaSeleccionada){
        params.id_area = areaSeleccionada;
    }

    if(item){
        return;
    }else{
        callAPI({
        method: 'gestion/getalerts',
        params: params,
        ok: function (vals) {
            document.getElementById("data-spinner").style.display="none";

            // CORRECCIÓN: Actualizar las alertas que se usan para determinar cámaras
            if (currentSearchType === null || currentSearchType === 'interes') {
                alertas = vals.data;

                // Identificar nuevas alertas vs todas
                const alertResult = identificarNuevasAlertas(alertas);
                const newAlerts = alertResult.nuevas;

                // **CAMBIO: Agregar esta sección para notificar sobre las nuevas alertas**
                if (newAlerts.length > 0 && newAlerts.length!=alertas.length) {
                    //log("=== NUEVAS ALERTAS DETECTADAS ===", newAlerts);
                    checkAlertsAgainstInteres(newAlerts);

                    newAlerts.forEach(item => {
                        nuevasAlertas.push(item);
                    });
                }

                    // **MODIFICACIÓN: Solo actualizar filteredAlerts para interés**
                    if (selectedInteresItem !== null && item !== null) {
                        if (vals.data && vals.data.length > 0) {
                            filteredAlerts = [...vals.data];

                            // **CORRECCIÓN: Calcular ruta solo si hay filteredAlerts**
                            if (filteredAlerts.length >= 2) {
                                calculateAndDrawRoute();
                            }
                        } else {
                            filteredAlerts = [];
                            // **CORRECCIÓN: Limpiar ruta si no hay alertas**
                            currentRoute = null;
                            routeAnimationProgress = 0;
                            if (routeAnimation) {
                                cancelAnimationFrame(routeAnimation);
                                routeAnimation = null;
                            }
                        }
                    } else if (item === null) {
                        filteredAlerts = null;
                        // **CORRECCIÓN: Limpiar ruta cuando se cargan todas las alertas**
                        currentRoute = null;
                        routeAnimationProgress = 0;
                        if (routeAnimation) {
                            cancelAnimationFrame(routeAnimation);
                            routeAnimation = null;
                        }
                    }
                }

                if (item === null && selectedInteresItem === null) {
                    initialAlerts = [...vals.data];
                    lastKPUpdate = new Date();
                    calculateTrendData();

                    // NUEVO: Actualizar el panel de personas seleccionadas cuando lleguen nuevas alertas
                    if (multiSelectedItems && multiSelectedItems.length > 0) {
                        updateMapSelectedPersonsPanel();
                    }

                    // Limpiar y actualizar resaltado permanente de cámaras con alertas
                    alertHighlightedCameras = {};
                }

                // **MODIFICACIÓN: Renderizar con las alertas apropiadas según el contexto**
                let alertsToRender;
                if (currentSearchType === 'placa' || currentSearchType === 'caracteristicas') {
                    // Usar resultados de búsqueda activa
                    alertsToRender = currentSearchResults || [];
                } else {
                    // Usar alertas normales o filtradas
                    alertsToRender = filteredAlerts !== null ? filteredAlerts : alertas;
                }

                if(highlightedCamera && currentFilter == highlightedCamera.camera_id){
                    applyFilter();
                }else if( currentFilter != null){
                    applyFilter()
                }else{
                    renderTimelineList(alertsToRender);
                }

                // Actualizar la leyenda y KPIs (siempre con datos iniciales)
                const uniqueAlertTypes = [...new Set(initialAlerts.map(alert => alert.type_event_name))];

                buildLegend(uniqueAlertTypes);
                updateAllMetrics();
                setTimeout(() => {
                    render();
                }, 100);
            },
            error: function (error) {
                //showGlobalLoader(false);

                // NO mostrar error si hay una búsqueda activa
                if (currentSearchType !== null && item === null) {
                    return;
                }

                log("Error al obtener las alertas:", error);
                // Mostrar alertas de ejemplo en caso de error
                const alertasEjemplo = [
                    {
                        id: 1,
                        type_event_name: "Accidente",
                        camera_name: "Cámara 1",
                        location: "Estacionamientos S1",
                        init_time_frame: new Date().toISOString()
                    },
                    {
                        id: 2,
                        type_event_name: "Aglomeración",
                        camera_name: "Cámara 2",
                        location: "Recepción",
                        init_time_frame: new Date(Date.now() - 10000000).toISOString()
                    }
                ];

                // **MODIFICACIÓN: Solo actualizar en caso de error si no hay búsqueda activa**
                if (currentSearchType === null) {
                    // Guardar también en caso de error
                    if (item === null && currentSearchType === null) {
                        initialAlerts = [...alertasEjemplo];
                        lastKPUpdate = new Date();
                        calculateTrendData();

                        // Resaltar cámaras de ejemplo
                        alertHighlightedCameras = {};
                    }

                    currentRoute = null;
                    routeAnimationProgress = 0;
                    if (routeAnimation) {
                        cancelAnimationFrame(routeAnimation);
                        routeAnimation = null;
                    }

                    renderTimelineList(alertasEjemplo);
                    updateAllMetrics();
                }
            }
        });
    }
}

function showGlobalLoader(show) {
    // Crear loader global si no existe
    let globalLoader = document.getElementById('global-loader');
    if (!globalLoader) {
        globalLoader = document.createElement('div');
        globalLoader.id = 'global-loader';
        globalLoader.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(6, 25, 34, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000;
            flex-direction: column;
        `;
        globalLoader.innerHTML = `
        `;
        document.body.appendChild(globalLoader);
    }

    globalLoader.style.display = show ? 'flex' : 'none';
}

function highlightCameraForAlert(cameraId) {
  const camera = camerasData.find(cam => cam.camera_id === cameraId);
  if (!camera) return;

  // Guardar referencia a la cámara resaltada PERMANENTEMENTE
  // (sin timer de expiración)
  alertHighlightedCameras[cameraId] = camera;

  render();
}

forceShowCamera = null;

// ==========================
// Función para limpiar resaltado de alertas
// ==========================
function clearAlertHighlights() {
  alertHighlightedCameras = {};
  forceShowCamera = null; // Añadir esta línea
  render();
}

// ==========================
// Función para calcular datos de tendencia
// ==========================
function calculateTrendData() {
    if (initialAlerts.length === 0) return;

    const now = new Date();
    kpiTrendData = [];

    // Crear intervalos de 1 hora para las últimas 4 horas, incluyendo la hora actual parcial
    for (let i = 4; i >= 1; i--) {
        const hourStart = new Date(now.getTime() - i * 60 * 60 * 1000);
        const hourEnd = i === 1 ? now : new Date(now.getTime() - (i - 1) * 60 * 60 * 1000);

        const alertsInHour = initialAlerts.filter(alert => {
            const alertTime = new Date(alert.init_time_frame);
            return alertTime >= hourStart && alertTime < hourEnd;
        });

        // Formatear la etiqueta del intervalo
        let hourLabel;
        if (i === 1) {
            // Para el último intervalo (hora actual), mostrar hora inicio - hora actual
            const startHour = hourStart.getHours().toString().padStart(2, '0');
            const endHour = hourEnd.getHours().toString().padStart(2, '0');
            const endMinutes = hourEnd.getMinutes().toString().padStart(2, '0');
            hourLabel = `${startHour}:00-${endHour}:${endMinutes}`;
        } else {
            const startHour = hourStart.getHours().toString().padStart(2, '0');
            const endHour = hourEnd.getHours().toString().padStart(2, '0');
            hourLabel = `${startHour}:00-${endHour}:00`;
        }

        kpiTrendData.push({
            hour: hourLabel,
            count: alertsInHour.length,
            timestamp: hourStart
        });
    }
}

$(document).ready(function() {
    // Inicializar fechas por defecto
    const hoy = new Date();
    const ayer = new Date(hoy);
    ayer.setDate(hoy.getDate() - 1);
    (function initDateTimeWindow(){
      const now = new Date();
      const start = new Date(now.getTime() - 6*60*60*1000);
      const pad = n => String(n).padStart(2,'0');
      const toLocalDT = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      $('#txtFechaIni').val(toLocalDT(start));
      $('#txtFechaFin').val(toLocalDT(now));
    })();

    // Asegurar que la pestaña KPI esté activa por defecto
    switchTab('kpi');

    loadSavedSelections();
    updateMapSelectedPersonsPanel();

    // MODIFICADO: Cargar edificios en lugar de llamar directamente a obtainEdificio
    loadEdificiosData();

    initMapFilters();
    initShowAllCheckbox(); // NUEVO: Inicializar checkbox "Activar Todos"
    initConfigModal(); // NUEVO: Inicializar modal de configuración
    initSelectionsContainer();
    initMapSelectedPersonsPanel();
    loadInteresList();
    loadVehicleList();
    getColors();
    
    initCanvasClickListener();

    initLiveAlertsSystem();

    // Aplicar visibilidad inicial de los paneles - MODIFICADO
    updatePanelVisibility('config-show-map-filters', showMapFilters);
    updatePanelVisibility('config-show-camera-status', showCameraStatus);
    updatePanelVisibility('config-show-map-legend', showMapLegend);
    updatePanelVisibility('config-show-selected-persons', showSelectedPersonsPanel);
    updatePanelVisibility('config-show-live-alerts', showLiveAlerts); // NUEVO
});

// Variables globales para el modal de video
let videoPlayer = null;
let selectedAlert = null;

// Función para mostrar detalles de alerta
function showAlertFotoframe() {
    if(!alert){
        alert = selectedAlert;
    }
      const panel = document.getElementById('alert-details');
      const title = document.getElementById('alert-details-title');

      if (!panel || !title) {
        log("Elementos del panel de detalles no encontrados");
        return;
      }

      title.textContent = `Cámara en vivo`;

      // Mostrar el panel
      panel.style.display = 'block';
}

function updateDetailContent(alert){
    const content = document.getElementById('alert-details-content');
    const time = new Date(alert.datetime_lima);
    const formattedTime = time.toLocaleString('es-PE');
    let html = ``;
    if(content.innerHTML.length==0){
      // Construir el contenido básico
      html = `
        <div style="max-width:480px">
            <h4 class="person-details-title" id ="cameraName">Cámara: ${highlightedCamera.camera_name|| highlightedCamera.cameraname || highlightedCamera.camera_id}</h4>
          <div class="detail-item" id ="cameraLocation">
            Ubicación: ${highlightedCamera.location}
          </div>
          <div class="detail-item" id="date-time">
            Fecha y Hora:
            ${formattedTime}
          </div>
      `;

      // Añadir información adicional si está disponible
      if (highlightedCamera.nombre_objetivo) {
        html += `
          <div class="detail-item" id ="cameraObjective">
            Objetivo:
            ${highlightedCamera.nombre_objetivo}
          </div>
        `;
      }

      if (highlightedCamera.nombre_cuadrante) {
        html += `
          <div class="detail-item" id ="cameraQuadrant">
            Cuadrante:
            ${highlightedCamera.nombre_cuadrante}
          </div>
        `;
      }

      // Añadir frame si está disponible
      if (alert.foto||alert.foto_frame) {
        html += `
          <div class="detail-item">
            Vídeo:<br>
            <img id="image-detail" src="${alert.foto||alert.foto_frame}" style="max-width:100%; margin-top:5px; border-radius:4px;">
          </div>
        `;
      }

      html += `</div>`;

      content.innerHTML = html;
    }else{
        const dateTime = document.getElementById("date-time");
        dateTime.textContent = "Fecha y Hora: "+formattedTime;

        const cameraObjective = document.getElementById("cameraObjective");
        if(cameraObjective){
            cameraObjective.textContent = "Objetivo: "+highlightedCamera.nombre_objetivo;
        }

        const cameraLocation = document.getElementById("cameraLocation");
        cameraLocation.textContent = "Ubicación: "+highlightedCamera.location;

        const cameraName = document.getElementById("cameraName");
        cameraName.textContent = "Cámara: "+highlightedCamera.camera_id;

        const cameraQuadrant = document.getElementById("cameraQuadrant");
        if(cameraQuadrant){
            cameraQuadrant.textContent = "Cuadrante: "+highlightedCamera.nombre_cuadrante;
        }
        const fotoData = document.getElementById("image-detail");
        fotoData.src=alert.foto||alert.foto_frame;
    }
}

// Función para aplicar recorte a la imagen de detección
function applyImageCropping(alert) {
  const croppedDetection = document.getElementById('cropped-detection-detail');
  if (!croppedDetection) return;

  croppedDetection.innerHTML = '';
  createCroppedImage(croppedDetection, alert.foto||alert.foto_frame,
                    (alert.person_coords_face || alert.vehicle_coords_plate || alert.coords_face || alert.coords_plate),
                    'Detección',
                    (alert.person_coords_obj || alert.vehicle_coords_obj || alert.coords_obj),
                    120, 125);
}

// Función para crear imagen recortada
function createCroppedImage(parentElement, imageUrl, coordsString, label, coordsObj, width, height) {
  if (!coordsString) return;

  const coords = coordsString.split(",").map(Number);
  const coords1 = coordsObj.split(",").map(Number);
  const [xf1, yf1, xf2, yf2] = coords;
  const [xb1, yb1] = coords1;

  const containerW = width;
  const containerH = height;

  const x1 = xf1 + xb1;
  const y1 = yf1 + yb1;
  const w = xf2 - xf1;
  const h = yf2 - yf1;

  const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
  const w_obj = xo2 - xo1;
  const h_obj = yo2 - yo1;

  const container = document.createElement('div');
  container.className = 'image-section';

  const img = new Image();
  img.src = imageUrl;
  img.onload = () => {
    const imgW = img.naturalWidth;
    const imgH = img.naturalHeight;
    const scale = Math.min(containerW / w, containerH / h);
    const bgW = imgW * scale;
    const bgH = imgH * scale;

    const bgX = (containerW - w * scale) / 2 - x1 * scale;
    const bgY = (containerH - h * scale) / 2 - y1 * scale;

    container.style.backgroundImage = `url(${imageUrl})`;
    container.style.backgroundSize = `${bgW}px ${bgH}px`;
    container.style.backgroundPosition = `${bgX}px ${bgY}px`;
    container.style.backgroundRepeat = "no-repeat";
    container.style.width = `${containerW}px`;
    container.style.height = `${containerH}px`;
  };
  parentElement.appendChild(container);
}

function createCroppedImageCaracteristicas(parentElement, imageUrl, coordsObj, width, height) {
    if (!coordsObj) return;

    const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
    const w_obj = xo2 - xo1;
    const h_obj = yo2 - yo1;

    const containerW = width;
    const containerH = height;

    const img = new Image();
    img.src = imageUrl;
    img.onload = () => {
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;
        const scale = Math.min(containerW / w_obj, containerH / h_obj);
        const bgW = imgW * scale;
        const bgH = imgH * scale;

        const bgX = (containerW - w_obj * scale) / 2 - xo1 * scale;
        const bgY = (containerH - h_obj * scale) / 2 - yo1 * scale;

        parentElement.style.backgroundImage = `url(${imageUrl})`;
        parentElement.style.backgroundSize = `${bgW}px ${bgH}px`;
        parentElement.style.backgroundPosition = `${bgX}px ${bgY}px`;
        parentElement.style.backgroundRepeat = "no-repeat";
        parentElement.style.width = `${containerW}px`;
        parentElement.style.height = `${containerH}px`;
        parentElement.style.borderRadius = "6px";
    };
    img.onerror = () => {
        parentElement.innerHTML = '<div style="color: var(--ink); text-align: center; padding-top: 40px;">Error al cargar imagen</div>';
    };
}

const videoOvl = document.getElementById('videoOvl');
const closeVideoModalBtn = document.getElementById('closeVideoModal');

const interesOvl = document.getElementById('interesOvl');
const closeinteresOvlBtn = document.getElementById('closeInteresModal');

// Función para mostrar el modal de video
function showVideoModal() {
  videoOvl.style.display = 'flex';
}

function closeVideoModal() {
  videoOvl.style.display = 'none';

  if (videoPlayer) {
    try {
      videoPlayer.stop();
    } catch (e) {
      log("Error al detener video player:", e);
    }
    videoPlayer = null;
  }
}

// Event listeners para el modal de video
closeVideoModalBtn.addEventListener('click', closeVideoModal);
closeinteresOvlBtn.addEventListener('click', closeInteresModal);
videoOvl.addEventListener('click', (e) => {
  if (e.target === videoOvl) {
    closeVideoModal();
  }
});
interesOvl.addEventListener('click', (e) => {
  if (e.target === interesOvl) {
    closeInteresModal();
  }
});

// Función para ver video de alerta normal
function verVideo(item) {

  resetVideoModal('regular');

  // Actualizar información en el modal
  document.getElementById("showcamera").textContent = item.camera_name;
  document.getElementById("showUbication").textContent = item.location;
  document.getElementById("showAlert").textContent = item.type_event_name;
  document.getElementById("showId").textContent = item.id;

  let coords_data = null;
  if(item.coords_zone){
    try {
      let poligono = JSON.parse(item.coords_zone);
      coords_data = [{
        points: poligono,
        lineColor: "blue",
        fillColor: "rgba(0,0,255,0.3)",
        lineWidth: 3
      }];
    } catch (e) {
      log("Error parsing coords_zone:", e);
    }
  }

  // Mostrar el modal primero
  showVideoModal();

  // Luego cargar el video
  callAPI({
    method: 'gestion/dolistimgevents',
    params: {
      camid: item.camera_id,
      date_start: item.init_time_frame || item.date_start,
      tracking_id: item.tracking_id
    },
    ok: function (data) {
      const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
      if (!videoContainer) return;

      videoContainer.innerHTML = '';
      try {
        videoPlayer = new videoplay(videoContainer);
      } catch (e) {
        log("Error al crear video player:", e);
        return;
      }

      const grouped = Object.values(
        data[1].reduce((acc, item) => {
          if (!acc[item.foto]) {
            acc[item.foto] = {
              foto: item.foto,
              coords_obj: []
            };
          }
          acc[item.foto].coords_obj.push({
            categoria: item.category,
            accuracy_obj: item.accuracy_obj,
            colorupper: item.color_name_upper,
            colorlower: item.color_name_lower,
            plate: item.plate,
            coords: item.coords_obj.split(","),
            coordsplate: (item.coords_plate || '').split(",")
          });
          return acc;
        }, {})
      );

      try {
        videoPlayer.update(grouped, "foto", "coords_obj", coords_data);
        setTimeout(() => {
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 500);
      } catch (e) {
        log("Error al actualizar video player:", e);
      }
    },
    error: function(error) {
      log("Error al cargar el video:", error);
    }
  });
}

// Función para ver video de persona
function verVideoPersona(item) {
  resetVideoModal('person');

  // Actualizar información en el modal
  document.getElementById("showcamera").textContent = item.camera_name || item.cameraname;
  document.getElementById("showUbication").textContent = item.location;
  document.getElementById("showAlert").textContent = item.type_event_name || 'Detección';
  document.getElementById("showId").textContent = item.main_id||item.id;

  const personInfoPanel = document.getElementById('person-info-panel');
  const photoShort = document.getElementById('photo-short');
  const photoName = document.getElementById('photo-name');
  photoName.style.display = `block`;
  photoShort.style.display = 'none';
  if (personInfoPanel) {
    personInfoPanel.style.display = 'block';
    photoShort.style.display = 'flex';

    dataPerson =  document.getElementById('person-data');
    const personName = item.nombre ? `${item.nombre} ${item.apellido}` : item.vehicle_plate;
    const personTitle = item.nombre ? "Persona Detectada" : "Vehículo Detectado";
    const subTitle = item.nombre ? "Nombre:" : "Placa:";
    const regTime = new Date(item.fecha_registro || item.fecha_robo);
    const formattedRegTime = regTime.toLocaleString('es-PE');
    //document.getElementById('person-name').textContent = `${item.nombre ? (`Nombre: ` + item.nombre + " " + item.apellido) : `Placa: ` + item.vehicle_plate}`;
    dataPerson.innerHTML = `
        <div class="detail-item">${subTitle} ${personName}</div>
          ${item.documento_contacto || item.num_documento ?
            `<div class="detail-item">${item.tipo_documento || item.vtipo_documento}: ${item.documento_contacto || item.num_documento}</div>` : ''}
          <div class="detail-item">Reportado: ${formattedRegTime}</div>
          <div class="detail-item">Precisión: ${item.person_accuracy || item.vehicle_accuracy || item.acc_parecido}%</div>
          ${item.persona_contacto || item.nombre_propietario ?
            `<div class="detail-item">Persona de Contacto: ${item.parentesco || 'Propietario'} - ${item.persona_contacto || item.nombre_propietario}</div>` : ''}
          ${item.numero_contacto || item.contacto_propietario ?
            `<div class="detail-item">Teléfono de contacto: ${item.numero_contacto || item.contacto_propietario}</div>` : ''}
        `;

    const personPhoto = document.getElementById('person-photo');
    if(item.person_coords_face != null || item.coords_face){
      personPhoto.style.backgroundImage = `url(/personimages/inputs/${item.matched_ident||item.id}.jpg)`;
    } else {
      // Lógica para vehicle photo
      const containerW = 90;
      const containerH = 100;
      const [xf1, yf1, xf2, yf2] = (item.vehicle_coords_plate || "0,0,1,1").split(",").map(Number);
      const [xb1, yb1] = (item.vehicle_coords_obj || "0,0").split(",").map(Number);

      const x1 = xf1 + xb1;
      const y1 = yf1 + yb1;
      const w = xf2 - xf1;
      const h = yf2 - yf1;

      const [xo1, yo1, xo2, yo2] = (item.vehicle_coords_obj || "0,0,1,1").split(",").map(Number);
      const w_obj = xo2 - xo1;
      const h_obj = yo2 - yo1;

      const img = new Image();
      img.src = item.foto;
      img.onload = () => {
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;
        const scale_ = Math.min(containerW / w_obj, containerH / h_obj);
        const bgW_ = imgW * scale_;
        const bgH_ = imgH * scale_;
        const bgX_ = (containerW - w_obj * scale_) / 2 - xo1 * scale_;
        const bgY_ = (containerH - h_obj * scale_) / 2 - yo1 * scale_;

        personPhoto.style.backgroundImage = `url(${item.foto})`;
        personPhoto.style.backgroundSize = `${bgW_}px ${bgH_}px`;
        personPhoto.style.backgroundPosition = `${bgX_}px ${bgY_}px`;
      };
    }

    const croppedDetection = document.getElementById('cropped-detection');
    croppedDetection.innerHTML = '';

    createCroppedImage(croppedDetection, item.foto||item.foto_frame,
                      (item.person_coords_face||item.vehicle_coords_plate || item.coords_face),
                      'Detección',
                      (item.person_coords_obj||item.vehicle_coords_obj || item.coords_obj),
                      90, 100);
  } else {
    if (personInfoPanel) personInfoPanel.style.display = 'none';
  }

  // Mostrar el modal primero
  showVideoModal();

  let tracking_id=item.tracking_id || item.xtracking_id;
  let ident = item.matched_ident || item.id;
  // Luego cargar el video según el tipo
  if(item.person_coords_face != null || item.coords_face){
    callAPI({
      method: 'gestion/getframesperson',
      params: {
        camara: item.camera_id,
        tracking_id: tracking_id,
        documento: ident,
      },
      ok: function (data) {
        const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
        if (!videoContainer) return;

        videoContainer.innerHTML = '';
        videoPlayer = new videoplay(videoContainer);

        const frames = data;
        const grouped = Object.values(
          frames.reduce((acc, frame) => {
            if (!acc[frame.foto]) {
              acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
            }
            acc[frame.foto].coords_obj.push({
              categoria: frame.category,
              accuracy_obj: frame.acc_parecido,
              colorupper: frame.color_name_upper,
              colorlower: frame.color_name_lower,
              coords: (frame.coords_obj || '').split(","),
              coordsplate: (frame.coords_face || '').split(","),
              plate: item.nombre + " " + item.apellido
            });
            return acc;
          }, {})
        ).sort((a, b) => a.foto.localeCompare(b.foto));

        videoPlayer.update(grouped, "foto", "coords_obj", null);
        setTimeout(() => {
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 100);
      },
      error: function(error) {
        log("Error al cargar video de persona:", error);
      }
    });
  } else {
    callAPI({
      method: 'gestion/dolistimgbytrackid',
      params: {
        cameraid: item.camera_id,
        tracking_id: item.tracking_id
      },
      ok: function(data) {
        const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
        if (!videoContainer) return;

        videoContainer.innerHTML = '';
        videoPlayer = new videoplay(videoContainer);

        const frames = data[2];
        const grouped = Object.values(
          frames.reduce((acc, frame) => {
            if (!acc[frame.foto]) {
              acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
            }
            acc[frame.foto].coords_obj.push({
              categoria: frame.category,
              accuracy_obj: frame.accuracy_obj,
              colorupper: frame.color_name_upper,
              colorlower: frame.color_name_lower,
              coords: (frame.coords_obj || '').split(","),
              coordsplate: (frame.coords_plate || '').split(","),
              plate: frame.plate
            });
            return acc;
          }, {})
        ).sort((a, b) => a.foto.localeCompare(b.foto));

        videoPlayer.update(grouped, "foto", "coords_obj", null);
        setTimeout(() => {
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 100);
      },
      error: function(error) {
        log("Error al cargar video por trackid:", error);
      }
    });
  }
}

function validarFrame(frame){
    if(busqueda.colorsuperior!='all'){
        if(frame.color_upper != busqueda.colorsuperior){
            return false;
        }
    }
    if(busqueda.colorinferior!='all'){
        if(frame.color_upper != busqueda.colorsuperior){
            return false;
        }
    }
    if(busqueda.edad!='all'){
        if(frame.color_upper != busqueda.colorsuperior){
            return false;
        }
    }
    if(busqueda.sexo!='all'){
        if(frame.color_upper != busqueda.colorsuperior){
            return false;
        }
    }
    return true;
}

// Función para ver video de búsqueda por características
function playVideoCaracteristicas(row) {
    resetVideoModal('caracteristicas');

    // Actualizar información en el modal
    document.getElementById("showcamera").textContent = row.cameraname;
    document.getElementById("showUbication").textContent = row.location;
    let initialText = "Búsqueda por Prenda superior: " + row.colorup;
    if (busqueda.colorinferior != 'all') {
        initialText += " - Prenda inferior: " + row.colorlow;
    }
    if (busqueda.edad != 'all') {
        initialText += " - Edad: " + row.val_edad;
    }
    if (busqueda.sexo != 'all') {
        initialText += " - Género: " + row.genero;
    }
    document.getElementById("showAlert").textContent = initialText;
    document.getElementById("showId").textContent = row.j || row.id + " - Búsqueda por Características";

    const personInfoPanel = document.getElementById('person-info-panel');
    const photoShort = document.getElementById('photo-short');

    if (personInfoPanel && photoShort) {
        personInfoPanel.style.display = 'block';
        photoShort.style.display = 'flex';

        const time = new Date(row.date_start);
        const formattedTime = time.toLocaleString('es-PE');

        const dataPerson = document.getElementById('person-data');
        dataPerson.innerHTML = `
            <div class="detail-item">ID: ${row.j || row.id}</div>
            <div class="detail-item">Cámara: ${row.cameraname}</div>
            <div class="detail-item">Fecha: ${formattedTime}</div>
            <div class="detail-item">Color Superior: ${row.colorup || 'N/A'}</div>
            <div class="detail-item">Color Inferior: ${row.colorlow || 'N/A'}</div>
            <div class="detail-item">Sexo: ${row.genero || 'N/A'}</div>
            <div class="detail-item">Edad: ${row.val_edad || 'N/A'}</div>
            <div class="detail-item">Ubicación: ${row.location}</div>
        `;

        const croppedDetection = document.getElementById('cropped-detection');
        const personPhoto = document.getElementById('person-photo');

        if (croppedDetection) {
            croppedDetection.innerHTML = '';
            createCroppedImageCaracteristicas(croppedDetection, row.foto_frame, row.coords_obj, 90, 100);
        }

        if (personPhoto) {
            const photoName = document.getElementById('photo-name');
            photoName.style.display = `none`;
        }
    }

    // Mostrar el modal primero
    showVideoModal();

    let params = {
        camara: row.camera_id,
        tracking_id: row.xtracking_id || row.tracking_id,
        epoch_frame: row.epoch_frame,
    }

    if(busqueda.colorsuperior!='all'){
        params.color_upper = busqueda.colorsuperior
    }
    if(busqueda.colorinferior!='all'){
        params.color_lower = busqueda.colorinferior
    }
    if(busqueda.edad!='all'){
        params.edad = busqueda.edad
    }
    if(busqueda.sexo != 'all'){
        params.sexo = busqueda.sexo
    }

    // Luego cargar el video
    callAPI({
        method: 'gestion/getframespersoncaract',
        params: params,
        ok: function (data) {
            const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
            if (!videoContainer) return;

            videoContainer.innerHTML = '';
            try {
                videoPlayer = new videoplay(videoContainer);
            } catch (e) {
                log("Error al crear video player:", e);
                return;
            }

            const frames = data;
            const grouped = Object.values(
              frames.reduce((acc, frame) => {
                if (!acc[frame.foto]) {
                  acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
                }
                if(validarFrame(frame)){
                    acc[frame.foto].coords_obj.push({
                      categoria: frame.category,
                      accuracy_obj: frame.accuracy_obj,
                      colorupper: frame.color_name_upper,
                      colorlower: frame.color_name_lower,
                      coords: (frame.coords_obj || '').split(","),
                      coordsplate: (frame.coords_face || '').split(","),
                    });
                }
                return acc;
              }, {})
            ).sort((a, b) => a.foto.localeCompare(b.foto));

            try {
                videoPlayer.update(grouped, "foto", "coords_obj")
                setTimeout(() => {
                    try {
                        videoPlayer.play();
                    } catch (e) {
                        log("Error al reproducir video:", e);
                    }
                }, 100)
            } catch (e) {
                log("Error al actualizar video player:", e);
            }
        },
        error: function (error) {
            log("Error al cargar el video de características:", error);
        }
    });
}

let cameraCount=0;

function getCamaras() {

    const canvas = document.getElementById("boardCanvas");
    if (canvas) {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = configTablero.colorFondo;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dibujar texto de carga
        ctx.fillStyle = "var(--teal)";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Cargando cámaras...", canvas.width/2, canvas.height/2);
    }

    callAPI({
        method: 'gestion/camarabytype',
        params: {
            id_area: areaSeleccionada
        },
        ok: function (vals) {
            cameraCount = vals.length;

            vals.forEach(cam => {
                let ubicacionEncontrada = null;
                let tipoUbicacion = null;

                // BUSQUEDA JERÁRQUICA: 1. Cuadrante, 2. Subzona, 3. Zona
                for (const piso of edificio.pisos) {
                    // 1. BUSCAR EN CUADRANTES
                    for (const ambiente of piso.ambientes) {
                        if (ambiente.tipo === 'cuadrante' &&
                            ambiente.id_cuadrante &&
                            ambiente.id_cuadrante.toString() === cam.id_cuadrante.toString()) {

                            ubicacionEncontrada = ambiente;
                            tipoUbicacion = 'cuadrante';
                            break;
                        }
                    }
                    if (ubicacionEncontrada) break;

                    // 2. BUSCAR EN SUBZONAS
                    for (const ambiente of piso.ambientes) {
                        if (ambiente.tipo === 'subzona' &&
                            ambiente.id_subzona &&
                            ambiente.id_subzona.toString() === cam.id_cuadrante.toString()) {

                            ubicacionEncontrada = ambiente;
                            tipoUbicacion = 'subzona';
                            break;
                        }
                    }
                    if (ubicacionEncontrada) break;

                    // 3. BUSCAR EN ZONAS (por nombre aproximado)
                    for (const ambiente of piso.ambientes) {
                        if (ambiente.tipo === 'zona' &&
                            ambiente.nombre &&
                            cam.location &&
                            cam.location.toLowerCase().includes(ambiente.nombre.toLowerCase())) {

                            ubicacionEncontrada = ambiente;
                            tipoUbicacion = 'zona';
                            break;
                        }
                    }
                    if (ubicacionEncontrada) break;
                }

                if (ubicacionEncontrada) {
                    // CALCULAR POSICIÓN DENTRO DEL AMBIENTE ENCONTRADO
                    const vertices = ubicacionEncontrada.vertices;

                    if (vertices && vertices.length > 0) {
                        // PARA CUADRANTES: usar posición específica si está disponible
                        if (tipoUbicacion === 'cuadrante' && vertices.length === 1) {
                            // Si el cuadrante es un solo punto, usar ese punto directamente
                            cam.coords = [...vertices[0]];
                        } else {
                            // PARA SUBZONAS Y ZONAS: calcular centro del polígono
                            const xCoords = vertices.map(v => v[0]);
                            const zCoords = vertices.map(v => v[2]);

                            const minX = Math.min(...xCoords);
                            const maxX = Math.max(...xCoords);
                            const minZ = Math.min(...zCoords);
                            const maxZ = Math.max(...zCoords);

                            const centerX = (minX + maxX) / 2;
                            const centerZ = (minZ + maxZ) / 2;
                            const y = vertices[0][1]; // Altura del piso

                            cam.coords = [centerX, y, centerZ];
                        }

                        cam.piso = ubicacionEncontrada.piso || piso.nombre;
                        cam.location = `${cam.piso} - ${ubicacionEncontrada.nombre}`;

                        //log(`✓ Cámara ${cam.camera_id} asignada a ${tipoUbicacion}: ${ubicacionEncontrada.nombre}`);
                    }
                } else {
                    // FALLBACK: Asignación inteligente por tipo de cámara
                    //log(`⚠ Cámara ${cam.camera_id} no encontrada en jerarquía, usando asignación por tipo`);
                    asignarCamaraPorTipo(cam);
                }

                if (!cam.coords || !Array.isArray(cam.coords) || cam.coords.length !== 3) {
                    //log(`Cámara ${cam.camera_id} sin coordenadas válidas, asignando por defecto`);
                    // Asignar posición por defecto
                    const pisoObj = edificio.pisos.find(p => p.nombre === (cam.piso || "Piso 1"));
                    const altura = pisoObj ? pisoObj.altura : 0;
                    cam.coords = [0, altura, 0]; // Posición central por defecto
                }
            });

            camerasData = vals;
            render();
        },
        error: function (error) {
            log("Error al obtener las cámaras:", error);
            // Datos de respaldo para pruebas
            camerasData = [
                {
                    "id": 1,
                    "camera_id": "Cámara Vehicular S1",
                    "location": "Sótano 1 - Estacionamientos S1",
                    "latitud": -12.070,
                    "longitud": -77.039,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [-50, -40, 0],
                    "piso": "Sótano 1"
                },
                {
                    "id": 2,
                    "camera_id": "Cámara Salida Vehicular",
                    "location": "Sótano 2 - Estacionamientos S2",
                    "latitud": -12.071,
                    "longitud": -77.038,
                    "estado_general": "inactivo",
                    "fecha_registro": new Date(Date.now() - 3600000).toISOString(),
                    "coords": [-30, -80, 20],
                    "piso": "Sótano 2"
                },
                {
                    "id": 3,
                    "camera_id": "Cámara Parking",
                    "location": "Sótano 3 - Estacionamientos S3",
                    "latitud": -12.072,
                    "longitud": -77.037,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [40, -120, -30],
                    "piso": "Sótano 3"
                },
                {
                    "id": 4,
                    "camera_id": "Cámara Recepción",
                    "location": "Piso 1 - Recepción",
                    "latitud": -12.073,
                    "longitud": -77.036,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [75, 0, -45],
                    "piso": "Piso 1"
                }
            ];
            render();
        }
    });
}

function asignarCamaraPorTipo(cam) {
    const camLocation = (cam.location || '').toLowerCase();
    let ambientesCandidatos = [];

    // BUSCAR AMBIENTES APROPIADOS SEGÚN EL TIPO DE CÁMARA
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            const nombreAmbiente = (ambiente.nombre || '').toLowerCase();

            // CÁMARAS VEHICULARES → ESTACIONAMIENTOS
            if (camLocation.includes('vehicular') || camLocation.includes('estacionamiento') ||
                camLocation.includes('parking') || camLocation.includes('sótano')) {

                if (nombreAmbiente.includes('estacionamiento') || nombreAmbiente.includes('parking') ||
                    nombreAmbiente.includes('sótano') || piso.nombre.toLowerCase().includes('sótano')) {
                    ambientesCandidatos.push({ambiente, piso: piso.nombre});
                }
            }
            // CÁMARAS INTERIORES → PISOS REGULARES
            else {
                if (!nombreAmbiente.includes('estacionamiento') && !nombreAmbiente.includes('parking') &&
                    !piso.nombre.toLowerCase().includes('sótano')) {
                    ambientesCandidatos.push({ambiente, piso: piso.nombre});
                }
            }
        }
    }

    // SI NO HAY CANDIDATOS, USAR CUALQUIER AMBIENTE
    if (ambientesCandidatos.length === 0) {
        for (const piso of edificio.pisos) {
            for (const ambiente of piso.ambientes) {
                if (ambiente.vertices && ambiente.vertices.length > 0) {
                    ambientesCandidatos.push({ambiente, piso: piso.nombre});
                }
            }
        }
    }

    if (ambientesCandidatos.length > 0) {
        const seleccion = ambientesCandidatos[Math.floor(Math.random() * ambientesCandidatos.length)];
        const vertices = seleccion.ambiente.vertices;

        // CALCULAR POSICIÓN ALEATORIA DENTRO DEL AMBIENTE
        const xCoords = vertices.map(v => v[0]);
        const zCoords = vertices.map(v => v[2]);

        const minX = Math.min(...xCoords);
        const maxX = Math.max(...xCoords);
        const minZ = Math.min(...zCoords);
        const maxZ = Math.max(...zCoords);

        const x = minX + Math.random() * (maxX - minX);
        const z = minZ + Math.random() * (maxZ - minZ);
        const y = vertices[0][1];

        cam.coords = [x, y, z];
        cam.piso = seleccion.piso;
        cam.location = `${seleccion.piso} - ${seleccion.ambiente.nombre}`;

        //log(`↳ Cámara ${cam.camera_id} asignada aleatoriamente a: ${seleccion.ambiente.nombre}`);
    } else {
        log(`❌ No se pudo asignar cámara ${cam.camera_id}`);
    }
}

// Función para obtener ambientes por tipo (MODIFICADA)
function getAmbientesByType(type) {
    const ambientes = [];

    if (!edificio.pisos) return ambientes;

    edificio.pisos.forEach(piso => {
        piso.ambientes.forEach(ambiente => {
            // CORRECCIÓN: Usar el nombre del piso en lugar del objeto completo
            const nombreAmbiente = ambiente.nombre ? ambiente.nombre.toLowerCase() : '';
            const nombrePiso = piso.nombre ? piso.nombre.toLowerCase() : '';

            if (type === 'estacionamiento') {
                if ((nombrePiso.includes('sótano') || nombrePiso.includes('piso 1')) &&
                    (nombreAmbiente.includes('estacionamiento') ||
                     nombreAmbiente.includes('parking') ||
                     nombreAmbiente.includes('estacionamientos'))) {
                    // CORRECCIÓN: Crear copia del ambiente con referencia al nombre del piso
                    ambientes.push({
                        ...ambiente,
                        piso: piso.nombre // Solo el nombre, no el objeto completo
                    });
                }
            } else if (type === 'piso') {
                if (!nombrePiso.includes('sótano') &&
                    !nombrePiso.includes('piso 5') &&
                    !nombreAmbiente.includes('estacionamiento') &&
                    !nombreAmbiente.includes('parking')) {
                    // CORRECCIÓN: Crear copia del ambiente con referencia al nombre del piso
                    ambientes.push({
                        ...ambiente,
                        piso: piso.nombre // Solo el nombre, no el objeto completo
                    });
                }
            }
        });
    });

    return ambientes;
}

// Función para resetear el modal de video
function resetVideoModal(type) {
  if (videoPlayer) {
    try {
      videoPlayer.stop();
    } catch (e) {
      log("Error al detener video player:", e);
    }
    videoPlayer = null;
  }

  const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
  if (videoContainer) videoContainer.innerHTML = '';

  const personInfoPanel = document.getElementById('person-info-panel');
  const photoShort = document.getElementById('photo-short');

  if (photoShort) {
    photoShort.style.display = type === 'person' || type === 'caracteristicas' ? 'flex' : 'none';
  }

  if (personInfoPanel) {
    personInfoPanel.style.display = (type === 'person' || type === 'caracteristicas') ? 'block' : 'none';
  }
}

function switchTab(tabName) {
    // Ocultar todos los paneles de pestañas
    document.querySelectorAll('.tab-pane').forEach(pane => {
        pane.classList.remove('active');
    });

    // Desactivar todos los botones de pestañas
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
    });

    // Activar la pestaña seleccionada
    document.getElementById(`tab-${tabName}`).classList.add('active');
    document.querySelector(`.tab-button[data-tab="${tabName}"]`).classList.add('active');
}

function closeZonasModal() {
    const modal = document.getElementById('zonasModal');
    modal.style.display = 'none';
}

let isLastFrame=null;

// Inicializar event listeners para el modal de video
document.addEventListener('DOMContentLoaded', () => {
    // Busca el checkbox. Ajusta el ID si es necesario.
    const liveAlertsCheckbox = document.getElementById('show-live-alerts');

    if (liveAlertsCheckbox) {
        // Sincronizar el estado inicial de la variable con el checkbox
        showLiveAlerts = liveAlertsCheckbox.checked;

        liveAlertsCheckbox.addEventListener('change', (e) => {
            toggleLiveAlerts(e.target.checked);
        });
    } else {
        //log("Checkbox con ID 'show-live-alerts' no encontrado.");
    }

    // Listener para el botón de seleccionar zonas
    const btnSeleccionarZonas = document.getElementById('btnSeleccionarZonas');
    if (btnSeleccionarZonas) {
        btnSeleccionarZonas.addEventListener('click', showUbicacionModal);
    }

    // Listener para cerrar el modal de zonas
    document.getElementById('btnCerrarZonas').addEventListener('click', closeZonasModal);

    document.getElementById('zonasModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeZonasModal();
        }
    });

    // Listener para el botón aplicar
    document.getElementById('btnAplicarZonas').addEventListener('click', function() {
        updateZonasSeleccionadasDisplay();
        closeZonasModal();
    });

    // Listener para el botón limpiar
    document.getElementById('btnLimpiarZonas').addEventListener('click', function() {
        subzonasSeleccionadas.clear();
        nombresSubzonasSeleccionadas.clear();
        // Desmarcar todos los checkboxes en la lista
        document.querySelectorAll('#lista-zonas input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = false;
        });
        updateZonasSeleccionadasDisplay();
        updateSelectAllButtonText(); // NUEVO: Actualizar texto del botón
    });

    document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');
            switchTab(tabName);
        });
    });

    // Asegurar que la pestaña KPI esté activa por defecto
    switchTab('kpi');

    document.getElementById('btnBackToAll').addEventListener('click', function() {
        returnToAllAlerts();
    });


    // Event listener para cerrar el panel de detalles
    const closeButton = document.querySelector('.close-details');
    if (closeButton) {
        closeButton.addEventListener('click', function() {
            closeDetailsAlert(isLastFrame);
        });
    }
});

function returnToAllAlerts(){
    // NUEVO: Mostrar loader
    //showGlobalLoader(true);

    // LIMPIAR RUTA
    currentRoute = null;
    routeAnimationProgress = 0;
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }

    // **MODIFICACIÓN: LIMPIAR ESTADO DE BÚSQUEDAS ACTIVAS**
    currentSearchType = null;
    currentSearchResults = null;
    selectedInteresItem = null; // ← NUEVO: Limpiar el interés seleccionado

    // NUEVO: Resetear filtro de cámaras
    filtroCamara = '';
    const inputFiltro = document.getElementById('input-filtro-camara');
    if (inputFiltro) {
        inputFiltro.value = '';
    }

    // Ocultar el box de persona seleccionada
    document.getElementById('selectedPersonBox').style.display = 'none';

    // Resetear el filtro de cámaras por interés
    filteredCamerasByInteres = null;

    busqueda=null;

    // **MODIFICACIÓN: Forzar recarga de todas las alertas con null explícito**
    getAlertas(busqueda);

    // Restaurar título
    document.getElementById('title-panel').textContent = 'Alertas en tiempo real (Últimas 4 horas)';

    // Ocultar botón de volver
    document.getElementById('btnBackToAll').style.display = 'none';

    // Ocultar resultados de búsqueda por placa
    document.getElementById('placa-results').innerHTML = '';
    document.getElementById('placa-search-form').style.display = 'none';
    document.getElementById('placa-input').value = '';

    // Ocultar resultados de búsqueda por características
    document.getElementById('caracteristicas-results').innerHTML = '';
    document.getElementById('caracteristicas-search-form').style.display = 'none';

    // Forzar re-renderizado para mostrar todas las cámaras
    render();
    setTimeout(() => {
        // NUEVO: Ocultar loader
        showGlobalLoader(false);
    }, 1000);
}

function seleccionVideo(id){
    if(filteredAlerts && filteredAlerts.length){
        selectedAlert = filteredAlerts.find(i => i.id == id);
        if(!selectedAlert){
            selectedAlert = filteredAlerts.find(i => i.main_id == id);
        }
    }else{
        selectedAlert = alertas.find(i => i.id == id);
        if(!selectedAlert){
            selectedAlert = alertas.find(i => i.main_id == id);
        }
    }

    if (selectedAlert) {
        if((selectedAlert.tracking_id != null || selectedAlert.xtracking_id!=null) && selectedAlert.plate==null){
            verVideoPersona(selectedAlert);
        } else {
          verVideo(selectedAlert);
        }
     }
}

function closeDetailsAlert(isLastFrame){

    if(!isLastFrame){
        // Restaurar completamente el estado de las cámaras
        highlightedCamera = null;
        forceShowCamera = null;

        // Forzar actualización de cámaras clickeables
        updateClickableCameras();

        // Resto del código existente...
        // Restaurar el resaltado dorado permanente de todas las alertas
        alertHighlightedCameras = {};

        // Si hay un interés seleccionado, restaurar sus cámaras
        if (selectedInteresItem !== null) {
            // Recargar las alertas del interés para restaurar el resaltado
            let itemBusqueda = interesData.find(data => data.id == selectedInteresItem.id)||interesDataVehicle.find(data => data.id == selectedInteresItem.id);
            if (itemBusqueda) {
                callAPI({
                    method: 'gestion/getalerts',
                    params: {
                        id_area: areaSeleccionada
                    },
                    ok: function (vals) {
                        const alertasInteres = vals.data;
                        const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];

                        cameraNames.forEach(cameraName => {
                            highlightCameraForAlert(cameraName);
                        });
                        render();
                    }
                });
            }
        }
    } else {
        const content = document.getElementById('alert-details-content');
        content.innerHTML = ``;
        // Si no se clickeó ninguna cámara, limpiar resaltados
        highlightedCamera = null;

        isLastFrame = null;

        // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }

        selectedAlert = null;

        if(currentFilter != null || currentFilter != 'all'){
            currentFilter = 'all';
            applyFilter();
        }

        closeDetailsAlert();
        //log("No se clickeó ninguna cámara");
    }
    
    if (showPeople && personasEnAmbientes.length > 0) {
        render();
    }

    // Forzar actualización de cámaras clickeables
    updateClickableCameras();

    const alertDetails = document.getElementById('alert-details');
    if (alertDetails) {
        alertDetails.style.display = 'none';
    }

    // Forzar re-renderizado
    render();
}

function buildLegend(alertTypes) {
  const legendContainer = document.querySelector('.map-legend');
  if (!legendContainer) return;

  legendContainer.innerHTML = '';

  const alertCounts = {};
  alertas.forEach(alert => {
      if(alert.type_event_name==null){
          return;
      }
    const type = alert.type_event_name;
    alertCounts[type] = (alertCounts[type] || 0) + 1;
  });

  const totalAlerts = alertas.length;

  const legendHeader = document.createElement('div');
  legendHeader.className = 'legend-header';
  legendHeader.innerHTML = `
    <div class="legend-title" style="margin-right:3em">Filtrar alertas</div>
    <button class="legend-toggle">−</button>
  `;
  legendContainer.appendChild(legendHeader);

  const legendBody = document.createElement('div');
  legendBody.className = 'legend-body';
  legendBody.style.maxHeight= '280px';
  legendBody.style.overflow= 'auto';

  const allButton = document.createElement('div');
  allButton.className = 'legend-item active';
  allButton.setAttribute('data-filter', 'all');
  allButton.innerHTML = `
    <div class="legend-item-content">
      <!--<span class="legend-dot all-dot"></span>-->
      <span class="legend-label">Todas</span>
    </div>
    <span class="legend-count">${totalAlerts}</span>
  `;
  legendBody.appendChild(allButton);

  alertTypes.forEach(type => {
      if(!type) return;
    const button = document.createElement('div');
    button.className = 'legend-item';
    button.setAttribute('data-filter', type);

    let colorClass = 'teal-dot';
    const lowerType = type.toLowerCase();

    if (lowerType.includes('accidente')) {
      colorClass = 'red-dot';
    } else if (lowerType.includes('aglomeracion') || lowerType.includes('restringida') || lowerType.includes('zona')) {
      colorClass = 'orange-dot';
    }

    button.innerHTML = `
      <div class="legend-item-content">
        <!--<span class="legend-dot ${colorClass}"></span>-->
        <span class="legend-label">${type}</span>
      </div>
      <span class="legend-count">${alertCounts[type] || 0}</span>
    `;
    legendBody.appendChild(button);
  });

  legendContainer.appendChild(legendBody);

  // Event listeners para la leyenda
  const toggleBtn = legendHeader.querySelector('.legend-toggle');
  toggleBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    legendContainer.classList.toggle('minimized');
    toggleBtn.textContent = legendContainer.classList.contains('minimized') ? '+' : '−';
  });

  legendHeader.addEventListener('click', function(e) {
    if (e.target === toggleBtn) return;
    if (legendContainer.classList.contains('minimized')) {
      legendContainer.classList.remove('minimized');
      toggleBtn.textContent = '−';
    }
  });

  initLegendEvents();
}

function initLegendEvents() {
  const legendItems = document.querySelectorAll('.map-legend .legend-item');
  legendItems.forEach(item => {
    item.addEventListener('click', () => {
      legendItems.forEach(i => i.classList.remove('active'));
      item.classList.add('active');
      currentFilter = item.getAttribute('data-filter');
      applyFilter();
    });
  });
}

function applyFilter() {
    // **CORRECCIÓN: Usar filteredAlerts si existe (para interés seleccionado), sino usar alertas**
    const baseAlerts = filteredAlerts !== null && filteredAlerts.length >= 0 ? filteredAlerts : alertas;

    if (currentFilter === 'all') {
        // Si hay filteredAlerts, mantenerlas, sino usar todas las alertas
        const alertsToShow = filteredAlerts !== null && filteredAlerts.length >= 0 ? [...filteredAlerts] : [...alertas];
        renderTimelineList(alertsToShow);
        hideClearFiltersButton();

        // RESTAURAR RESALTADO según el contexto
        alertHighlightedCameras = {};
        if (selectedInteresItem !== null && filteredAlerts !== null && filteredAlerts.length > 0) {
            // **CORRECCIÓN: Solo calcular ruta si hay un interés seleccionado y filteredAlerts**
            if (filteredAlerts.length >= 2) {
                calculateAndDrawRoute();
            }
        } else {
            // Resaltar todas las alertas

            // **CORRECCIÓN: Limpiar ruta cuando no hay interés seleccionado**
            currentRoute = null;
            routeAnimationProgress = 0;
            if (routeAnimation) {
                cancelAnimationFrame(routeAnimation);
                routeAnimation = null;
            }
        }
    } else {
        // Verificar si currentFilter es un tipo de alerta o una cámara
        const isAlertType = baseAlerts.some(alert => alert.type_event_name === currentFilter);

        let filteredResult;
        if (isAlertType) {
            // Filtro por tipo de alerta
            filteredResult = baseAlerts.filter(alert => alert.type_event_name === currentFilter);
        } else {
            // Filtro por cámara
            filteredResult = baseAlerts.filter(alert => alert.camera_name === currentFilter);
        }

        renderTimelineList(filteredResult);

        if(!highlightedCamera){
            showClearFiltersButton();
        }

        // Limpiar resaltado permanente cuando se aplica un filtro
        clearAlertHighlights();

        // **CORRECCIÓN: Limpiar ruta cuando se aplica un filtro específico**
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
    }

    render();
}

document.getElementById('clear-filters-btn').addEventListener('click', function() {
  currentFilter = 'all';
  applyFilter();
  updateLegendSelection('all');
  hideClearFiltersButton();
});

function showClearFiltersButton() {
  const clearFiltersBtn = document.getElementById('clear-filters-btn');
  if (clearFiltersBtn) {
    clearFiltersBtn.disabled = false;
    clearFiltersBtn.classList.add('visible');
  }
}

function hideClearFiltersButton() {
  const clearFiltersBtn = document.getElementById('clear-filters-btn');
  if (clearFiltersBtn) {
    clearFiltersBtn.disabled = true;
    clearFiltersBtn.classList.remove('visible');
  }
}

function updateLegendSelection(filterValue) {
  const legendItems = document.querySelectorAll('.map-legend .legend-item');
  legendItems.forEach(item => {
    const itemFilter = item.getAttribute('data-filter');
    if (itemFilter === filterValue) {
      item.classList.add('active');
    } else {
      item.classList.remove('active');
    }
  });
}

function calculateExtendedMetrics() {
  // Usar initialAlerts en lugar de alertas para KPIs estáticos
  if (initialAlerts.length === 0) return null;

  const totalAlerts = initialAlerts.length;

  // Distribución por tipos principales (usando initialAlerts)
  const typeCounts = {};
  initialAlerts.forEach(alert => {
    const type = alert.type_event_name;
    typeCounts[type] = (typeCounts[type] || 0) + 1;
  });

  const topTypes = Object.entries(typeCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  // Alertas por cámara (Top 5) - usando initialAlerts
  const alertsByCamera = {};
  initialAlerts.forEach(alert => {
    const camera = alert.camera_name || 'Desconocida';
    alertsByCamera[camera] = (alertsByCamera[camera] || 0) + 1;
  });

  const topCameras = Object.entries(alertsByCamera)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  return {
    totalAlerts,
    topTypes,
    topCameras,
    trendData: kpiTrendData, // Incluir datos de tendencia
    timestamp: lastKPUpdate ? lastKPUpdate.toLocaleTimeString('es-PE') : 'N/A' // Timestamp
  };
}

function updateAllMetrics() {
  const metrics = calculateExtendedMetrics();
  if (!metrics) return;

  // Actualizar el timestamp en el encabezado
  const timestampElement = document.getElementById('kpi-timestamp');
  if (timestampElement) {
    timestampElement.textContent = `Actualizado: ${metrics.timestamp}`;
  }

  // El resto del código permanece igual...
  document.getElementById('total-alerts').textContent = metrics.totalAlerts;
  updateAlertTypeMetrics(metrics.topTypes);
  updateCameraMetrics(metrics.topCameras);
  updateTrendChart(metrics.trendData);
}

// ==========================
// Función para actualizar el gráfico de tendencia
// ==========================
function updateTrendChart(trendData) {
    const container = document.getElementById('trend-chart-container');
    if (!container) return;

    if (!trendData || trendData.length === 0) {
        container.innerHTML = '<div class="no-data">No hay datos de tendencia</div>';
        return;
    }

    // Calcular valores mínimos y máximos para una mejor escala
    const values = trendData.map(item => item.count);
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const valueRange = maxValue - minValue;

    // Usar una escala más inteligente que considere el rango de valores
    const scaleFactor = valueRange > 0 ? 70 / valueRange : 1;
    const baseHeight = 15; // Altura base mínima

    let html = `
        <div style="font-size: 12px; color: var(--teal); margin-bottom: 8px; text-align: center;">
            Tendencia últimas 4 horas
        </div>
        <div class="trend-chart" style="height: 80px; display: flex; align-items: end; justify-content: space-around; gap: 8px;">
    `;

    trendData.forEach((item, index) => {
        // Calcular altura proporcional al valor dentro del rango
        let barHeight = baseHeight;
        if (valueRange > 0) {
            barHeight = baseHeight + ((item.count - minValue) * scaleFactor);
        }

        // Limitar la altura máxima
        barHeight = Math.min(barHeight, 70);

        const isIncreasing = index > 0 && item.count > trendData[index - 1].count;
        const isDecreasing = index > 0 && item.count < trendData[index - 1].count;

        let trendIcon = '→';
        let trendColor = '#FFC107'; // Amarillo/neutral
        if (isIncreasing) {
            trendIcon = '↑';
            trendColor = '#4CAF50'; // Verde
        }
        if (isDecreasing) {
            trendIcon = '↓';
            trendColor = '#F44336'; // Rojo
        }

        html += `
            <div style="display: flex; flex-direction: column; align-items: center; height: 100%;">
            ${index === trendData.length - 1 ?
                    `<div class="trend-icon" style="font-size: 14px; font-weight: bold; color: ${trendColor}; margin-top: 3px;">${trendIcon}</div>` :
                    '<div style="height: 14px;"></div>'}
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: end; height: 100%;">
                    <div class="trend-value" style="font-size: 11px; color: var(--teal); margin-bottom: 5px; font-weight: bold;">${item.count}</div>
                    <div class="trend-bar" style="width: 20px; background: linear-gradient(to top, var(--teal), #1cb5a9); border-radius: 3px 3px 0 0; height: ${barHeight}px; transition: height 0.3s ease;"></div>
                </div>
                <div class="trend-label" style="font-size: 10px; color: var(--ink); margin-top: 5px; text-align: center; max-width: 60px; word-wrap: break-word;">${item.hour}</div>
            </div>
        `;
    });

    html += '</div>';
    container.innerHTML = html;
}

function updateAlertTypeMetrics(topTypes) {
  const container = document.getElementById('alert-type-metrics');
  if (!container) return;

  if (!topTypes || topTypes.length === 0) {
    container.innerHTML = '<div class="no-data">No hay tipos de alerta</div>';
    return;
  }

  // Encontrar el valor máximo para escalar las barras
  const maxValue = Math.max(...topTypes.map(([_, count]) => count));

  let html = '';
  topTypes.forEach(([type, count]) => {
    const widthPercentage = (count / maxValue) * 100;
    if(type=="null"){
        return;
    }

    // Determinar el color según el tipo de alerta
    let colorClass = 'teal';
    const lowerType = type.toLowerCase();

    if (lowerType.includes('accidente')) {
      colorClass = '#22e6d9';
    } else if (lowerType.includes('aglomeracion') ||
               lowerType.includes('restringida') ||
               lowerType.includes('zona')) {
      colorClass = 'teal';
    }

    html += `
      <div class="alert-type-item" data-type="${type}">
        <div class="alert-type-label" title="${type}">${type}</div>
        <div class="alert-type-chart">
          <div class="alert-type-fill ${colorClass}" style="width: ${widthPercentage}%"></div>
        </div>
        <div class="alert-type-value ${colorClass}">${count}</div>
      </div>
    `;
  });

  container.innerHTML = html;

  // Añadir event listeners para filtrar por tipo de alerta
  container.querySelectorAll('.alert-type-item').forEach(item => {
    item.addEventListener('click', () => {
      const alertType = item.getAttribute('data-type');
      currentFilter = alertType;
      applyFilter();
      updateLegendSelection(alertType); // Actualizar la selección en la leyenda
    });

    let type = item.getAttribute('data-type')

    if(currentFilter == type){
        updateLegendSelection(currentFilter)
    }
  });
}

function updateCameraMetrics(topCameras) {
  const container = document.getElementById('camera-metrics');
  if (!container) return;

  if (topCameras.length === 0) {
    container.innerHTML = '<div class="no-data">No hay datos de cámaras</div>';
    return;
  }

  // Encontrar el valor máximo para escalar las barras
  const maxValue = Math.max(...topCameras.map(([_, count]) => count));

  let html = '';
  topCameras.forEach(([camera, count]) => {
    const widthPercentage = (count / maxValue) * 100;
    html += `
      <div class="bar-item" data-camera="${camera}">
        <div class="bar-label" title="${camera}">${camera}</div>
        <div class="bar-chart">
          <div class="bar-fill" style="width: ${widthPercentage}%"></div>
        </div>
        <div class="bar-value">${count}</div>
      </div>
    `;
  });

  container.innerHTML = html;

  container.querySelectorAll('.bar-item').forEach(item => {
      item.addEventListener('click', () => {
        const cameraName = item.getAttribute('data-camera');
        currentFilter = cameraName;
        applyFilter();
        // No actualizamos la leyenda porque es un filtro por cámara
        // Pero sí actualizamos la selección en la leyenda a "all" para evitar conflictos
        updateLegendSelection('all');
      });
    });
}
let showDebugAreas = true; // Cambiar a false para desactivar el debug



// Variables globales para filtros



let currentFilter = 'all';
let filteredAlerts = [];
let lastAlertIds = new Set();

// ==========================
// Función para identificar nuevas alertas (MODIFICADA)
// ==========================
function identificarNuevasAlertas(alertasActuales) {
  // Asegurarse de que lastAlertIds existe
  if (!lastAlertIds) {
    lastAlertIds = new Set();
  }

  // Normalizar IDs a strings para evitar problemas
  const idsActuales = new Set(alertasActuales.map(a => String(a.id)));

  // Filtrar las que no están en el set ACUMULADO
  const nuevasAlertas = alertasActuales.filter(a => !lastAlertIds.has(String(a.id)));

  let now = new Date();
  nuevasAlertas.forEach(item=>{
    item.timeStamp=now;
  })

  // **--- LÍNEA CLAVE ---**
  // ACUMULAR los IDs antiguos con los nuevos.
  // Esto crea un nuevo Set con la unión de ambos.
  // ¡Esto es lo que evita el "límite" de 300!
  lastAlertIds = new Set([...lastAlertIds, ...idsActuales]);

  return {
    nuevas: nuevasAlertas,
    todas: alertasActuales
  };
}

// Modificar la función showInteresModal para aceptar el tipo de búsqueda
function showInteresModal(searchType) {
    // Establecer el tipo de búsqueda activa
    currentSearchType = searchType;
    const modal = document.getElementById('interesOvl');
    modal.style.display = 'flex';

    // Cambiar el título según el tipo de búsqueda
    const title = document.getElementById('interesModalTitle');
    if (title) {
        if (searchType === 'personas') {
            title.textContent = 'Búsqueda de Personas de Interés';
        } else if (searchType === 'vehiculos') {
            title.textContent = 'Búsqueda de Vehículos de Interés';
        } else {
            title.textContent = 'Búsqueda Avanzada';
        }
    }

    // Cargar directamente la lista correspondiente
    if (searchType === 'personas') {
        loadInteresList();
    } else if (searchType === 'vehiculos') {
        loadVehicleList();
    }
}

// Función simplificada para cargar vehículos
function loadVehicleList() {
    const container = document.getElementById('interesModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de vehículos...</div></div>';

    callAPI({
        method: 'gestion/get_vehiculos_lista',
        ok: function(data) {
            interesDataVehicle = data;
            renderInteresList(data, container, 2);
        },
        error: function(error) {
            log("Error al cargar la lista de vehículos:", error);
            container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

// Función para cerrar el modal de interés
function closeInteresModal() {
    const modal = document.getElementById('interesOvl');
    modal.style.display = 'none';

    // Resetear a la pestaña de personas para la próxima apertura
    setTimeout(() => {
        switchTab('busqueda');
    }, 300);
}

// Event listeners para cerrar el modal
document.getElementById('closeInteresModal').addEventListener('click', closeInteresModal);
document.getElementById('interesOvl').addEventListener('click', function(e) {
    if (e.target === this) {
        closeInteresModal();
    }
});

// Función para cargar la lista de interés
function loadInteresList() {
    const container = document.getElementById('interesModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de interés...</div></div>';
    callAPI({
        method: 'gestion/getiperson',
        params: {
            id_lista: 'all',
            nombre: 'all',
            ident_nro: 'all'
        },
        ok: function(data) {
            interesData = data;
            const container = document.getElementById('interesModalContent');
            renderInteresList(data, container);
        },
        error: function(error) {
            log("Error al cargar la lista de interés:", error);
            document.getElementById('interesModalContent').innerHTML =
                '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

let interesData = null;
let interesDataVehicle = null;
// Función para renderizar la lista de interés
function renderInteresList(data, container, category) {
    container.style.width='100%';

    if (!data || data.length === 0) {
        container.innerHTML = `<div class="loading">No hay ${category==1?"personas":"vehículos"} de interés</div>`;
        return;
    }

    // Generar un ID único para la tabla basado en la categoría
    const tableId = `interesTable-${category}`;
    const filterId = `filterInteres-${category}`;

    let html = `
        <div style="margin-bottom: 15px;">
            <input type="text" id="${filterId}" placeholder="Buscar por nombre, apellido, documento, placa, etc..."
                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal);background:var(--panel)">
        </div>
        <div style="max-height: 400px; overflow-y: auto;">
            <table class="table table-hover-1" id="${tableId}">
                <thead>
                    <tr>
                        ${data[0].foto?`<th>Foto</th>`:``}
                        <th>Nombre</th>
                        ${data[0].nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}
                        ${data[0].nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}
                        <th>Lista</th>
                        <th>Razón</th>
                        <th>Fecha de reporte</th>
                        ${data[0].nombre_propietario?`<th>Documento de propietario</th>`:``}
                        <th>Persona de contacto</th>
                        <th>Número de contacto</th>
                    </tr>
                </thead>
                <tbody>
    `;

    data.forEach(item => {
        let foto=null;
        if(item.foto){
            foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
            `<img src="${item.foto}"
                  style="width:40px; height:40px; object-fit:cover; border-radius:8px;"
                  onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
            ``;
        }
        const time = new Date(item.fh_crea||item.fecha_robo||item.created_at);
        const formattedTime = time.toLocaleString('es-PE');
        let name = (item.parentesco && item.parentesco!=null?item.parentesco+' - ':'') + (item.persocontacname||item.nombre_propietario?(item.persocontacname||item.nombre_propietario):'')
        html += `
            <tr class="interes-item" data-id="${item.id}" data-tipo="${item.foto?1:2}"
                style="cursor: pointer; border-bottom: 1px solid rgba(34,230,217,0.2);">
                ${foto?`<td>${foto}</td>`:``}
                <td>${item.personame || item.name || 'N/A'}</td>
                <td>${item.documento || item.marca+" "+item.modelo || 'N/A'}</td>
                <td>${item.edad || item.color || 'N/A'}</td>
                <td>${obtainList(item.id_lista.toString(),item.foto?1:2) || 'N/A'}</td>
                <td>${item.descripcion || 'N/A'}</td>
                <td>${formattedTime || 'N/A'}</td>
                ${category==2?(item.nombre_propietario?`<td>${item.tipo_documento+' - '+item.num_documento || 'N/A'}</td>`:`<td>N/A</td>`):``}
                <td>${name!=''?name:'N/A' || 'N/A'}</td>
                <td>${item.persocontac || item.contacto_propietario || 'N/A'}</td>
            </tr>
        `;
    });

    html += `
                </tbody>
            </table>
        </div>
    `;

    container.innerHTML = html;

    // Añadir event listener para el filtro - CORREGIDO
    const filterInput = document.getElementById(filterId);
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const rows = container.querySelectorAll(`#${tableId} tbody tr`);

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                let found = false;

                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(filterText)) {
                        found = true;
                    }
                });

                row.style.display = found ? '' : 'none';
            });
        });
    }

    // Añadir event listeners a las filas de la tabla - CORREGIDO
    container.querySelectorAll('.interes-item').forEach(item => {
        item.addEventListener('click', function() {
            const id = this.getAttribute('data-id');
            const tipo = this.getAttribute('data-tipo');
            selectInteresItem(id, tipo, tipo,true);
        });
    });
}

function obtainList(id_lista,category){
    switch(id_lista) {
        case "1":
            tipoPersona = 'Vehículo Robado';
            break;
        case "2":
            tipoPersona = category==1?'Persona Sospechosa':'Vehículo Sospechoso';
            break;
        case "3":
            tipoPersona = 'Persona Requisitoriada';
            break;
        case "4":
            tipoPersona = 'Persona Desaparecida';
            break;
        default:
            tipoPersona = 'Tipo no especificado';
    }

    return tipoPersona;
}

// Función para seleccionar un item de interés
function selectInteresItem(id, tipo, category, boolean) {
    // Limpiar ruta existente al seleccionar nuevo interés
    currentRoute = null;
    routeAnimationProgress = 0;
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }

    // NUEVO: Resetear filtro de cámaras
    filtroCamara = '';
    const inputFiltro = document.getElementById('input-filtro-camara');
    if (inputFiltro) {
        inputFiltro.value = '';
    }

    //showGlobalLoader(true);

    // Establecer el tipo de búsqueda activa
    currentSearchType = 'interes';

    document.getElementById('placa-search-form').style.display = 'none';
    document.getElementById('caracteristicas-search-form').style.display = 'none';
    document.getElementById('caracteristicas-results').innerHTML = '';

    // Limpiar filtros previos
    currentFilter = 'all';

    selectedInteresItem = { id, tipo };
    // INICIALIZAR CORRECTAMENTE EL FILTRO DE CÁMARAS
    filteredCamerasByInteres = []; // Inicializar como array vacío

    let itemBusqueda=null;

    if(category==1){
        itemBusqueda = interesData.find(data => data.id.toString() == id.toString());
    }else{
        itemBusqueda = interesDataVehicle.find(data => data.id == id);
    }

    // Ocultar botón de búsqueda avanzada y mostrar el de volver';
    document.getElementById('btnBackToAll').style.display = 'block';

    // Mostrar el box de persona seleccionada
    const selectedPersonBox = document.getElementById('selectedPersonBox');
    const selectedPersonDetails = document.getElementById('selectedPersonDetails');

    const time = new Date(itemBusqueda.fecha_robo|| itemBusqueda.fh_crea || itemBusqueda.created_at);
    const formattedTime = time.toLocaleString('es-PE');

    // Determinar el tipo de persona según id_lista
    let tipoPersona = obtainList(itemBusqueda.id_lista.toString(),category);

    // Limpiar resaltado permanente
    alertHighlightedCameras = {};

    if (itemBusqueda) {

        busqueda = itemBusqueda;
        document.getElementById("data-spinner").style.display="none";
        // Obtener alertas asociadas a esta persona de interés
        const nombre = itemBusqueda.name;
        const id = itemBusqueda.id ;
        const precision = null;
        const subzonas = 'all';
        const colorsup = 'all';
        const colorinf = 'all';

        // Paso 1: Obtener la fecha y hora actuales.
        const today = new Date();

        const fechaIniDate = new Date(today);
        fechaIniDate.setHours(0, 0, 0, 0); // Establece la hora a 00:00:00.000

        const fechaIni = fechaIniDate.getTime(); // Obtiene el timestamp UNIX (milisegundos)

        const fechaFinDate = new Date(today);
        fechaFinDate.setHours(23, 59, 59, 999); // Establece la hora a 23:59:59.999

        const fechaFin = fechaFinDate.getTime(); // Obtiene el timestamp UNIX (milisegundos)

        if(category==1){
            callAPI({
                method: "gestion/getlistpersondetect",
                params: {
                    nombre: nombre || "all",
                    id: id,
                    precision: precision,
                    subzonas: subzonas,
                    colorsuperior: colorsup,
                    colorinferior: colorinf,
                    persona: 3,
                    fechaini: fechaIni,
                    fechafin: fechaFin,
                    edad: "all",
                    genero: "all"
                },
                ok: function (data) {
                    let routesCheckbox = document.getElementById('label-routes');
                    routesCheckbox.style.display = 'block';
                    document.getElementById("data-spinner").style.display="none";
                    //showGlobalLoader(false);
                    const alertasInteres = data.filter(item=>item.id_area == areaSeleccionada);

                    // **CORRECCIÓN: ASIGNAR LAS ALERTAS A filteredAlerts**
                    filteredAlerts = alertasInteres ? [...alertasInteres] : [];

                    // **ACTUALIZAR filteredCamerasByInteres CON LAS CÁMARAS FILTRADAS**
                    if (alertasInteres && alertasInteres.length > 0) {
                        const cameraNames = [...new Set(alertasInteres.map(alert => alert.cameraname))];
                        filteredCamerasByInteres = camerasData.filter(cam =>
                            cameraNames.includes(cam.camera_id)
                        );

                        // Resaltar cámaras con alertas del interés
                        cameraNames.forEach(cameraName => {
                            highlightCameraForAlert(cameraName);
                        });
                    } else {
                        // Si no hay alertas, mantener como array vacío
                        filteredCamerasByInteres = [];
                    }

                    // **CORRECCIÓN: Renderizar con las alertas filtradas**
                    renderTimelineList(filteredAlerts);

                    // **CORRECCIÓN: Calcular y dibujar la ruta SOLO si hay filteredAlerts**
                    if (filteredAlerts && filteredAlerts.length >= 2) {
                        calculateAndDrawRoute();
                    } else {
                        currentRoute = null;
                        routeAnimationProgress = 0;
                        if (routeAnimation) {
                            cancelAnimationFrame(routeAnimation);
                            routeAnimation = null;
                        }
                    }

                    render(); // Forzar re-renderizado del mapa

                    // **CORRECCIÓN: Actualizar KPIs con las alertas filtradas**
                    updateAllMetrics();
                },
                error: function (error) {
                    log("Error al obtener alertas para el interés:", error);
                    // En caso de error, tratar como si no hubiera alertas
                    filteredAlerts = [];
                    filteredCamerasByInteres = [];
                    renderTimelineList([]);

                    // Limpiar ruta en caso de error
                    currentRoute = null;
                    routeAnimationProgress = 0;
                    if (routeAnimation) {
                        cancelAnimationFrame(routeAnimation);
                        routeAnimation = null;
                    }

                    render();
                }
            });
        }else{
            if(boolean){
                //log(itemBusqueda)
                searchByPlaca(itemBusqueda.name, true);
            }else{
                //log(itemBusqueda)
                searchByPlaca(itemBusqueda.name);
            }
        }


    }

    // Llenar los detalles de la persona (siempre mostrar esto)
    let name = (itemBusqueda.parentesco && itemBusqueda.parentesco!=null?itemBusqueda.parentesco+' - ':'') + (itemBusqueda.persocontacname||itemBusqueda.nombre_propietario?(itemBusqueda.persocontacname||itemBusqueda.nombre_propietario):'')
    // En la función selectInteresItem, cambiar:
    selectedPersonDetails.innerHTML = `
    <div style="display:flex; gap: 0.6em">
        <div>
        <div><strong>Nombre:</strong> ${itemBusqueda.nombre || itemBusqueda.name || 'N/A'}</div>
        <div><strong>Lista:</strong> ${tipoPersona}</div>
        <div><strong>${itemBusqueda.nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}:</strong> ${itemBusqueda.documento || itemBusqueda.marca+" "+itemBusqueda.modelo || 'N/A'}</div>
        <div><strong>${itemBusqueda.nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}:</strong> ${itemBusqueda.edad || itemBusqueda.color || 'N/A'}</div>
        <div><strong>Reportado:</strong> ${formattedTime || 'N/A'}</div>
        <div><strong>Razón:</strong> ${itemBusqueda.descripcion || 'N/A'}</div>
        <div><strong>Persona de contacto:</strong> ${name || 'N/A'}</div>
        <div><strong>Número de contacto:</strong> ${itemBusqueda.persocontac || itemBusqueda.contacto_propietario || 'N/A'}</div>
        </div>
        ${itemBusqueda.foto && !itemBusqueda.foto.startsWith('@') ?
            `<div style="text-align:right;">
                <img src="${itemBusqueda.foto}" style="max-width: 100px; border-radius: 4px;">
            </div>` : ''}
    <div>

    `;
    selectedPersonBox.style.display = 'block';

    // Cambiar el título del timeline
    document.getElementById('title-panel').textContent = 'Alertas relacionadas';

    if(boolean){
        // Cerrar el modal
        closeInteresModal();
    }
}

// Función para cargar las alertas de interés

function addBackButton() {
    // Verificar si ya existe el botón
    if (document.getElementById('backToAllAlerts')) return;

    const backButton = document.createElement('button');
    backButton.id = 'backToAllAlerts';
    backButton.className = 'btn btn-accent';
    backButton.textContent = 'Volver a todas las alertas';
    backButton.style.marginTop = '10px';

    backButton.addEventListener('click', function() {
        // LIMPIAR RUTA - NUEVO
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }

        // Ocultar el box de persona seleccionada
        document.getElementById('selectedPersonBox').style.display = 'none';
        busqueda=null;

        // Resetear el filtro de cámaras por interés
        filteredCamerasByInteres = null;
        selectedInteresItem = null;

        // Volver a cargar todas las alertas
        getAlertas(busqueda);

        // Restaurar título
        document.getElementById('title-panel').textContent = 'Alertas en tiempo real (Últimas 4 horas)';

        // Forzar re-renderizado para mostrar todas las cámaras
        render();

        // Eliminar el botón
        this.remove();
    });

    // Insertar después del timeline
    document.getElementById('timelineList').parentNode.appendChild(backButton);
}

// ==========================
// Función para calcular y dibujar rutas de seguimiento
// ==========================
function calculateAndDrawRoute() {
    // MOSTRAR INDICADOR DE CARGA DE RUTA
    const canvas = document.getElementById("boardCanvas");
    if (canvas && currentRoute === null) {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "rgba(6, 25, 34, 0.8)";
        ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 20, 200, 40);
        ctx.fillStyle = "var(--teal)";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Calculando ruta...", canvas.width/2, canvas.height/2);
    }

    // **CORRECCIÓN: Usar filteredAlerts si existe, de lo contrario no dibujar ruta**
    const alertsToUse = filteredAlerts && filteredAlerts.length > 0 ? filteredAlerts : [];

    // Verificación más estricta - solo dibujar si hay al menos 2 alertas Y hay un interés seleccionado
    if ((!selectedInteresItem && !busqueda) || !alertsToUse || alertsToUse.length < 2) {
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        render();
        return;
    }

    // NUEVO: FILTRAR Y AGRUPAR DETECCIONES POR CÁMARA Y MINUTO
    const groupedAlerts = filterAndGroupDetections(alertsToUse); // CAMBIÉ EL NOMBRE AQUÍ
    
    if (groupedAlerts.length < 2) {
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        render();
        return;
    }

    const sortedAlerts = [...groupedAlerts].sort((a, b) => // USAR LA NUEVA VARIABLE
        new Date(a.init_time_frame) - new Date(b.init_time_frame)
    );

    // Obtener coordenadas de cámaras en orden temporal
    const routePoints = [];
    sortedAlerts.forEach(alert => {
        const camera = camerasData.find(cam => cam.camera_id === (alert.camera_name || alert.cameraname));
        if (camera && camera.coords) {
            routePoints.push({
                coords: camera.coords,
                cameraName: camera.camera_id,
                timestamp: alert.epoch_frame,
                alertType: alert.type_event_name,
                // NUEVO: Guardar información de tiempo formateada
                timeDisplay: formatTimeForDisplay(alert.init_time_frame || alert.epoch_frame)
            });
        } else {
            //log("Cámara no encontrada para alerta:", alert.camera_name);
        }
    });

    // Eliminar duplicados consecutivos
    const uniqueRoutePoints = [];
    routePoints.forEach((point, index) => {
        if (index === 0 || point.cameraName !== routePoints[index-1].cameraName) {
            uniqueRoutePoints.push(point);
        }
    });

    if (uniqueRoutePoints.length < 2) {
        currentRoute = null;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        return;
    }

    currentRoute = uniqueRoutePoints;
    routeAnimationProgress = 0;

    // Iniciar animación
    if (currentRoute.length > 1) {
        startRouteAnimation();
    }
}

// ==========================
// Función para filtrar y agrupar detecciones por cámara y minuto - NUEVA
// ==========================
function filterAndGroupDetections(alerts) {
    if (!alerts || alerts.length === 0) return [];
    
    // Objeto para agrupar por cámara y mantener la más reciente
    const latestAlertsByCamera = {};
    
    // Procesar todas las alertas para quedarnos con la más reciente de cada cámara
    alerts.forEach(alert => {
        const cameraName = alert.camera_name || alert.cameraname;
        if (!cameraName) return;
        
        const alertTime = new Date(alert.init_time_frame || alert.epoch_frame);
        
        // Si no tenemos alerta para esta cámara, o esta es más reciente, la guardamos
        if (!latestAlertsByCamera[cameraName] || 
            alertTime > latestAlertsByCamera[cameraName].timestamp) {
            
            latestAlertsByCamera[cameraName] = {
                ...alert,
                timestamp: alertTime,
                fullTimestamp: alertTime
            };
        }
    });
    
    // Convertir a array y ordenar por timestamp
    const selectedAlerts = Object.values(latestAlertsByCamera);
    selectedAlerts.sort((a, b) => a.timestamp - b.timestamp);
    
    // NUEVO: Guardar solo el tiempo más reciente para cada cámara
    const cameraTimes = {};
    Object.keys(latestAlertsByCamera).forEach(cameraName => {
        const alert = latestAlertsByCamera[cameraName];
        cameraTimes[cameraName] = [formatDetectionTime(alert.fullTimestamp, true)];
    });
    
    window.cameraDetectionTimes = cameraTimes;
    
    return selectedAlerts;
}

function formatDetectionTime(timestamp, isMostRecent = false) {
    const date = new Date(timestamp);
    
    if (isMostRecent) {
        // Para la detección más reciente: mostrar hora, minuto Y segundo
        return date.toLocaleTimeString('es-PE', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    } else {
        // Para detecciones anteriores: mostrar solo hora y minuto
        return date.toLocaleTimeString('es-PE', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }
}

// ==========================
// Función para formatear tiempo para display - NUEVA
// ==========================
function formatTimeForDisplay(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    
    if (diffMin < 1) {
        return 'Hace unos segundos';
    } else if (diffMin === 1) {
        return 'Hace 1 minuto';
    } else if (diffMin < 60) {
        return `Hace ${diffMin} minutos`;
    } else {
        return date.toLocaleTimeString('es-PE', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }
}

// ==========================
// Función para animar la ruta
// ==========================
function startRouteAnimation() {
  if (routeAnimation) {
    cancelAnimationFrame(routeAnimation);
  }

  const startTime = Date.now();
  const duration = 10000; // 10 segundos para completar la animación

  function animate() {
    const elapsed = Date.now() - startTime;
    routeAnimationProgress = Math.min(elapsed / duration, 1);

    render();

    if (routeAnimationProgress < 1) {
      routeAnimation = requestAnimationFrame(animate);
    } else {
      // Reiniciar la animación cuando termine
      setTimeout(() => {
        routeAnimationProgress = 0;
        startRouteAnimation();
      }, 2000); // Esperar 2 segundos antes de reiniciar
    }
  }

  animate();
}

// ==========================
// Función para dibujar la ruta en el mapa
// ==========================
function drawRoute() {
  // Verificar si debemos mostrar rutas y si hay una ruta válida
  if (!showRoutes || !currentRoute || currentRoute.length < 2) {
    return;
  }

  // Validar que todos los puntos de la ruta tengan coordenadas válidas
  const validRoute = currentRoute.filter(point =>
    point && point.coords && Array.isArray(point.coords) && point.coords.length === 3
  );

  if (validRoute.length < 2) {
    //log("Ruta no válida: menos de 2 puntos con coordenadas válidas");
    return;
  }


  // Dibujar la línea de ruta completa (fondo)
  ctx.strokeStyle = 'rgba(255, 235, 59, 0.6)'; // Amarillo semi-transparente
  ctx.lineWidth = 4;
  ctx.setLineDash([10, 5]);
  ctx.beginPath();

  // Mover al primer punto
  const firstPoint = validRoute[0];
  const [firstX, firstY] = project(firstPoint.coords);
  ctx.moveTo(firstX, firstY);

  // Dibujar línea a través de todos los puntos
  for (let i = 1; i < validRoute.length; i++) {
    const point = validRoute[i];
    const [px, py] = project(point.coords);
    ctx.lineTo(px, py);
  }
  ctx.stroke();

  // Dibujar la animación de progreso (línea sólida)
  if (routeAnimationProgress > 0) {
    const totalSegments = validRoute.length - 1;
    const progressInSegments = routeAnimationProgress * totalSegments;
    const currentSegment = Math.floor(progressInSegments);
    const segmentProgress = progressInSegments - currentSegment;

    ctx.strokeStyle = '#22e6d9'; // Color teal
    ctx.lineWidth = 6;
    ctx.setLineDash([]); // Línea sólida
    ctx.beginPath();

    // Mover al primer punto
    ctx.moveTo(firstX, firstY);

    // Dibujar hasta el segmento actual completo
    for (let i = 1; i <= currentSegment; i++) {
      const point = validRoute[i];
      const [px, py] = project(point.coords);
      ctx.lineTo(px, py);
    }

    // Dibujar el segmento actual parcial si hay progreso
    if (currentSegment < totalSegments && segmentProgress > 0) {
      const startPoint = validRoute[currentSegment];
      const endPoint = validRoute[currentSegment + 1];

      const [startX, startY] = project(startPoint.coords);
      const [endX, endY] = project(endPoint.coords);

      const currentX = startX + (endX - startX) * segmentProgress;
      const currentY = startY + (endY - startY) * segmentProgress;

      ctx.lineTo(currentX, currentY);
    }

    ctx.stroke();
  }

  // Restablecer el estilo de línea
  ctx.setLineDash([]);

  // Dibujar puntos de la ruta
  validRoute.forEach((point, index) => {
        const [px, py] = project(point.coords);
    
        // Verificar si el punto es visible en pantalla
        if (px < 0 || px > canvas.width || py < 0 || py > canvas.height) {
            return;
        }
    
        // Punto de ruta (círculo)
        ctx.beginPath();
        ctx.arc(px, py, 8, 0, 2 * Math.PI);
    
        // Color según la posición en la ruta
        if (index === 0) {
            ctx.fillStyle = '#4caf50'; // Verde para inicio
        } else if (index === validRoute.length - 1) {
            ctx.fillStyle = '#f44336'; // Rojo para fin
        } else {
            ctx.fillStyle = '#ff9800'; // Naranja para puntos intermedios
        }
    
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
    
        // Número de secuencia
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((index + 1).toString(), px, py);
    
        // NUEVO: Dibujar recuadro con lista de tiempos de detección
        if (zoom > 1.0) {
            drawTimeInfoBox(ctx, point.cameraName, px, py);
        }
    });

  // Dibujar flecha de dirección si hay más de un punto
  if (validRoute.length > 1 && routeAnimationProgress > 0) {
    drawDirectionArrow(validRoute);
  }
}

function drawTimeInfoBox(ctx, cameraName, x, y) {
    // Obtener el tiempo de esta cámara (solo el más reciente)
    const detectionTimes = window.cameraDetectionTimes && window.cameraDetectionTimes[cameraName];
    
    if (!detectionTimes || detectionTimes.length === 0) return;
    
    // Configuración del recuadro
    const padding = 8;
    const headerHeight = 20;
    const timeItemHeight = 20;
    
    // Calcular dimensiones del recuadro
    const cameraNameWidth = ctx.measureText(cameraName).width;
    const timeWidth = ctx.measureText(detectionTimes[0]).width;
    const boxWidth = Math.max(cameraNameWidth, timeWidth) + padding * 2;
    const boxHeight = headerHeight + timeItemHeight + padding;
    
    // Posición del recuadro (arriba del punto)
    const boxX = x - boxWidth / 2;
    const boxY = y - 40 - boxHeight;
    
    // Dibujar fondo del recuadro
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.strokeStyle = '#22e6d9';
    ctx.lineWidth = 2;
    
    // Rectángulo redondeado
    const radius = 6;
    ctx.beginPath();
    ctx.moveTo(boxX + radius, boxY);
    ctx.lineTo(boxX + boxWidth - radius, boxY);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
    ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
    ctx.lineTo(boxX + radius, boxY + boxHeight);
    ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
    ctx.lineTo(boxX, boxY + radius);
    ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Dibujar encabezado con nombre de cámara
    ctx.fillStyle = '#22e6d9';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(cameraName, x, boxY + headerHeight / 2);
    
    // Dibujar línea separadora
    ctx.strokeStyle = '#22e6d9';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(boxX + padding, boxY + headerHeight);
    ctx.lineTo(boxX + boxWidth - padding, boxY + headerHeight);
    ctx.stroke();
    
    // Dibujar el tiempo (solo uno, el más reciente)
    const timeY = boxY + headerHeight + timeItemHeight / 2;
    
    // Bullet point rojo (siempre el más reciente)
    ctx.fillStyle = '#ff5252'; // Color rojo
    ctx.beginPath();
    ctx.arc(boxX + padding + 4, timeY, 3, 0, 2 * Math.PI);
    ctx.fill();
    
    // Texto del tiempo
    ctx.fillStyle = '#ffffff';
    ctx.font = '11px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(detectionTimes[0], boxX + padding + 10, timeY);
}

// Función auxiliar para dibujar flecha de dirección
function drawDirectionArrow(route) {
  const progressInSegments = routeAnimationProgress * (route.length - 1);
  const currentSegment = Math.floor(progressInSegments);
  const segmentProgress = progressInSegments - currentSegment;

  if (currentSegment < route.length - 1) {
    const startPoint = route[currentSegment];
    const endPoint = route[currentSegment + 1];

    const [startX, startY] = project(startPoint.coords);
    const [endX, endY] = project(endPoint.coords);

    const arrowX = startX + (endX - startX) * segmentProgress;
    const arrowY = startY + (endY - startY) * segmentProgress;

    // Calcular ángulo de la flecha
    const angle = Math.atan2(endY - startY, endX - startX);

    // Dibujar flecha
    ctx.save();
    ctx.translate(arrowX, arrowY);
    ctx.rotate(angle);

    ctx.fillStyle = '#22e6d9';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-10, -5);
    ctx.lineTo(-10, 5);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}


function initMapFilters() {
  const camerasCheckbox = document.getElementById('show-cameras');
  const pisosCheckbox = document.getElementById('show-pisos');
  const ambientesCheckbox = document.getElementById('show-ambientes');
  const subzonesTextCheckbox = document.getElementById('show-subzones-text');
  const routesCheckbox = document.getElementById('show-routes');
  let labelRoutes = document.getElementById('label-routes');

  if (camerasCheckbox) {
    camerasCheckbox.addEventListener('change', function(e) {
      showCameras = e.target.checked;
      updateShowAllCheckboxState(); // NUEVO: Actualizar estado de "Activar Todos"
      render();
    });
  }

  if (pisosCheckbox) {
    pisosCheckbox.addEventListener('change', function(e) {
      showPisos = e.target.checked;
      updateShowAllCheckboxState(); // NUEVO: Actualizar estado de "Activar Todos"
      render();
    });
  }

  if (ambientesCheckbox) {
    ambientesCheckbox.addEventListener('change', function(e) {
      showAmbientes = e.target.checked;

      // Si se desactivan los ambientes, desactivar también el texto
      if (!showAmbientes) {
        showSubzonesText = false;
        subzonesTextCheckbox.checked = false;
      }

      updateShowAllCheckboxState(); // NUEVO: Actualizar estado de "Activar Todos"
      render();
    });
  }

  if (subzonesTextCheckbox) {
    subzonesTextCheckbox.addEventListener('change', function(e) {
      // Solo permitir activar el texto si los ambientes están activos
      if (showAmbientes) {
        showSubzonesText = e.target.checked;
      } else {
        // Si los ambientes no están activos, forzar desactivado
        showSubzonesText = false;
        this.checked = false;
      }

      updateShowAllCheckboxState(); // NUEVO: Actualizar estado de "Activar Todos"
      render();
    });
  }

  if (routesCheckbox) {
    routesCheckbox.addEventListener('change', function(e) {
      showRoutes = e.target.checked;
      updateShowAllCheckboxState(); // NUEVO: Actualizar estado de "Activar Todos"
      render();
    });

    labelRoutes.style.display = 'none';
  }
  
  const peopleCheckbox = document.getElementById('show-people');
  if (peopleCheckbox) {
    peopleCheckbox.addEventListener('change', function(e) {
      showPeople = e.target.checked;
      updateShowAllCheckboxState();
      if (showPeople) {
        document.getElementById('person-count-legend').style.display = "block";
        iniciarSistemaPersonas();
      } else {
          document.getElementById('person-count-legend').style.display = "none";
        detenerSistemaPersonas();
        personasEnAmbientes = [];
      }
      render();
    });
  }
}

// Función para actualizar los contadores de la leyenda de cámaras - MODIFICADO
function updateCameraLegendCounts(alertCount, normalCount, alertCount15) {
  const alertElement = document.getElementById('alert-cameras-count');
  const alertElement15 = document.getElementById('alert-cameras-count-15');
  const normalElement = document.getElementById('normal-cameras-count');

  if (alertElement) alertElement.textContent = alertCount;
  if (alertElement15) alertElement15.textContent = alertCount15;
  if (normalElement) normalElement.textContent = normalCount;
}

// Event listeners para los botones de búsqueda
document.querySelectorAll('#busquedaContent .btn-default[data-search-type]').forEach(button => {
    button.addEventListener('click', function() {
        const searchType = this.getAttribute('data-search-type');
        handleSearchTypeClick(searchType);
    });
});

// Función para manejar los clics en los botones de búsqueda
function handleSearchTypeClick(searchType) {
    // Ocultar todos los formularios y resultados primero
    document.querySelectorAll('.search-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('search-results').innerHTML = '';
    document.getElementById('caracteristicas-results').innerHTML = '';

    // LIMPIAR BÚSQUEDAS ANTERIORES - NUEVO
    currentSearchType = null;
    currentSearchResults = null;
    filteredAlerts = null;
    selectedInteresItem = null;

    if(highlightedCamera){
        highlightedCamera = null;
        selectedAlert = null;

        returnToAllAlerts();

        // Si no se clickeó ninguna cámara y no hay cámara seleccionada, limpiar resaltados
        highlightedCamera = null;

        isLastFrame = null;

        // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }

        selectedAlert = null;

        if(currentFilter != null || currentFilter != 'all'){
            currentFilter = 'all';
            applyFilter();
        }

        closeDetailsAlert();
    }

    returnToAllAlerts();

    // Ocultar botón de volver
    //document.getElementById('btnBackToAll').style.display = 'none';

    // Restaurar título original
    //document.getElementById('title-panel').textContent = 'Detecciones Relacionadas';

    switch(searchType) {
        case 'personas':
        case 'vehiculos':
            showInteresModal(searchType);
            break;
        case 'placa':
            currentSearchType = 'placa';
            busqueda = null;
            document.getElementById('placa-search-form').style.display = 'block';
            document.getElementById('placa-results').innerHTML = '';
            document.getElementById('selectedPersonBox').style.display = 'none';
            break;
        case 'caracteristicas':
            currentSearchType = 'caracteristicas';
            busqueda = null;
            document.getElementById('caracteristicas-search-form').style.display = 'block';
            document.getElementById('caracteristicas-results').innerHTML = '';
            document.getElementById('selectedPersonBox').style.display = 'none';
            break;
        case 'personas-interes':
            showMultiSelectModal();
    }
}

// Event listener para búsqueda por placa
document.getElementById('search-placa-btn').addEventListener('click', function() {
    const placa = document.getElementById('placa-input').value.trim();
    if (!placa) {
        alert('Por favor ingrese un número de placa');
        return;
    }
    searchByPlaca(placa);
});

// Event listener para búsqueda por características
document.getElementById('search-caracteristicas-btn').addEventListener('click', function() {
    searchByCaracteristicas();
});

function searchByPlaca(placa,isModal) {
    // Establecer el tipo de búsqueda activa

    const resultsContainer = document.getElementById('placa-results');

    if(!isModal){
        resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"></div><div>Buscando vehículos con placa: ' + placa + '</div></div>';
    }else{
        resultsContainer.innerHTML = '';
    }
    // Ocultar el panel de selección
    document.getElementById('selectedPersonBox').style.display = 'none';

    // Mostrar botón de volver
    document.getElementById('btnBackToAll').style.display = 'block';

    busqueda = interesDataVehicle.find(data => data.name == placa)||{name: placa};

    callAPI({
        method: "gestion/dolistseguimiento",
        params: {placa: placa},
        ok: (data) => {
            let routesCheckbox = document.getElementById('label-routes');
            routesCheckbox.style.display = 'block';
            document.getElementById('data-spinner').style.display = 'none';
            const alertasInteres = data.filter(item=>item.id_area == areaSeleccionada);

                    // **CORRECCIÓN: ASIGNAR LAS ALERTAS A filteredAlerts**
                    filteredAlerts = alertasInteres ? [...alertasInteres] : [];

                    // **ACTUALIZAR filteredCamerasByInteres CON LAS CÁMARAS FILTRADAS**
                    if (alertasInteres && alertasInteres.length > 0) {
                        const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];
                        filteredCamerasByInteres = camerasData.filter(cam =>
                            cameraNames.includes(cam.camera_id)
                        );

                        // Resaltar cámaras con alertas del interés
                        cameraNames.forEach(cameraName => {
                            highlightCameraForAlert(cameraName);
                        });
                    } else {
                        // Si no hay alertas, mantener como array vacío
                        filteredCamerasByInteres = [];
                    }

                    // **CORRECCIÓN: Renderizar con las alertas filtradas**
                    renderTimelineList(filteredAlerts);

                    // **CORRECCIÓN: Calcular y dibujar la ruta SOLO si hay filteredAlerts**
                    if (filteredAlerts && filteredAlerts.length >= 2) {
                        calculateAndDrawRoute();
                    } else {
                        currentRoute = null;
                        routeAnimationProgress = 0;
                        if (routeAnimation) {
                            cancelAnimationFrame(routeAnimation);
                            routeAnimation = null;
                        }
                    }

                    render(); // Forzar re-renderizado del mapa

                    // **CORRECCIÓN: Actualizar KPIs con las alertas filtradas**
                    updateAllMetrics();

            // Actualizar el contenedor de resultados con un mensaje
            if(!isModal){
                resultsContainer.innerHTML = `
                    <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                        <h5 style="color: var(--teal); margin-top: 0;">Búsqueda completada</h5>
                        <div style="font-size: 14px;">
                            Se encontraron ${alertasInteres ? alertasInteres.length : 0} resultados para la placa: ${placa}
                        </div>
                        <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                            Los resultados se muestran en la lista de alertas a la derecha.
                        </div>
                    </div>
                `;
            }
        },
        error: (error) => {
            //showGlobalLoader(false);
            log("Error en búsqueda por placa:", error);
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                    <h5 style="color: var(--orange); margin-top: 0;">Error en la búsqueda</h5>
                    <div style="font-size: 14px;">
                        No se pudieron obtener resultados para la placa: ${placa}
                    </div>
                </div>
            `;
        }
    });
}

function showresultsearch(data) {
    const timelineList = document.getElementById('timelineList');

    if (!timelineList) {
        log('Elemento timelineList no encontrado');
        return;
    }

    // Limpiar el contenido actual
    timelineList.innerHTML = '';

    if (!data || data.length === 0) {
        timelineList.innerHTML = '<div class="loading">No hay detecciones para mostrar</div>';
        return;
    }

    // Ordenar los datos por fecha (más reciente primero)
    const sortedData = [...data].sort((a, b) => new Date(b.date_start) - new Date(a.date_start));

    // Obtener el tiempo actual para calcular opacidades
    const now = new Date();

    sortedData.forEach((item, index) => {
        const li = document.createElement('li');
        li.setAttribute('data-id', item.id || index);
        li.setAttribute('data-type', 'caracteristica');

        // Formatear la fecha
        const time = new Date(item.date_start);
        const formattedTime = time.toLocaleString('es-PE');


        // CALCULAR OPACIDAD BASADA EN EL TIEMPO TRANSCURRIDO
        const timeDiff = now - time; // Diferencia en milisegundos
        const minutesDiff = timeDiff / (1000 * 60); // Convertir a minutos

        // Reducir opacidad 0.1 cada 10 minutos, mínimo 0.5
        const opacity = Math.max(0.3, 1 - (Math.floor(minutesDiff / 10) * 0.15));

        // APLICAR OPACIDAD AL ELEMENTO
        li.style.opacity = opacity;

        // Construir el contenido del elemento de lista para características
        li.innerHTML = `
            <strong>${item.id||index + 1} - Detección</strong>
            <div>Cámara: ${item.cameraname || item.camera_name} · ${item.location}</div>
            <div>Sexo: ${item.sexo || 'N/A'} | Edad: ${item.val_edad || 'N/A'}</div>
            <div>Color Superior: ${item.colorup || 'N/A'} | Color Inferior: ${item.colorlow || 'N/A'}</div>
            <time>${formattedTime}</time>
        `;

        // Añadir event listener para mostrar detalles al hacer clic
        li.addEventListener('click', () => {
            playVideoCaracteristicas(item);
        });

        timelineList.appendChild(li);
    });

    // Cambiar el título del timeline para indicar que es búsqueda por características
    document.getElementById('title-panel').textContent = 'Resultados de búsqueda por características';
}

let subzonasSeleccionadas = new Map(); // Cambiar de Set a Map para almacenar id -> objeto completo
let nombresSubzonasSeleccionadas = new Set();

// Función para mostrar el modal de selección de zonas
function showUbicacionModal() {
    const modal = document.getElementById('zonasModal');

    // MOSTRAR EL MODAL
    modal.style.display = 'flex';

    // Cargar la lista de zonas
    loadZonasList();
}

// Función para cargar la lista de zonas
function loadZonasList() {
    const container = document.getElementById('lista-zonas');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando zonas...</div></div>';

    callAPI({
        method: 'gestion/jerarquia_territorial',
        ok: function(data) {
            data = data.filter(item => item.id_area == areaSeleccionada)
            renderZonasList(data);
        },
        error: function(error) {
            log("Error al cargar zonas:", error);
            const container = document.getElementById('lista-zonas');
            container.innerHTML = '<div class="loading">Error al cargar las zonas</div>';
        }
    });
}

let edificio = [];

let areasData = [];

function loadEdificiosData() {
    callAPI({
        method: 'gestion/get_areas',
        ok: function(areas) {
            if (areas && areas.length > 0) {
                areasData = areas;
                actualizarSelectorPisos();

                // Obtener el primer id_area único
                const areasAgrupadas = new Map();
                areas.forEach(area => {
                    if (!areasAgrupadas.has(area.id_area)) {
                        areasAgrupadas.set(area.id_area, area);
                    }
                });

                // Seleccionar el primer edificio por defecto
                const primerEdificio = areasAgrupadas.values().next().value;
                if (primerEdificio) {
                    document.getElementById('selectPiso').value = primerEdificio.id_area;

                    // Cargar el edificio seleccionado
                    obtainEdificio(primerEdificio.id_area);
                }
            } else {
                log('No se recibieron áreas');
            }
        },
        error: function(error) {
            log('Error al cargar las áreas:', error);
        }
    });
}

// Si necesitas convertir el string de subzonas de vuelta a array
function obtenerSubzonas(areaId) {
    let subzonas = [];
    areasData.forEach (area => {
        subzonas.push(area.id_subzona);
    });
    return subzonas;
}

// Función para renderizar la lista de zonas - MODIFICADA
function renderZonasList(zonasData) {
    const container = document.getElementById('lista-zonas');
    if (!container) return;

    if (!zonasData || Object.keys(zonasData).length === 0) {
        container.innerHTML = '<div class="loading">No hay zonas disponibles</div>';
        return;
    }

    let html = '<div style="display: flex; flex-direction: column; gap: 5px;">';

    // Convertir objeto a array y procesar cada zona
    Object.values(zonasData).forEach(zona => {
        // MODIFICADO: Usar solo id_subzona como ID (cuadrante)
        const zonaId = zona.id_subzona; // Solo el cuadrante
        const zonaNombre = zona.ubicacion || 'Sin nombre';
        const isSelected = subzonasSeleccionadas.has(zonaId);

        html += `
            <div class="zona-item" style="display: flex; align-items: center; padding: 8px; border-radius: 4px; border: 1px solid rgba(34,230,217,0.2); cursor: pointer;">
                <input type="checkbox" id="zona-${zonaId}" value="${zonaId}"
                       ${isSelected ? 'checked' : ''}
                       style="margin-right: 10px; accent-color: var(--teal);">
                <label for="zona-${zonaId}" style="flex: 1; cursor: pointer; color: var(--ink);">
                    <strong>${zonaNombre}</strong>
                    <br><span style="font-size: 12px; color: var(--ink);">
                        Área: ${zona.id_area} | Zona: ${zona.id_zona} | Cuadrante: ${zona.id_subzona}
                    </span>
                </label>
            </div>
        `;
    });

    html += '</div>';
    container.innerHTML = html;

    // Event listeners para los checkboxes - MODIFICADO
    container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const zonaId = this.value;
            const zonaItem = this.parentElement;
            const zonaNombre = zonaItem.querySelector('strong').textContent;

            // Buscar el objeto zona completo en los datos
            const zonaCompleta = Object.values(zonasData).find(z =>
                z.id_subzona === zonaId // MODIFICADO: Buscar por id_subzona
            );

            if (this.checked && zonaCompleta) {
                // MODIFICADO: Guardar objeto completo usando solo id_subzona como clave
                subzonasSeleccionadas.set(zonaId, {
                    id: zonaId,
                    nombre: zonaNombre,
                    datos: zonaCompleta
                });
                nombresSubzonasSeleccionadas.add(zonaNombre);
            } else {
                // MODIFICADO: Eliminar del Map usando id_subzona
                subzonasSeleccionadas.delete(zonaId);
                nombresSubzonasSeleccionadas.delete(zonaNombre);
            }
        });
    });

    // Resto del código permanece igual...
    // NUEVO: Event listener para el botón "Seleccionar Todas"
    const btnSelectAll = document.getElementById('btnSelectAllZonas');
    if (btnSelectAll) {
        btnSelectAll.addEventListener('click', function() {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            const todasLasZonas = Object.values(zonasData);

            if (subzonasSeleccionadas.size === todasLasZonas.length) {
                // Si ya están todas seleccionadas, deseleccionar todas
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                subzonasSeleccionadas.clear();
                nombresSubzonasSeleccionadas.clear();
            } else {
                // Seleccionar todas las zonas
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const zonaId = checkbox.value;
                    const zonaItem = checkbox.parentElement;
                    const zonaNombre = zonaItem.querySelector('strong').textContent;

                    // Buscar el objeto zona completo
                    const zonaCompleta = todasLasZonas.find(z =>
                        z.id_subzona === zonaId // MODIFICADO: Buscar por id_subzona
                    );

                    if (zonaCompleta) {
                        subzonasSeleccionadas.set(zonaId, {
                            id: zonaId,
                            nombre: zonaNombre,
                            datos: zonaCompleta
                        });
                        nombresSubzonasSeleccionadas.add(zonaNombre);
                    }
                });
            }

            // Actualizar texto del botón
            updateSelectAllButtonText();
        });
    }

    // Actualizar texto del botón "Seleccionar Todas" inicialmente
    updateSelectAllButtonText();

    // Event listener para el filtro
    const filterInput = document.getElementById('filterZonas');
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const zonaItems = container.querySelectorAll('.zona-item');

            zonaItems.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filterText) ? 'flex' : 'none';
            });
        });
    }
}

function updateSelectAllButtonText() {
    const btnSelectAll = document.getElementById('btnSelectAllZonas');
    if (!btnSelectAll) return;

    // Obtener datos de zonas para saber el total
    const container = document.getElementById('lista-zonas');
    if (!container) return;

    const totalCheckboxes = container.querySelectorAll('input[type="checkbox"]').length;

    if (subzonasSeleccionadas.size === totalCheckboxes && totalCheckboxes > 0) {
        btnSelectAll.textContent = 'Deseleccionar Todas';
        btnSelectAll.style.background = 'var(--orange)';
    } else {
        btnSelectAll.textContent = 'Seleccionar Todas';
        btnSelectAll.style.background = 'var(--teal)';
    }
}

// Función para actualizar la visualización de zonas seleccionadas
function updateZonasSeleccionadasDisplay() {
    const button = document.getElementById('btnSeleccionarZonas');
    if (!button) return;

    if (nombresSubzonasSeleccionadas.size > 0) {
        const zonasList = Array.from(nombresSubzonasSeleccionadas);

        // MODIFICADO: Mostrar los nombres en el texto del botón con ellipsis
        if (zonasList.length > 3) {
            button.textContent = `${zonasList.length} zonas seleccionadas: ${zonasList.slice(0, 3).join(', ')}...`;
        } else {
            button.textContent = zonasList.join(', ');
        }
        button.style.color = 'var(--teal)';
        button.style.fontWeight = 'bold';
        // AÑADIDO: Asegurar que el texto tenga ellipsis
        button.style.whiteSpace = 'nowrap';
        button.style.overflow = 'hidden';
        button.style.textOverflow = 'ellipsis';
    } else {
        button.textContent = 'Seleccionar Zonas/Subzonas';
        button.style.color = 'var(--ink)';
        button.style.fontWeight = 'normal';
        // AÑADIDO: Asegurar que el texto tenga ellipsis
        button.style.whiteSpace = 'nowrap';
        button.style.overflow = 'hidden';
        button.style.textOverflow = 'ellipsis';
    }
}

function getvalues() {
    const fechaIni = $('#txtFechaIni').val()
    ? new Date($('#txtFechaIni').val()).getTime()
    : "";

    const fechaFin = $('#txtFechaFin').val()
        ? new Date($('#txtFechaFin').val()).getTime()
        : "";

    let subzonasList = obtenerSubzonas(areaSeleccionada);
    let stringList = JSON.stringify(subzonasList);

    return {
        subzonas: stringList,
        colorsuperior: $('#txtcolorsup').val().trim(),
        colorinferior: $('#txtcolorinf').val().trim(),
        sexo: $('#txtsexo').val().trim(),
        edad: $("#txtedad").val(),
        precision: null,
        fechaini: fechaIni,
        fechafin: fechaFin,
    }
}

function imageprocess(obj, time) {
    obj.onerror = null;

    var btn = obj.parentElement.parentElement.parentElement.querySelector('button')
    btn.setAttribute('disabled', 1);
    btn.className = "btn btn-w-md btn-secondary btn-rounded"

    setTimeout(
        () => {
            obj.src = '/images/logowin.png'
            obj.style.filter = 'grayscale(100%)'
            obj.style.opacity = '0.1'
        },
        time
    );
}

// Función para búsqueda por características
function searchByCaracteristicas(paramsBusqueda) {
    let routesCheckbox = document.getElementById('label-routes');
    routesCheckbox.style.display = 'none';
    // Establecer el tipo de búsqueda activa
    currentSearchType = 'caracteristicas';
    const resultsContainer = document.getElementById('caracteristicas-results');

    resultsContainer.innerHTML = '';

    // Obtener valores del formulario
    busqueda = paramsBusqueda||getvalues();
    // Validar que al menos un campo esté completado
    if (busqueda.colorsuperior === 'all') {
        resultsContainer.innerHTML = `<div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--red); margin-top: 15px;">
                    <h5 style="color: var(--red); margin-top: 0;">Error</h5>
                    <div style="font-size: 14px;color: var(--red);">
                        La prenda superior es obligatoria
                    </div>
                </div>`;
        toastr["error"]("Escoja un color de prenda superior.","Error");
        return;
    }else if (!busqueda.fechaini && !busqueda.fechafin){
        resultsContainer.innerHTML = `<div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--red); margin-top: 15px;">
                    <h5 style="color: var(--red); margin-top: 0;">Error</h5>
                    <div style="font-size: 14px; color: var(--red);">
                        Debes ingresar un rango de fecha.
                    </div>
                </div>`;
        toastr["error"]("Escoja un rango de fecha.","Error");
        return;
    }

    resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"></div><div>Buscando personas con características...</div></div>';

    // Mostrar loader global
    //showGlobalLoader(true);

    // Ocultar el panel de selección
    document.getElementById('selectedPersonBox').style.display = 'none';

    // Mostrar botón de volver
    document.getElementById('btnBackToAll').style.display = 'block';

    callAPI({
        method: "gestion/getlistpersoncaract",
        params: busqueda,
        ok: (data)=>{
            document.getElementById('data-spinner').style.display = 'none';
            //showGlobalLoader(false);

            // FILTRO: Conservar solo las detecciones cuya cámara contenga "UTEC"
            if (data && Array.isArray(data)) {
                data = data.filter(item => item.id_area && item.id_area == areaSeleccionada);
            }

            // **MODIFICACIÓN: Guardar los resultados de la búsqueda y actualizar timeline**
            currentSearchResults = data;

            // Mostrar resultados en la timeline
            showresultsearch(data);

            // Actualizar el contenedor de resultados con un mensaje
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                    <h5 style="color: var(--teal); margin-top: 0;">Búsqueda completada</h5>
                    <div style="font-size: 14px;">
                        Se encontraron ${data ? data.length : 0} resultados para la búsqueda por características.
                    </div>
                    <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                        Los resultados se muestran en la lista de alertas a la derecha.
                    </div>
                </div>
            `;
        },
        error: (error) => {
            //showGlobalLoader(false);
            log("Error en búsqueda por características:", error);
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                    <h5 style="color: var(--orange); margin-top: 0;">Error en la búsqueda</h5>
                    <div style="font-size: 14px;">
                        No se pudieron obtener resultados para la búsqueda por características.
                    </div>
                </div>
            `;
        }
    });
}

// Funciones de selección (placeholders)
function selectVehicleByPlaca(placa) {
    alert('Seleccionado vehículo con placa: ' + placa);
    // Aquí iría la lógica para seleccionar el vehículo
}

function selectByCaracteristicas() {
    alert('Mostrando detalle de coincidencias por características');
    // Aquí iría la lógica para mostrar el detalle
}


// Variable global para almacenar selecciones
let multiSelectedItems = [];

// Función para mostrar el modal de selección múltiple
function showMultiSelectModal() {
    const modal = document.getElementById('multiSelectOvl');
    modal.style.display = 'flex';

    // Cargar selecciones actuales del localStorage al estado temporal
    loadSavedSelections();
    tempSelectedItems = [...multiSelectedItems];

    // Cargar la lista de personas
    loadMultiSelectList();
}


// Función para cargar la lista de selección múltiple
function loadMultiSelectList() {
    const container = document.getElementById('multiSelectModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de personas...</div></div>';

    callAPI({
        method: 'gestion/get_listas',
        ok: function(data) {
            renderMultiSelectList(data, container);
        },
        error: function(error) {
            log("Error al cargar la lista de interés:", error);
            container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

// Función para renderizar la lista de selección múltiple
function renderMultiSelectList(data, container) {
    if (!data || data.length === 0) {
        container.innerHTML = '<div class="loading">No hay seleccionados de interés</div>';
        return;
    }

    // Usar tempSelectedItems en lugar de multiSelectedItems
    const currentSelectionIds = tempSelectedItems.map(item => item.id);

    // Mostrar selecciones actuales en la parte superior
    let html = `
        <div style="margin-bottom: 20px; padding: 15px; background: var(--bg); border-radius: 8px; border: 1px solid var(--teal);">
            <h5 style="color: var(--teal); margin-top: 0; margin-bottom: 10px;">Selecciones Actuales</h5>
            <div id="current-selections" style="max-height: 150px; overflow-y: auto;">
    `;

    if (tempSelectedItems.length === 0) {
        html += '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
    } else {
        tempSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:8px;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                `<span style="font-size:40px" class="pe-7s-car"></span>`;

            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${foto}
                        <div>
                            <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                            <div style="color: var(--ink); font-size: 12px;">${item.documento || 'Vehículo'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">✕</button>
                </div>
            `;
        });
    }

    html += `
            </div>
        </div>
        <div style="margin-bottom: 15px;">
            <input type="text" id="filterMultiSelect" placeholder="Buscar por nombre, apellido, documento..."
                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
        </div>
        <div id="multiSelectTableContainer" style="max-height: 400px; overflow-y: auto;">
            <table class="table table-hover-1" id="multiSelectTable" style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background: rgba(34,230,217,0.1);">
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Seleccionar</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Foto</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Nombre/Placa</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Documento</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Edad</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Lista</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Razón</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Fecha de reporte</th>
                    </tr>
                </thead>
                <tbody>
    `;

    data.forEach(item => {
        const isChecked = currentSelectionIds.includes(item.id);
        const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
            `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
            `<span style="font-size:40px" class="pe-7s-car"></span>`;

        const time = new Date(item.fecha_robo || item.fh_crea || item.created_at);
        const formattedTime = time.toLocaleString('es-PE');

        html += `
            <tr class="multi-select-item" data-id="${item.id}" style="cursor: pointer; border-bottom: 1px solid rgba(34,230,217,0.1);">
                <td style="padding: 10px;">
                    <input type="checkbox" class="person-checkbox" data-id="${item.id}" ${isChecked ? 'checked' : ''}
                           style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--teal);">
                </td>
                <td style="padding: 10px;">${foto}</td>
                <td style="padding: 10px; color: var(--ink-strong);">${item.personame || item.name || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.documento || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.edad || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${obtainList(item.id_lista.toString(), item.foto?1:2) || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.descripcion || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${formattedTime || 'N/A'}</td>
            </tr>
        `;
    });

    html += `
                </tbody>
            </table>
        </div>
    `;

    container.innerHTML = html;

    // Event listener para el filtro
    const filterInput = document.getElementById('filterMultiSelect');
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const rows = container.querySelectorAll('#multiSelectTable tbody tr');

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                let found = false;

                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(filterText)) {
                        found = true;
                    }
                });

                row.style.display = found ? '' : 'none';
            });
        });
    }

    // Event listeners para los checkboxes - MODIFICADO: Usar tempSelectedItems
    container.querySelectorAll('.person-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const id = this.getAttribute('data-id');
            const isChecked = this.checked;

            if (isChecked) {
                // Agregar a la selección temporal
                const item = data.find(d => d.id == id);
                if (item && !tempSelectedItems.some(selected => selected.id == id)) {
                    tempSelectedItems.push(item);
                }
            } else {
                // Remover de la selección temporal
                tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
            }

            // Actualizar la lista de selecciones actuales INMEDIATAMENTE (solo en el modal)
            updateTempSelectionsDisplay();

            // NO actualizar el localStorage ni las listas principales aquí
        });
    });

    // Event listener para hacer clic en toda la fila
    container.querySelectorAll('.multi-select-item').forEach(row => {
        row.addEventListener('click', function(e) {
            if (e.target.type === 'checkbox') return;

            const checkbox = this.querySelector('.person-checkbox');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        });

        // Efecto hover
        row.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'rgba(34, 230, 217, 0.1)';
        });

        row.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
        });
    });

    // Event listeners para los botones de eliminar en la sección de selecciones actuales (temporal)
    container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromTempSelection(id);
            // Volver a renderizar la lista completa
            renderMultiSelectList(data, container);
        });
    });
}

// Función para actualizar la visualización de selecciones temporales en el modal
function updateTempSelectionsDisplay() {
    const container = document.querySelector('#multiSelectModalContent #current-selections');
    if (!container) return;

    let html = '';

    if (tempSelectedItems.length === 0) {
        html = '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
    } else {
        tempSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                ``;

            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${foto}
                        <div>
                            <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                            <div style="color: var(--ink); font-size: 12px;">${item.documento || 'N/A'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">✕</button>
                </div>
            `;
        });
    }

    container.innerHTML = html;

    // Re-añadir event listeners para los botones de eliminar
    container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromTempSelection(id);

            // Recargar la lista completa
            loadMultiSelectList();
        });
    });
}

// Función para remover una persona de la selección temporal
function removeFromTempSelection(id) {
    tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
    updateTempSelectionsDisplay();
}

// Event listener para el botón de guardar - MODIFICADO
document.getElementById('saveMultiSelection').addEventListener('click', function() {
    // Guardar las selecciones temporales en la variable principal y en localStorage
    multiSelectedItems = [...tempSelectedItems];

    if (saveSelectionsToLocalStorage()) {
        // Actualizar todas las visualizaciones
        updateCurrentSelections();
        updateMapSelectedPersonsPanel();
        closeMultiSelectModal();

        // Mostrar mensaje de éxito
        Swal.fire({
            icon: 'success',
            title: 'Selección guardada',
            text: `Se han guardado ${multiSelectedItems.length} persona(s) de interés`,
            timer: 2000,
            showConfirmButton: false
        });
    } else {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'No se pudo guardar la selección'
        });
    }
});

// Función para actualizar la lista de selecciones actuales
function updateCurrentSelections() {
    const container = document.getElementById('current-selections-list');
    if (!container) return;

    let html = '';

    if (multiSelectedItems.length === 0) {
        html = '<div class="selection-placeholder">Haga clic en "Seleccionar" para añadir a la lista de interés</div>';
    } else {
        multiSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                item.foto : null;

            html += `
                <div class="selection-item" data-id="${item.id}">
                    <div class="selection-item-info">
                    ${foto?`<img src="${foto}" class="selection-item-photo" onerror="this.onerror=null;this.src='/public/images/logowin.png';">`:`<span style="font-size:40px" class="pe-7s-car"></span>`}
                        <div class="selection-item-details">
                            <div class="selection-item-name">${item.personame || item.name || 'N/A'}</div>
                            <div class="selection-item-document">${item.documento || 'Vehículo'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection" data-id="${item.id}" title="Eliminar de la lista">✕</button>
                </div>
            `;
        });
    }

    container.innerHTML = html;

    // Añadir event listeners para los botones de eliminar - MEJORADO
    container.querySelectorAll('.btn-remove-selection').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromSelection(id);

            // Si el modal de selección múltiple está abierto, actualizarlo también
            const multiSelectModal = document.getElementById('multiSelectOvl');
            if (multiSelectModal && multiSelectModal.style.display === 'flex') {
                loadMultiSelectList();
            }
        });
    });
}

// Función para guardar selecciones en localStorage
function saveSelectionsToLocalStorage() {
    try {
        localStorage.setItem('personasInteresSeleccionadas', JSON.stringify(multiSelectedItems));
        return true;
    } catch (e) {
        log('Error al guardar en localStorage:', e);
        return false;
    }
}

// La función removeFromSelection permanece igual (para eliminación desde el panel principal)
function removeFromSelection(id) {
    multiSelectedItems = multiSelectedItems.filter(item => item.id != id);
    updateCurrentSelections();
    saveSelectionsToLocalStorage();
    updateMapSelectedPersonsPanel();
}

// Función para inicializar el contenedor de selecciones
function initSelectionsContainer() {
    const container = document.getElementById('selected-persons-container');
    if (container) {
        updateCurrentSelections();
    }
}

// Función para cargar selecciones del localStorage
function loadSavedSelections() {
    try {
        const saved = localStorage.getItem('personasInteresSeleccionadas');
        if (saved) {
            multiSelectedItems = JSON.parse(saved);
        } else {
            multiSelectedItems = [];
        }
        initSelectionsContainer();
        // AÑADIDO: Actualizar también el panel del mapa
        updateMapSelectedPersonsPanel();
    } catch (e) {
        //log('Error al cargar del localStorage:', e);
        multiSelectedItems = [];
        initSelectionsContainer();
        updateMapSelectedPersonsPanel();
    }
}

// Función para cerrar el modal de selección múltiple
function closeMultiSelectModal() {
    const modal = document.getElementById('multiSelectOvl');
    modal.style.display = 'none';
}

// Event listeners para el nuevo modal
document.getElementById('closeMultiSelectModal').addEventListener('click', closeMultiSelectModal);
document.getElementById('multiSelectOvl').addEventListener('click', function(e) {
    if (e.target === this) {
        closeMultiSelectModal();
    }
});

// Event listener para el botón de guardar
document.getElementById('saveMultiSelection').addEventListener('click', function() {
    if (saveSelectionsToLocalStorage()) {

        updateMapSelectedPersonsPanel();
        closeMultiSelectModal();
    } else {
        alert('Error al guardar la selección');
    }
});

// ==========================
// Función para verificar NUEVAS alertas contra personas de interés
// ==========================
function checkAlertsAgainstInteres(nuevasAlertas) {
    // Cargar selecciones guardadas
    loadSavedSelections();

    if (!multiSelectedItems || multiSelectedItems.length === 0 || !nuevasAlertas || nuevasAlertas.length === 0) {
        return null;
    }

    let lastMatchingAlert = null;
    let lastTimestamp = 0;

    nuevasAlertas.forEach(alert => {
        multiSelectedItems.forEach(persona => {
            if ((persona.id && alert.matched_ident && persona.id.toString() === alert.matched_ident.toString()) ||
                (persona.id && alert.dni && persona.id.toString() === alert.dni.toString())) {

                const alertTime = new Date(alert.init_time_frame).getTime();
                if (alertTime > lastTimestamp) {
                    lastTimestamp = alertTime;
                    lastMatchingAlert = alert;
                }

                // AÑADIDO: Activar resaltado de la persona
                setTimeout(() => {
                    highlightPersonWithAlert(persona.id);
                }, 200);
            }
        });
    });

    return lastMatchingAlert;
}

// Variable global para almacenar temporizadores de alertas activas
let activeAlertTimers = {};

// Función para actualizar el panel de personas de interés en el mapa
function updateMapSelectedPersonsPanel() {
    const panelBody = document.getElementById('selected-persons-map-body');
    if (!panelBody) return;

    if (!multiSelectedItems || multiSelectedItems.length === 0) {
        panelBody.innerHTML = '';
        return;
    }

    // MODIFICACIÓN: Ordenar items por alertas recientes
    const sortedItems = [...multiSelectedItems].sort((a, b) => {
        const timeA = getLastAlertTimestamp(a, a.foto ? 1 : 2);
        const timeB = getLastAlertTimestamp(b, b.foto ? 1 : 2);

        // Los que tienen alertas recientes primero, luego por nombre
        if (timeA > 0 && timeB > 0) {
            return timeB - timeA; // Más reciente primero
        } else if (timeA > 0) {
            return -1; // A tiene alerta, B no
        } else if (timeB > 0) {
            return 1; // B tiene alerta, A no
        } else {
            // Ambos sin alertas, ordenar por nombre
            const nameA = (a.personame || a.name || '').toLowerCase();
            const nameB = (b.personame || b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
        }
    });

    let html = '';

    sortedItems.forEach(person => {
        html += `<div class="box-interest" ${person.foto?'style="padding:8px"':''}>`;
        const photoUrl = person.foto && !person.foto.startsWith('@') ?
            person.foto : '/public/images/logowin.png';
        if(person.foto){
            html += `
                <img src="${photoUrl}"  onclick="getPersonData('${person.id}')"
                     class="selected-person-photo" style="max-width: 50px; min-width: 50px; max-height: 50px;"
                     data-id="${person.id}"
                     title="${person.personame || person.name || 'N/A'}"
                     onerror="this.onerror=null;this.src='/public/images/logowin.png';">
            `;
        }else{
            let placaText = (person.personame || person.name || '').toString().toUpperCase();
            let primeraParte = placaText.substring(0, 3);
            let segundaParte = placaText.substring(3, 6);
            
            html += `
                <div style="background: url('/public/images/placa.png') no-repeat center center; background-size: contain; text-align:center; display:block !important ; min-height:34px; padding-top:12px; font-size: 12px" onclick="getPersonData('${person.id}')"
                     class="selected-person-photo"
                     data-id="${person.id}"
                     title="${person.personame || person.name || 'N/A'}">
                     <span style="color: #000; font-size: 12px; text-transform: uppercase;">
                         <span>${primeraParte}-${segundaParte}</span>
                     </span>
                </div>
            `;
        }
        html+=`</div>`;
    });

    panelBody.innerHTML = html;
}

function getPersonData(personId){
    switchTab('busqueda');
    const personObject = multiSelectedItems.find(p => p.id === personId);

    if(highlightedCamera){
        highlightedCamera = null;
        selectedAlert = null;

        returnToAllAlerts();

        // Si no se clickeó ninguna cámara y no hay cámara seleccionada, limpiar resaltados
        highlightedCamera = null;

        isLastFrame = null;

        // Limpiar intervalo de obtainLastFrame si no hay cámara seleccionada
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }

        selectedAlert = null;

        if(currentFilter != null || currentFilter != 'all'){
            currentFilter = 'all';
            applyFilter();
        }

        closeDetailsAlert();
    }

    let category = 1;
    if(personObject.fecha_robo){
        category = 2;
    }
    selectInteresItem(personObject.id, personObject.tipo, category,false);
}

function highlightPersonWithAlert(personId) {
    const idStr = String(personId);
    
    function applyHighlight() {
        const photoElement = document.querySelector(`#civix-neo .selected-person-photo[data-id="${idStr}"]`);
        
        if (photoElement) {
            
            // Remover primero y luego agregar para forzar repintado
            photoElement.classList.remove('active-alert');
            void photoElement.offsetWidth; // Forzar reflow
            photoElement.classList.add('active-alert');
            
            // Aplicar estilos inline como respaldo
            photoElement.style.setProperty('border', '3px solid #FFD700', 'important');
            photoElement.style.setProperty('box-shadow', '0 0 12px #FFD700', 'important');
            photoElement.style.setProperty('padding', '2px', 'important');
            
            // Limpiar timer anterior
            if (activeAlertTimers[personId]) {
                clearTimeout(activeAlertTimers[personId]);
            }

            // Timer para remover
            activeAlertTimers[personId] = setTimeout(() => {
                photoElement.classList.remove('active-alert');
                // Remover estilos inline
                photoElement.style.removeProperty('border');
                photoElement.style.removeProperty('box-shadow');
                photoElement.style.removeProperty('padding');
                delete activeAlertTimers[personId];
            }, 15000);
            
            return true;
        }
        return false;
    }
    
    // Intentar aplicar inmediatamente
    if (!applyHighlight()) {
        
        // Si no se encuentra, esperar a que esté disponible
        const observer = new MutationObserver(() => {
            if (applyHighlight()) {
                observer.disconnect();
                //log('✅ Elemento encontrado y highlight aplicado');
            }
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
        
        // Timeout por si nunca aparece
        setTimeout(() => {
            observer.disconnect();
            log('❌ Timeout: Elemento no encontrado después de 5 segundos');
        }, 5000);
    }
}

function testHighlight() {
    const firstElement = document.querySelector('[data-id]');
    if (firstElement) {
        const testId = '1762207967174';
        log('🧪 Probando con ID:', testId);
        highlightPersonWithAlert(testId);
    } else {
        log('No hay elementos con data-id para probar');
    }
}

// Función de utilidad para debug
function checkAllPersonElements() {
    //log('=== ELEMENTOS CON data-id ===');
    const elements = document.querySelectorAll('[data-id]');
    elements.forEach(el => {
        log(`- ${el.tagName}.${el.className} [data-id="${el.getAttribute('data-id')}"]`);
    });
    return elements;
}

function initMapSelectedPersonsPanel() {
    const panel = document.getElementById('selected-persons-map-panel');
    const toggleBtn = panel.querySelector('.selected-persons-map-toggle');

    // Actualizar el panel inicialmente
    updateMapSelectedPersonsPanel();
}

function getColors(){
    callAPI({
        method: 'gestion/color',
        ok: function (vals) {
            const seltxtcolorinf = $('#txtcolorinf');
            vals.forEach(obj => {
                seltxtcolorinf.append(`<option value="${obj.id}"> ${obj.name}</option>`);
            });
            const seltxtcolorsup = $('#txtcolorsup');
            vals.forEach(obj => {
                seltxtcolorsup.append(`<option value="${obj.id}"> ${obj.name}</option>`);
            });
        }
    });
}


function startAlertUpdates() {
    // Detener actualizaciones anteriores si existen
    stopAlertUpdates();

    // Iniciar actualización de alertas (cada 5 segundos)
    alertasInterval = setInterval(() => {
        getAlertas(busqueda);
    }, 10000);

    // INICIAR actualización de frames en vivo (cada 1 segundo)
    if (showLiveAlerts) {
        liveAlertUpdateInterval = setInterval(() => {
            updateLiveAlertFrames();
        }, 1000);
    }
}

// MODIFICADA: Función para detener actualizaciones de alertas
function stopAlertUpdates() {
    if (alertasInterval) {
        clearInterval(alertasInterval);
        alertasInterval = null;
    }

    // ASEGURARSE de detener también el intervalo de los frames
    if (liveAlertUpdateInterval) {
        clearInterval(liveAlertUpdateInterval);
        liveAlertUpdateInterval = null;
    }
}

function toggleLiveAlerts(isActive) {
    showLiveAlerts = isActive;

    if (showLiveAlerts) {
        // Si se activa, limpiar el cache y empezar a actualizar
        cameraImageCache.clear();
        // Iniciar el intervalo de 1 segundo si no está ya corriendo
        if (!liveAlertUpdateInterval) {
            liveAlertUpdateInterval = setInterval(() => {
                updateLiveAlertFrames();
            }, 1000);
        }
        // Hacer la primera llamada inmediata
        updateLiveAlertFrames();
    } else {
        // Si se desactiva, detener el intervalo
        if (liveAlertUpdateInterval) {
            clearInterval(liveAlertUpdateInterval);
            liveAlertUpdateInterval = null;
        }
    }

    render();
}

// ==========================
// Función para normalizar coordenadas del edificio - NUEVA
// ==========================
function normalizarCoordenadasEdificio(edificio) {
    if (!edificio.pisos) return edificio;

    edificio.pisos.forEach(piso => {
        // ENCONTRAR TODAS LAS ZONAS DEL PISO, NO SOLO UNA
        const zonas = piso.ambientes.filter(amb => amb.tipo === 'zona');
        if (zonas.length === 0) return;

        // CALCULAR EL BOUNDING BOX DE TODO EL PISO (TODAS LAS ZONAS)
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;

        zonas.forEach(zona => {
            if (zona.vertices && zona.vertices.length > 0) {
                zona.vertices.forEach(vertice => {
                    const x = vertice[0];
                    const z = vertice[2];
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                });
            }
        });

        // SI NO SE ENCONTRARON COORDENADAS VÁLIDAS, USAR VALORES POR DEFECTO
        if (minX === Infinity) {
            minX = -100; maxX = 100; minZ = -100; maxZ = 100;
        }

        // CALCULAR FACTORES DE NORMALIZACIÓN
        const targetSize = 200; // Tamaño objetivo del bounding box
        const currentWidth = maxX - minX;
        const currentHeight = maxZ - minZ;
        const maxCurrentSize = Math.max(currentWidth, currentHeight);

        let scaleFactor = 1;
        if (maxCurrentSize > 0) {
            scaleFactor = targetSize / maxCurrentSize;
        }

        // CALCULAR EL CENTRO ACTUAL
        const centerX = (minX + maxX) / 2;
        const centerZ = (minZ + maxZ) / 2;

        // NORMALIZAR TODOS LOS AMBIENTES DEL PISO
        piso.ambientes.forEach(ambiente => {
            if (!ambiente.vertices || ambiente.vertices.length === 0) return;

            // CREAR NUEVO ARRAY DE VÉRTICES NORMALIZADOS
            const verticesNormalizados = ambiente.vertices.map(vertice => {
                // APLICAR TRANSFORMACIÓN: centrar y escalar
                const xNormalizado = (vertice[0] - centerX) * scaleFactor;
                const zNormalizado = (vertice[2] - centerZ) * scaleFactor;
                const y = vertice[1]; // Mantener la altura original

                return [xNormalizado, y, zNormalizado];
            });
            ambiente.vertices = verticesNormalizados;
        });
    });

    return edificio;
}

// ==========================
// Configuración del modal de configuración - MODIFICADO
// ==========================
function initConfigModal() {
    const configBtn = document.getElementById('btnConfig');
    const configModal = document.getElementById('configOvl');
    const closeConfigBtn = document.getElementById('closeConfigModal');

    if (!configBtn || !configModal) return;

    // Abrir modal
    configBtn.addEventListener('click', function() {
        // Sincronizar los checkboxes del modal con el estado actual
        syncConfigCheckboxes();
        configModal.style.display = 'flex';
    });

    // Cerrar modal
    closeConfigBtn.addEventListener('click', function() {
        configModal.style.display = 'none';
    });

    // Cerrar al hacer clic fuera del modal
    configModal.addEventListener('click', function(e) {
        if (e.target === configModal) {
            configModal.style.display = 'none';
        }
    });

    // Inicializar eventos de los checkboxes del modal
    initConfigCheckboxes();

    // Inicializar la lógica específica para el checkbox de alertas en vivo
    initLiveAlertsCheckboxLogic();
}

function initLiveAlertsCheckboxLogic() {
    const liveAlertsCheckbox = document.getElementById('config-show-live-alerts');
    const otherCheckboxes = [
        'config-show-map-filters',
        'config-show-camera-status',
        'config-show-map-legend',
        'config-show-selected-persons'
    ];

    // Event listener para el checkbox de alertas en vivo
    if (liveAlertsCheckbox) {
        liveAlertsCheckbox.addEventListener('change', function(e) {
            const isLiveAlertsActive = e.target.checked;

            // Si se activan las alertas en vivo, desmarcar y deshabilitar las otras opciones
            if (isLiveAlertsActive) {
                otherCheckboxes.forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) {
                        checkbox.checked = false;
                        checkbox.disabled = true;

                        // Actualizar las variables globales correspondientes
                        updateConfigVariable(id, false);
                        updatePanelVisibility(id, false);
                    }
                });
                
                if(document.getElementById('filtro-camaras-container')){
                    document.getElementById('filtro-camaras-container').style.display = 'none';
                }

                // Activar el sistema de alertas en vivo
                toggleLiveAlerts(true);
            } else {
                // Si se desactivan las alertas en vivo, habilitar las otras opciones
                otherCheckboxes.forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) {
                        checkbox.disabled = false;

                        // Restaurar el estado por defecto (todos true)
                        checkbox.checked = true;
                        updateConfigVariable(id, true);
                        updatePanelVisibility(id, true);
                    }
                });
                
                if(document.getElementById('filtro-camaras-container')){
                    document.getElementById('filtro-camaras-container').style.display = 'block';
                }

                // Desactivar el sistema de alertas en vivo
                toggleLiveAlerts(false);
            }

            render();
        });
    }
}

// ==========================
// Sincronizar checkboxes del modal con estado actual - MODIFICADO
// ==========================
function syncConfigCheckboxes() {
    // Sincronizar los checkboxes con las variables globales
    document.getElementById('config-show-map-filters').checked = showMapFilters;
    document.getElementById('config-show-camera-status').checked = showCameraStatus;
    document.getElementById('config-show-map-legend').checked = showMapLegend;
    document.getElementById('config-show-selected-persons').checked = showSelectedPersonsPanel;
    document.getElementById('config-show-live-alerts').checked = showLiveAlerts;

    // Si las alertas en vivo están activas, deshabilitar los otros checkboxes
    if (showLiveAlerts) {
        const otherCheckboxes = [
            'config-show-map-filters',
            'config-show-camera-status',
            'config-show-map-legend',
            'config-show-selected-persons'
        ];
        otherCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.disabled = true;
            }
        });
    }
}

// ==========================
// Inicializar eventos de checkboxes del modal - MODIFICADO
// ==========================
function initConfigCheckboxes() {
    const configCheckboxes = [
        'config-show-map-filters',
        'config-show-camera-status',
        'config-show-map-legend',
        'config-show-selected-persons',
        'config-show-live-alerts' // Ahora incluimos el de alertas en vivo, pero con un manejo especial
    ];

    // Para cada checkbox en el modal, añadir evento
    configCheckboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            // No agregamos el evento change para el checkbox de alertas en vivo aquí, porque lo manejamos en initLiveAlertsCheckboxLogic
            if (id !== 'config-show-live-alerts') {
                checkbox.addEventListener('change', function() {
                    updateConfigVariable(id, this.checked);
                    updatePanelVisibility(id, this.checked);
                    render();
                });
            }
        }
    });
}

function updateConfigVariable(checkboxId, isChecked) {
    switch(checkboxId) {
        case 'config-show-map-filters':
            showMapFilters = isChecked;
            break;
        case 'config-show-camera-status':
            showCameraStatus = isChecked;
            break;
        case 'config-show-map-legend':
            showMapLegend = isChecked;
            break;
        case 'config-show-selected-persons':
            showSelectedPersonsPanel = isChecked;
            break;
        case 'config-show-live-alerts':
            showLiveAlerts = isChecked;
            break;
    }
}

// ==========================
// Actualizar visibilidad de paneles - NUEVA FUNCIÓN
// ==========================
// MODIFICADO: Función para actualizar visibilidad de paneles - AÑADIR LIVE ALERTS
function updatePanelVisibility(checkboxId, isVisible) {
    switch(checkboxId) {
        case 'config-show-map-filters':
            showMapFilters = isVisible;
            document.getElementById('map-filters').style.display = isVisible ? 'block' : 'none';
            break;
        case 'config-show-camera-status':
            showCameraStatus = isVisible;
            document.getElementById('camera-status-legend').style.display = isVisible ? 'block' : 'none';
            break;
        case 'config-show-map-legend':
            showMapLegend = isVisible;
            document.getElementById('map-legend').style.display = isVisible ? 'block' : 'none';
            break;
        case 'config-show-selected-persons':
            showSelectedPersonsPanel = isVisible;
            document.getElementById('selected-persons-map-panel').style.display = isVisible ? 'block' : 'none';
            break;
        case 'config-show-live-alerts': // NUEVO
            showLiveAlerts = isVisible;
            document.getElementById('live-alerts-container').style.display = isVisible ? 'block' : 'none';
            if (showLiveAlerts) {
                startLiveAlertsUpdates();
            } else {
                stopLiveAlertsUpdates();
                clearLiveAlertFrames();
            }
            render();
            break;
    }
}

// ==========================
// Función para obtener timestamp de última alerta - NUEVA
// ==========================
function getLastAlertTimestamp(item, category) {
    if (!alertas || alertas.length === 0) return 0;

    let relevantAlerts = [];

    if (category === 1) { // Persona
        relevantAlerts = alertas.filter(alert => alert.matched_ident == item.id);
    } else { // Vehículo
        relevantAlerts = alertas.filter(alert => alert.matched_plate == item.name);
    }

    if (relevantAlerts.length === 0) return 0;

    // Ordenar por fecha descendente y tomar la más reciente
    relevantAlerts.sort((a, b) => new Date(b.init_time_frame) - new Date(a.init_time_frame));
    return new Date(relevantAlerts[0].init_time_frame).getTime();
}

// ==========================
// Sistema de Alertas en Vivo - NUEVO
// ==========================

function initLiveAlertsSystem() {

    // Inicializar event listener para el checkbox
    const liveAlertsCheckbox = document.getElementById('config-show-live-alerts');
    if (liveAlertsCheckbox) {
        liveAlertsCheckbox.addEventListener('change', function(e) {
            showLiveAlerts = e.target.checked;
            //log('Alertas en vivo:', showLiveAlerts ? 'ACTIVADAS' : 'DESACTIVADAS');

            if (showLiveAlerts) {
                startLiveAlertsUpdates();
            } else {
                stopLiveAlertsUpdates();
                clearLiveAlertFrames();
            }
            render();
        });
    }

    // Iniciar actualizaciones si está activo por defecto
    if (showLiveAlerts) {
        //log('Iniciando actualizaciones de alertas en vivo...');
        startLiveAlertsUpdates();
    }
}

function startLiveAlertsUpdates() {
    //log('🚀 INICIANDO ACTUALIZACIONES DE ALERTAS EN VIVO');

    // Actualizar inmediatamente
    updateLiveAlertFrames();

    // Configurar intervalo de actualización (cada 5 segundos)
    if (liveAlertUpdateInterval) {
        clearInterval(liveAlertUpdateInterval);
    }
    liveAlertUpdateInterval = setInterval(() => {
        updateLiveAlertFrames();
    }, 1000);
}

function stopLiveAlertsUpdates() {
    if (liveAlertUpdateInterval) {
        clearInterval(liveAlertUpdateInterval);
        liveAlertUpdateInterval = null;
    }
}

// AÑADIDO: Variable para almacenar IDs de personas de interés
let personsOfInterestIds = new Set();

// AÑADIDO: Variables para optimización de renderizado
let lastCameraUpdate = 0;
const CAMERA_UPDATE_INTERVAL = 500; // Actualizar cámaras como máximo cada segundo
let lastRenderTime = 0; 
const RENDER_THROTTLE = 100; // Limitar renderizados a 10fps como máximo

function updateLiveAlertFrames() {
    // No hacer nada si showLiveAlerts es false
    if (!showLiveAlerts) return;

    // MODIFICADO: Limitar la frecuencia de actualización para mejorar rendimiento
    const now = Date.now();
    if (now - lastCameraUpdate < CAMERA_UPDATE_INTERVAL) return;
    lastCameraUpdate = now;

    // Obtener las alertas actuales
    const alertsToUse = currentSearchResults !== null ? currentSearchResults :
                       (filteredAlerts !== null ? filteredAlerts : alertas);

    if (!alertsToUse || alertsToUse.length === 0) {
        return;
    }

    // Filtrar solo alertas de los últimos 5 minutos
    const fiveMinutesAgo = now - (5 * 60 * 1000);
    const recentAlerts = alertsToUse.filter(alert => {
        const alertTime = new Date(alert.init_time_frame || alert.epoch_frame).getTime();
        return alertTime >= fiveMinutesAgo;
    });

    // Obtener IDs de cámaras con alertas recientes (≤5 minutos)
    const cameraIdsWithAlerts = new Set();
    recentAlerts.forEach(alert => {
        const cameraId = alert.camera_id || alert.camera_name || alert.cameraname;
        if (cameraId) cameraIdsWithAlerts.add(cameraId);
    });

    // 1. Primero, limpiamos los frames de cámaras que ya no tienen alertas recientes
    for (const cameraId of cameraImageCache.keys()) {
        if (!cameraIdsWithAlerts.has(cameraId)) {
            log(`Limpiando frame obsoleto para la cámara: ${cameraId}`);
            if(expandedFrame){
                expandedFrame = null;
            }
            cameraImageCache.delete(cameraId);
        }
    }
    // 2. Luego, llamamos a nuestra función para obtener todos los frames de una vez
    if (cameraIdsWithAlerts.size > 0) {
        fetchAllCameraFrames(cameraIdsWithAlerts);
    }
}

function fetchAllCameraFrames(camerasWithNewAlerts) {
    // Si no hay cámaras con alertas nuevas, no hacer nada
    if (!camerasWithNewAlerts || camerasWithNewAlerts.size === 0) return;

    // 1. Convierte el Set a un Array y luego a string de cámaras separadas por comas
    const camerasString = [...camerasWithNewAlerts].join(',');
    
    let params = {
        cameras: camerasString
    }
    
    // Llamar al servicio sin parámetros
    callAPI({
        method: 'dashboards/lastframe',
        params: params,
        ok: function (response) {
            // Normalizar la respuesta para manejar ambos casos (array u objeto)
            const dataToEvaluate = Array.isArray(response.items) ? response.items : [response];
            
            // Procesar cada frame en la respuesta
            dataToEvaluate.forEach(frameData => {
                if (!frameData || !frameData.id) {
                    log(`Datos de frame inválidos:`, frameData);
                    return;
                }
                
                const imageData = frameData.foto || frameData.foto_frame;
                
                if (!imageData) {
                    log(`No hay imagen disponible para la cámara ${frameData.id}`);
                    return;
                }

                // MODIFICADO: Optimización para no recargar la misma imagen
                const cachedImage = cameraImageCache.get(frameData.id);
                if (cachedImage && cachedImage.src === imageData) {
                    return; // La imagen ya está en caché y es la misma
                }

                // Crear un nuevo objeto Image
                const img = new Image();
                img.onload = function() {
                    // Imagen cargada, guardarla en el cache
                    cameraImageCache.set(frameData.id, img);
                    // MODIFICADO: Usar throttling para limitar renderizados
                    throttleRender();
                };
                img.onerror = function() {
                    log(`Error al cargar imagen para ${frameData.id}`);
                };
                img.src = imageData;
            });
        },
        error: function (error) {
            log("Error al obtener todos los frames:", error);
        }
    });
}

// AÑADIDO: Función para limitar la frecuencia de renderizado
function throttleRender() {
    const now = Date.now();
    if (now - lastRenderTime >= RENDER_THROTTLE) {
        lastRenderTime = now;
        render();
    }
}

function clearLiveAlertFrames() {
    liveAlertFrames.forEach(frame => {
        if (frame.element && frame.element.parentNode) {
            frame.element.parentNode.removeChild(frame.element);
        }
    });
    liveAlertFrames = [];
    // MODIFICADO: Limpiar también los slots al limpiar los frames
    liveAlertSlots.left = [];
    liveAlertSlots.right = [];
}   

let liveAlertSlots = {
    left: [],
    right: []
};
const MAX_SLOTS_PER_SIDE = 5;

// Nueva variable para controlar el frame expandido
let expandedFrame = null;

// Nuevas constantes para definir el área de los slots
const SLOT_WIDTH = 154;  // Ancho total del slot (frame + márgenes)
const SLOT_HEIGHT = 108; // Alto total del slot
const FRAME_WIDTH = 154;
const FRAME_HEIGHT = 96;
const SLOT_MARGIN = 12;
const TOP_MARGIN = 40;

function drawLiveAlertConnections() {
    const alertsToUse = currentSearchResults !== null ? currentSearchResults :
                       (filteredAlerts !== null ? filteredAlerts : alertas);

    if (!alertsToUse || alertsToUse.length === 0) {
        return;
    }

    const currentTime = new Date().getTime();
    const fiveMinutesAgo = currentTime - (5 * 60 * 1000);

    const cameraAlertTimes = new Map();
    if (alertsToUse && alertsToUse.length > 0) {
        alertsToUse.forEach(alert => {
            if (alert.camera_name || alert.cameraname) {
                const cameraName = alert.camera_name || alert.cameraname;
                const alertTime = new Date(alert.init_time_frame || alert.epoch_frame).getTime();
                const minutesAgo = (currentTime - alertTime) / (1000 * 60);

                if (minutesAgo <= 5) {
                    if (!cameraAlertTimes.has(cameraName) || minutesAgo < cameraAlertTimes.get(cameraName)) {
                        cameraAlertTimes.set(cameraName, minutesAgo);
                    }
                }
            }
        });
    }

    const recentAlertCameras = Array.from(cameraAlertTimes.keys());

    if (recentAlertCameras.length === 0) {
        return;
    }

    const camerasWithAlerts = [];

    recentAlertCameras.forEach(cameraId => {
        const camera = camerasData.find(cam => cam.camera_id === cameraId);
        if (!camera) return;

        let cameraCoords = camera.coords;

        if (!cameraCoords && camera.id_cuadrante) {
            for (const piso of edificio.pisos) {
                for (const ambiente of piso.ambientes) {
                    if (ambiente.tipo === 'cuadrante' && ambiente.id_cuadrante &&
                        ambiente.id_cuadrante.toString() === camera.id_cuadrante.toString()) {

                        const vertices = ambiente.vertices;
                        const xCoords = vertices.map(v => v[0]);
                        const zCoords = vertices.map(v => v[2]);

                        const centerX = (Math.min(...xCoords) + Math.max(...xCoords)) / 2;
                        const centerZ = (Math.min(...zCoords) + Math.max(...zCoords)) / 2;
                        const y = vertices[0][1];

                        cameraCoords = [centerX, y, centerZ];
                        camera.coords = cameraCoords;
                        break;
                    }
                }
                if (cameraCoords) break;
            }
        }

        if (!cameraCoords) {
            const pisoObj = edificio.pisos.find(p => p.nombre === (camera.piso || pisoActivo));
            const altura = pisoObj ? pisoObj.altura : 0;
            cameraCoords = [Math.random() * 100 - 50, altura, Math.random() * 100 - 50];
            camera.coords = cameraCoords;
        }

        const [x, y, z] = cameraCoords;
        const [px, py] = project([x, y, z]);

        const cameraAlerts = alertsToUse.filter(alert =>
            (alert.camera_name || alert.cameraname) === cameraId &&
            (new Date().getTime() - new Date(alert.init_time_frame || alert.epoch_frame).getTime()) <= 5 * 60 * 1000
        );

        camerasWithAlerts.push({
            camera: camera,
            screenX: px,
            screenY: py,
            alerts: cameraAlerts,
            minutesAgo: cameraAlertTimes.get(cameraId)
        });
    });

    // Limpiar slots de cámaras que ya no están activas
    cleanupExpiredSlots(camerasWithAlerts);

    // Asignar cámaras a slots disponibles
    assignCamerasToSlots(camerasWithAlerts);

    // Dibujar frames en sus slots asignados
    drawFramesInSlots();
}

// NUEVA FUNCIÓN: Limpiar slots de cámaras que ya no están activas
function cleanupExpiredSlots(activeCameras) {
    const activeCameraIds = new Set(activeCameras.map(cam => cam.camera.camera_id));

    // Limpiar slots izquierdos
    liveAlertSlots.left = liveAlertSlots.left.filter(slot =>
        slot && activeCameraIds.has(slot.camera.camera_id)
    );

    // Limpiar slots derechos
    liveAlertSlots.right = liveAlertSlots.right.filter(slot =>
        slot && activeCameraIds.has(slot.camera.camera_id)
    );
}

// REVERTIDO: Función para asignar cámaras a slots (lógica original con push)
function assignCamerasToSlots(camerasWithAlerts) {
    const assignedCameras = new Set();

    // Recolectar todas las cámaras ya asignadas
    [...liveAlertSlots.left, ...liveAlertSlots.right].forEach(slot => {
        if (slot) assignedCameras.add(slot.camera.camera_id);
    });

    camerasWithAlerts.forEach(camData => {
        if (assignedCameras.has(camData.camera.camera_id)) return;

        const isLeft = camData.screenX < canvas.width / 2;
        const targetSlots = isLeft ? liveAlertSlots.left : liveAlertSlots.right;

        if (targetSlots.length < MAX_SLOTS_PER_SIDE) {
            targetSlots.push(camData);
            assignedCameras.add(camData.camera.camera_id);
        }
    });
}

// MODIFICADO: Dibujar frames en sus slots asignados
function drawFramesInSlots() {
    // Si hay un frame expandido, dibujarlo y salir
    if (expandedFrame) {
        drawExpandedFrame();
        return;
    }

    // Dibujar slots izquierdos
    liveAlertSlots.left.forEach((camData, index) => {
        if (camData) {
            const slotX = SLOT_MARGIN;
            const slotY = TOP_MARGIN + index * SLOT_HEIGHT;
            
            // Guardar la posición del slot completo para detectar clics
            camData.slotRect = {
                x: slotX,
                y: slotY,
                width: SLOT_WIDTH,
                height: SLOT_HEIGHT
            };
            
            const frameX = slotX + (SLOT_WIDTH - FRAME_WIDTH) / 2;
            const frameY = slotY + (SLOT_HEIGHT - FRAME_HEIGHT) / 2;
            
            drawCameraFrame(camData, frameX, frameY, FRAME_WIDTH, FRAME_HEIGHT, true);
        }
    });

    // Dibujar slots derechos
    liveAlertSlots.right.forEach((camData, index) => {
        if (camData) {
            const slotX = canvas.width - SLOT_WIDTH - SLOT_MARGIN;
            const slotY = TOP_MARGIN + index * SLOT_HEIGHT;
            
            // Guardar la posición del slot completo para detectar clics
            camData.slotRect = {
                x: slotX,
                y: slotY,
                width: SLOT_WIDTH,
                height: SLOT_HEIGHT
            };
            
            const frameX = slotX + (SLOT_WIDTH - FRAME_WIDTH) / 2;
            const frameY = slotY + (SLOT_HEIGHT - FRAME_HEIGHT) / 2;
            
            drawCameraFrame(camData, frameX, frameY, FRAME_WIDTH, FRAME_HEIGHT, false);
        }
    });
}

// Función para normalizar coordenadas al tamaño de la imagen mostrada
function normalizeCoords(coords, imgNaturalWidth, imgNaturalHeight, drawX, drawY, drawWidth, drawHeight) {
    if (!coords) return null;
    
    try {
        // Parsear coordenadas si vienen como string
        const parsedCoords = typeof coords === 'string' ? JSON.parse(coords) : coords;
        
        return parsedCoords.map(coord => {
            const x = (coord[0] / imgNaturalWidth) * drawWidth + drawX;
            const y = (coord[1] / imgNaturalHeight) * drawHeight + drawY;
            return [x, y];
        });
    } catch (e) {
        log("Error normalizando coordenadas:", e);
        return null;
    }
}

// Función para dibujar polígonos con relleno y borde
function drawPolygon(coords, fillColor, strokeColor, fillOpacity = 0.6) {
    if (!coords || coords.length < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(coords[0][0], coords[0][1]);
    
    for (let i = 1; i < coords.length; i++) {
        ctx.lineTo(coords[i][0], coords[i][1]);
    }
    
    ctx.closePath();
    
    // Relleno
    ctx.fillStyle = fillColor.replace(')', `,${fillOpacity})`).replace('rgb', 'rgba');
    ctx.fill();
    
    // Borde
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();
}

// MODIFICADO: Dibujar frame individual de cámara
function drawCameraFrame(camData, frameX, frameY, frameWidth, frameHeight, isLeftSide) {
    const [currentCamX, currentCamY] = project(camData.camera.coords);

    const connectionX = isLeftSide ? frameX + frameWidth : frameX;
    const connectionY = frameY + frameHeight / 2;

    const controlPoint1X = isLeftSide ?
        Math.min(currentCamX, connectionX) - 50 :
        Math.max(currentCamX, connectionX) + 50;
    const controlPoint2X = isLeftSide ?
        Math.max(currentCamX, connectionX) + 50 :
        Math.min(currentCamX, connectionX) - 50;

    ctx.beginPath();
    ctx.moveTo(currentCamX, currentCamY);
    ctx.bezierCurveTo(
        controlPoint1X, currentCamY,
        controlPoint2X, connectionY,
        connectionX, connectionY
    );

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Dibujar área del slot con fondo semitransparente (solo para debug, puedes quitarlo después)
    ctx.fillStyle = 'rgba(100, 100, 100, 0)';
    ctx.fillRect(camData.slotRect.x, camData.slotRect.y, camData.slotRect.width, camData.slotRect.height);

    // Dibujar el frame de la cámara
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.fillRect(frameX, frameY, frameWidth, frameHeight);

    const cachedImage = cameraImageCache.get(camData.camera.id.toString());
    if (cachedImage && cachedImage.complete && cachedImage.naturalWidth !== 0) {
        try {
            ctx.drawImage(cachedImage, frameX, frameY, frameWidth, frameHeight);
        } catch (e) {
            log("Error al dibujar imagen en cache:", e);
        }
    }

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.strokeRect(frameX, frameY, frameWidth, frameHeight);

    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(frameX, frameY + frameHeight - 20, frameWidth, 20);

    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(camData.camera.camera_id, frameX + frameWidth/2, frameY + frameHeight - 8);

    if (camData.alerts.length > 0) {
        const latestAlert = camData.alerts.reduce((latest, current) => {
            const latestTime = new Date(latest.init_time_frame || latest.epoch_frame).getTime();
            const currentTime = new Date(current.init_time_frame || current.epoch_frame).getTime();
            return currentTime > latestTime ? current : latest;
        });

        const now = new Date();
        const options = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const formattedTime = now.toLocaleString('es-PE', options);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(frameX, frameY, frameWidth, 15);

        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(formattedTime, frameX + 5, frameY + 12);

        // AÑADIDO: Resaltar en dorado si la alerta es de una persona de interés
        if (latestAlert.isPersonOfInterest) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.strokeRect(frameX - 2, frameY - 2, frameWidth + 4, frameHeight + 4);
        }
    }
}

let lastAlertIdsData = null;

// MODIFICADO: Dibujar frame expandido
function drawExpandedFrame() {
    const margin = 60;
    const frameX = margin;
    const frameY = margin;
    const frameWidth = canvas.width - 2 * margin;
    const frameHeight = canvas.height - 2 * margin;

    // Guardar la posición del frame expandido para detectar clics de cierre
    expandedFrame.expandedRect = {
        x: frameX,
        y: frameY,
        width: frameWidth,
        height: frameHeight
    };

    // Fondo semitransparente
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dibujar el frame expandido
    ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
    ctx.fillRect(frameX, frameY, frameWidth, frameHeight);

    // Dibujar la imagen de la cámara
    const cachedImage = cameraImageCache.get(expandedFrame.camera.id.toString());
    if (cachedImage && cachedImage.complete && cachedImage.naturalWidth !== 0) {
        try {
            // Calcular dimensiones para mantener la relación de aspecto
            const imgAspect = cachedImage.naturalWidth / cachedImage.naturalHeight;
            const frameAspect = frameWidth / frameHeight;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (imgAspect > frameAspect) {
                // La imagen es más ancha que el frame
                drawWidth = frameWidth;
                drawHeight = frameWidth / imgAspect;
                drawX = frameX;
                drawY = frameY + (frameHeight - drawHeight) / 2;
            } else {
                // La imagen es más alta que el frame
                drawHeight = frameHeight;
                drawWidth = frameHeight * imgAspect;
                drawX = frameX + (frameWidth - drawWidth) / 2;
                drawY = frameY;
            }
            
            ctx.drawImage(cachedImage, drawX, drawY, drawWidth, drawHeight);
            
            // SOLO PARA EVENTOS QUE NO SON PERSONA DESAPARECIDA: dibujar coordenadas
            if (expandedFrame.alerts[0]?.type_event_id !== 16) {
                // Normalizar y dibujar coords_zone (zona restringida)
                if (expandedFrame.alerts[0]?.coords_zone) {
                    const normalizedZone = normalizeCoords(
                        expandedFrame.alerts[0].coords_zone,
                        cachedImage.naturalWidth,
                        cachedImage.naturalHeight,
                        drawX, drawY, drawWidth, drawHeight
                    );
                    if (normalizedZone) {
                        drawPolygon(normalizedZone, 'rgb(0, 100, 255)', 'blue');
                    }
                }
            }
            
        } catch (e) {
            log("Error al dibujar imagen en cache:", e);
        }
    }

    // Borde del frame
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.strokeRect(frameX, frameY, frameWidth, frameHeight);

    // Información de la cámara
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(frameX, frameY + frameHeight - 40, frameWidth, 40);

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(expandedFrame.camera.camera_id, frameX + frameWidth/2, frameY + frameHeight - 20);

    // Información de tiempo y título
    if (expandedFrame.alerts.length > 0) {
        const latestAlert = expandedFrame.alerts.reduce((latest, current) => {
            const latestTime = new Date(latest.init_time_frame || latest.epoch_frame).getTime();
            const currentTime = new Date(current.init_time_frame || current.epoch_frame).getTime();
            return currentTime > latestTime ? current : latest;
        });
    
        const now = new Date();
        const options = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const formattedTime = now.toLocaleString('es-PE', options);
    
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(frameX, frameY, frameWidth, 30);
    
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`${latestAlert.type_event_name} - ${formattedTime}`, frameX + 10, frameY + 20);
    
        // MODIFICADO: PARA PERSONA DESAPARECIDA ENCONTRADA - siempre dibujar
        if (latestAlert.type_event_id === 16) {
            drawPersonPhoto(latestAlert, frameX, frameY, frameWidth);
        }
    
        // Resaltar si es persona de interés
        if (latestAlert.isPersonOfInterest) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.strokeRect(frameX - 3, frameY - 3, frameWidth + 6, frameHeight + 6);
            
            // Añadir texto de persona de interés
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('PERSONA DE INTERÉS', frameX + frameWidth - 10, frameY + 20);
        }
    }

    // Botón de cerrar más grande y visible
    const closeButtonSize = 28;
    const closeButtonX = frameX + frameWidth - closeButtonSize - 10;
    const closeButtonY = frameY + 10;

    // Fondo del botón
    ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
    ctx.fillRect(closeButtonX, closeButtonY, closeButtonSize, closeButtonSize);
    
    // Borde del botón
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(closeButtonX, closeButtonY, closeButtonSize, closeButtonSize);

    // Texto de cerrar
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('×', closeButtonX + closeButtonSize/2, closeButtonY + closeButtonSize/2 + 8);

    // Guardar la posición del botón de cerrar
    expandedFrame.closeButtonRect = {
        x: closeButtonX,
        y: closeButtonY,
        width: closeButtonSize,
        height: closeButtonSize
    };
}

// MODIFICADO: Función para dibujar foto de persona
function drawPersonPhoto(alert, frameX, frameY, frameWidth) {
    const photoSize = 80;
    const photoX = frameX + 20;
    const photoY = frameY + 40;
    const infoX = photoX + photoSize + 15;
    
    // Dibujar contenedor de foto
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillRect(photoX - 1, photoY - 1, photoSize+2, photoSize +2);
    
    // Dibujar contenedor de información
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(infoX-5, photoY, 160, photoSize+2);
    
    // Dibujar información
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    
    let textY = photoY + 15;
    
    if (alert.nombre || alert.apellido) {
        const nombreCompleto = `${alert.nombre || ''} ${alert.apellido || ''}`.trim();
        ctx.fillText(`Nombre: ${nombreCompleto}`, infoX, textY);
        textY += 15;
    }
    
    if (alert.dni) {
        ctx.fillText(`DNI: ${alert.dni}`, infoX, textY);
        textY += 15;
    }
    
    if (alert.edad) {
        ctx.fillText(`Edad: ${alert.edad} años`, infoX, textY);
        textY += 15;
    }
    
    if (alert.person_accuracy) {
        ctx.fillText(`Precisión: ${alert.person_accuracy}%`, infoX, textY);
    }
    
    // Construir la URL correcta para la foto de la persona
    const personImageId = alert.matched_ident || alert.id;
    const photoUrl = `/personimages/inputs/${personImageId}.jpg`;
    
    // Verificar si ya tenemos esta imagen cargada en caché
    const cachedImg = personPhotoCache.get(photoUrl);
    
    //log("Buscando foto de persona en cache:", photoUrl);
    //log("En cache:", cachedImg);
    
    if (cachedImg && cachedImg.complete && cachedImg.naturalWidth !== 0) {
        // Usar imagen en caché - dibujar inmediatamente
        //log("Dibujando foto de persona desde cache");
        drawPersonPhotoImage(cachedImg, photoX, photoY, photoSize);
    } else {
        // Dibujar placeholder mientras carga
        drawPhotoPlaceholder(photoX, photoY, photoSize);
        
        // Solo cargar si no está cargando ya
        if (!personPhotoCache.get(photoUrl + '_loading')) {
            //log("Iniciando carga de foto de persona:", photoUrl);
            loadPersonPhoto(photoUrl, photoX, photoY, photoSize);
        } else {
            //log("La foto ya se está cargando...");
        }
    }
}

// MODIFICADO: Función para cargar la foto de persona
function loadPersonPhoto(photoUrl, photoX, photoY, photoSize) {
    // Marcar como cargando
    personPhotoCache.set(photoUrl + '_loading', true);
    
    const img = new Image();
    
    img.onload = function() {
        //log("Foto de persona cargada exitosamente:", photoUrl);
        // Guardar en caché de personas
        personPhotoCache.set(photoUrl, img);
        // Quitar marca de carga
        personPhotoCache.delete(photoUrl + '_loading');
        
        // FORZAR REDIBUJADO: llamar a drawFramesInSlots para redibujar todo
        drawFramesInSlots();
    };
    
    img.onerror = function() {
        log("Error al cargar la foto de persona:", photoUrl);
        // Quitar marca de carga
        personPhotoCache.delete(photoUrl + '_loading');
        // Redibujar para mostrar el estado de error
        drawFramesInSlots();
    };
    
    // Cargar la imagen
    img.src = photoUrl;
}

// Función para dibujar la imagen de persona
function drawPersonPhotoImage(img, photoX, photoY, photoSize) {
    try {
        const imgAspect = img.naturalWidth / img.naturalHeight;
        let drawWidth, drawHeight, offsetX, offsetY;
        
        if (imgAspect > 1) {
            // Imagen más ancha que alta
            drawWidth = photoSize;
            drawHeight = photoSize / imgAspect;
            offsetX = 0;
            offsetY = (photoSize - drawHeight) / 2;
        } else {
            // Imagen más alta que ancha
            drawHeight = photoSize;
            drawWidth = photoSize * imgAspect;
            offsetX = (photoSize - drawWidth) / 2;
            offsetY = 0;
        }
        
        ctx.drawImage(img, photoX + offsetX, photoY + offsetY, drawWidth, drawHeight);
    } catch (e) {
        log("Error al dibujar imagen de persona:", e);
        drawPhotoPlaceholder(photoX, photoY, photoSize);
    }
}


// Función para dibujar placeholder cuando falla la carga
function drawPhotoPlaceholder(photoX, photoY, photoSize) {
    ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
    ctx.fillRect(photoX, photoY, photoSize, photoSize);
    
    ctx.fillStyle = '#666666';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Foto no disponible', photoX + photoSize/2, photoY + photoSize/2);
}

// Función para resetear el estado de la foto cuando se cierra el frame expandido
function resetExpandedFramePhoto() {
    if(expandedFrame){
        expandedFrame.lastPhotoKey = null;
        expandedFrame.personPhotoDrawn = false;
        // No limpiar personPhotoCache para mantener las fotos en caché
    }
}

// MODIFICADO: Manejar clics en el canvas
function handleCanvasClick(event) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (event.clientX - rect.left) * scaleX;
    const y = (event.clientY - rect.top) * scaleY;

    // Si hay un frame expandido, verificar si se hizo clic en el botón de cerrar
    if (expandedFrame) {
        if (expandedFrame.closeButtonRect && 
            x >= expandedFrame.closeButtonRect.x && 
            x <= expandedFrame.closeButtonRect.x + expandedFrame.closeButtonRect.width &&
            y >= expandedFrame.closeButtonRect.y && 
            y <= expandedFrame.closeButtonRect.y + expandedFrame.closeButtonRect.height) {
            expandedFrame = null;
            resetExpandedFramePhoto();
            return;
        }
        // Si se hace clic fuera del frame expandido, cerrarlo
        if (x < expandedFrame.expandedRect.x || 
            x > expandedFrame.expandedRect.x + expandedFrame.expandedRect.width ||
            y < expandedFrame.expandedRect.y || 
            y > expandedFrame.expandedRect.y + expandedFrame.expandedRect.height) {
            expandedFrame = null;
            resetExpandedFramePhoto();
        }
        return;
    }

    // Verificar si se hizo clic en algún slot (área más grande)
    const allSlots = [...liveAlertSlots.left, ...liveAlertSlots.right];
    for (const slot of allSlots) {
        if (slot.slotRect &&
            x >= slot.slotRect.x && 
            x <= slot.slotRect.x + slot.slotRect.width &&
            y >= slot.slotRect.y && 
            y <= slot.slotRect.y + slot.slotRect.height) {
            expandedFrame = slot;
            return;
        }
    }
}

// Agregar el event listener al canvas (debes llamar esta función una vez al inicializar)
function initCanvasClickListener() {
    canvas.addEventListener('click', handleCanvasClick);
}

let personasUpdateInterval = null;
let movimientoPersonasInterval = null;
let sistemaPersonasActivo = false;

function iniciarSistemaPersonas() {
    if (sistemaPersonasActivo) {
        log("El sistema de personas ya está activo");
        return;
    }
    
    sistemaPersonasActivo = true;
    iniciarMovimientoPersonas();
    iniciarActualizacionPersonas();
}

function detenerSistemaPersonas() {
    sistemaPersonasActivo = false;
    detenerMovimientoPersonas();
    detenerActualizacionPersonas();
    personasEnAmbientes = []; // Opcional: limpiar personas
    render(); // Actualizar para quitar las personas de la vista
}

function iniciarActualizacionPersonas() {
    // Llamar inmediatamente la primera vez
    obtenerPersonasEnAmbientes();
    
    // Configurar intervalo cada 2 segundos
    if (personasUpdateInterval) {
        clearInterval(personasUpdateInterval);
    }
    
    personasUpdateInterval = setInterval(obtenerPersonasEnAmbientes, 2000);
}

function detenerActualizacionPersonas() {
    if (personasUpdateInterval) {
        clearInterval(personasUpdateInterval);
        personasUpdateInterval = null;
    }
}

// ==========================
// Función para obtener personas en ambientes
// ==========================
function obtenerPersonasEnAmbientes() {
    if (!sistemaPersonasActivo) return;
    
    callAPI({
        method: 'dashboards/lastframe',
        ok: function(data) {
            procesarDatosPersonas(data.items);
            render();
            updatePersonCountLegend();
        },
        error: function(error) {
            log("Error al obtener personas en ambientes:", error);
            // En caso de error, mantener las personas existentes
            render();
        }
    });
}

// ==========================
// Función para actualizar leyenda de conteo de personas
// ==========================
function updatePersonCountLegend() {
    const legend = document.getElementById('person-count-legend');
    if(legend.style.display=="none"){
       legend.style.display="block" ;
    }
    if (!legend) return;
    
    const currentTime = Date.now();
    
    log(personasEnAmbientes);
    
    // Filtrar personas activas (menos de 10 segundos)
    const personasActivas = personasEnAmbientes;
    
    // Contar por piso
    const conteoPorPiso = {};
    personasActivas.forEach(persona => {
        const piso = persona.ambiente.piso || 'Desconocido';
        conteoPorPiso[piso] = (conteoPorPiso[piso] || 0) + 1;
    });
    
    let html = '<h4>Personas por piso</h4>';
    
    if (Object.keys(conteoPorPiso).length === 0) {
        html += '<div class="person-count-item">';
        html += '<span class="person-count-label">No hay personas activas</span>';
        html += '<span class="person-count-value">0</span>';
        html += '</div>';
    } else {
        Object.keys(conteoPorPiso).forEach(piso => {
            html += '<div class="person-count-item">';
            html += `<span class="person-count-label">${piso}</span>`;
            html += `<span class="person-count-value">${conteoPorPiso[piso]}</span>`;
            html += '</div>';
        });
    }
    
    const total = personasActivas.length;
    html += `<div class="total-count">Total: ${total} persona(s)</div>`;
    
    legend.innerHTML = html;
}

// ==========================
// Función para procesar datos de personas
// ==========================
function procesarDatosPersonas(data) {
    if (!sistemaPersonasActivo) return;
    
    // Mantener el array existente pero actualizar las personas
    const nuevasPersonas = [];
    
    data.forEach(item => {
        // Si no hay personas, saltar este item
        if (!item.persons || item.persons === 0) {
            return;
        }

        // Buscar la cámara para obtener su cuadrante
        const camara = camerasData.find(cam => cam.camera_id === item.camera_id);
        if (!camara || !camara.id_cuadrante) {
            //log(`Cámara ${item.camera_id} no encontrada o sin cuadrante`);
            return;
        }

        // Buscar el AMBIENTE/SUBZONA del cuadrante
        const ambiente = encontrarAmbientePorCuadrante(camara.id_cuadrante);
        if (!ambiente) {
            //log(`No se encontró ambiente para cuadrante ${camara.id_cuadrante} de cámara ${item.camera_id}`);
            return;
        }

        // Crear las personas para este AMBIENTE con radio más pequeño
        for (let i = 0; i < item.persons; i++) {
            const persona = {
                id: `${item.camera_id}-persona-${i}-${Date.now()}`,
                camera_id: item.camera_id,
                ambiente: ambiente,
                posicion: generarPosicionAleatoriaEnAmbiente(ambiente),
                velocidad: {
                    x: (Math.random() - 0.5) * 0.3,
                    z: (Math.random() - 0.5) * 0.3
                },
                color: generarColorPersona(),
                radio: 0.8 + Math.random() * 0.4, // Radio más pequeño: 0.8-1.2
                nombre: `P${i+1}`,
                direccionCambio: 0,
                timestamp: Date.now()
            };
            nuevasPersonas.push(persona);
        }
    });

    // Reemplazar el array completo
    personasEnAmbientes = nuevasPersonas;
    
    //log(`Personas actualizadas: ${personasEnAmbientes.length}`);
}


// ==========================
// Función para encontrar ambiente por cuadrante
// ==========================
function encontrarAmbientePorCuadrante(idCuadrante) {
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            // Buscar por ID de cuadrante en ambientes de tipo 'subzona'
            if (ambiente.tipo === 'subzona' && ambiente.id_subzona && 
                ambiente.id_subzona.toString() === idCuadrante.toString()) {
                return ambiente;
            }
            // Si no encontramos por id_subzona, buscar por id_cuadrante en subzonas
            if (ambiente.tipo === 'subzona' && ambiente.id_cuadrante && 
                ambiente.id_cuadrante.toString() === idCuadrante.toString()) {
                return ambiente;
            }
        }
    }
    
    // Si no encontramos subzona, buscar cualquier ambiente que contenga el cuadrante
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            if (ambiente.tipo === 'subzona' && ambiente.vertices && ambiente.vertices.length > 0) {
                // Verificar si este ambiente podría contener el cuadrante
                const camara = camerasData.find(cam => cam.id_cuadrante && 
                    cam.id_cuadrante.toString() === idCuadrante.toString());
                if (camara && camara.coords) {
                    const [x, y, z] = camara.coords;
                    const vertices2D = ambiente.vertices.map(v => [v[0], v[2]]);
                    if (pointInPolygon(x, z, vertices2D)) {
                        return ambiente;
                    }
                }
            }
        }
    }
    
    return null;
}

// ==========================
// Función para generar posición aleatoria en ambiente
// ==========================
function generarPosicionAleatoriaEnAmbiente(ambiente) {
    if (!ambiente.vertices || ambiente.vertices.length < 3) {
        // Si no hay vértices válidos, usar posición por defecto
        return [0, ambiente.vertices?.[0]?.[1] || 0, 0];
    }
    
    // Calcular el centro y las dimensiones del ambiente
    const xs = ambiente.vertices.map(v => v[0]);
    const zs = ambiente.vertices.map(v => v[2]);
    
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minZ = Math.min(...zs);
    const maxZ = Math.max(...zs);
    
    // Intentar generar una posición aleatoria dentro del polígono
    let intentos = 0;
    const maxIntentos = 50;
    
    while (intentos < maxIntentos) {
        const x = minX + Math.random() * (maxX - minX);
        const z = minZ + Math.random() * (maxZ - minZ);
        const y = ambiente.vertices[0][1];
        
        // Verificar si el punto está dentro del polígono del ambiente
        const vertices2D = ambiente.vertices.map(v => [v[0], v[2]]);
        if (pointInPolygon(x, z, vertices2D)) {
            return [x, y, z];
        }
        intentos++;
    }
    
    // Si no se pudo encontrar punto dentro del polígono, usar el centro del bounding box
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;
    const y = ambiente.vertices[0][1];
    
    return [centerX, y, centerZ];
}

// ==========================
// Función para generar color aleatorio para persona
// ==========================
function generarColorPersona() {
    const colores = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
    return colores[Math.floor(Math.random() * colores.length)];
}

// ==========================
// Función para iniciar movimiento de personas
// ==========================
function iniciarMovimientoPersonas() {
    if (movimientoPersonasInterval) {
        clearInterval(movimientoPersonasInterval);
    }

    movimientoPersonasInterval = setInterval(() => {
        if (!sistemaPersonasActivo || personasEnAmbientes.length === 0) {
            return;
        }
        actualizarPosicionesPersonas();
        render();
    }, 100);
}
// ==========================
// Función para actualizar posiciones de personas
// ==========================
function actualizarPosicionesPersonas() {
    const ahora = Date.now();
    
    // Eliminar personas muy antiguas (por si acaso)
    personasEnAmbientes = personasEnAmbientes.filter(persona => 
        ahora - persona.timestamp < 30000 // Mantener máximo 30 segundos
    );

    personasEnAmbientes.forEach(persona => {
        // Incrementar contador de cambio de dirección
        persona.direccionCambio++;

        // Cambio aleatorio de dirección cada 30-100 frames (más frecuente)
        if (persona.direccionCambio > 30 + Math.random() * 70) {
            persona.velocidad.x = (Math.random() - 0.5) * 0.3;
            persona.velocidad.z = (Math.random() - 0.5) * 0.3;
            persona.direccionCambio = 0;
        }

        // Mover persona
        const nuevaPosicion = [
            persona.posicion[0] + persona.velocidad.x,
            persona.posicion[1],
            persona.posicion[2] + persona.velocidad.z
        ];

        // Verificar si la nueva posición está dentro del AMBIENTE
        const vertices2D = persona.ambiente.vertices.map(v => [v[0], v[2]]);
        if (pointInPolygon(nuevaPosicion[0], nuevaPosicion[2], vertices2D)) {
            persona.posicion = nuevaPosicion;
        } else {
            // Rebote más suave
            persona.velocidad.x *= -0.6;
            persona.velocidad.z *= -0.6;
            persona.direccionCambio = 0;
        }

        // Variación aleatoria más pequeña
        persona.velocidad.x += (Math.random() - 0.5) * 0.02;
        persona.velocidad.z += (Math.random() - 0.5) * 0.02;

        // Limitar velocidad máxima (más lento)
        const velocidadMax = 0.4;
        const velocidadActual = Math.sqrt(persona.velocidad.x ** 2 + persona.velocidad.z ** 2);
        if (velocidadActual > velocidadMax) {
            persona.velocidad.x = (persona.velocidad.x / velocidadActual) * velocidadMax;
            persona.velocidad.z = (persona.velocidad.z / velocidadActual) * velocidadMax;
        }
    });
}

// ==========================
// Función para detener movimiento de personas
// ==========================
function detenerMovimientoPersonas() {
    if (movimientoPersonasInterval) {
        clearInterval(movimientoPersonasInterval);
        movimientoPersonasInterval = null;
    }
}

function drawPeople() {
    if (!showPeople || personasEnAmbientes.length === 0) return;

    personasEnAmbientes.forEach(persona => {
        const [x, y, z] = persona.posicion;
        const [px, py] = project([x, y, z]);

        // Solo dibujar si está en la pantalla
        if (px < -50 || px > canvas.width + 50 || py < -50 || py > canvas.height + 50) {
            return;
        }

        // Dibujar persona con radio más pequeño
        const radioPantalla = persona.radio * zoom;
        if (radioPantalla < 0.5) return; // No dibujar si es muy pequeño

        ctx.beginPath();
        ctx.arc(px, py, radioPantalla, 0, 2 * Math.PI);
        ctx.fillStyle = persona.color;
        ctx.fill();
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Indicador de dirección (solo si el zoom es suficiente)
        if (zoom > 2) {
            const direccionX = persona.velocidad.x * 8;
            const direccionZ = persona.velocidad.z * 8;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + direccionX, py + direccionZ);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Etiqueta con nombre (solo con zoom suficiente)
        if (zoom > 3) {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(persona.nombre, px, py - radioPantalla - 5);
        }
    });

}
</script>
