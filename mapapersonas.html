<div id="civix-neo">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <style>
    #civix-neo {
      --bg: #061922;
      --panel: #0b1f2a;
      --ink: #b5d6df;
      --ink-strong: #e8fbff;
      --teal: #22e6d9;
      --orange: #ff7a2f;
      --grid: #0e2a36;
    }

    #civix-neo .splash{
      height:70vh; display:flex; flex-direction:column; gap:12px;
      align-items:center; justify-content:center; color:var(--ink-strong);
    }
    
    #civix-neo #dashboard{display:none; height:100vh; width:100vw;}
    #civix-neo .grid{
      display:grid; grid-template-columns:320px 320px auto; gap:12px;
      height:100%; padding:12px;
    }
    #civix-neo .panel{
      background:var(--panel); border-radius:12px; padding:12px; overflow:auto;
      color:var(--ink);
      box-shadow:0 0 0 1px rgba(34,230,217,.06) inset;
      margin-bottom:0px;
    }
/* ------------------------------------------------ */
/* 1. SCROLLBAR COMPLETO (Delgado y Transparente) */
/* ------------------------------------------------ */
#civix-neo .panel::-webkit-scrollbar, 
#vehicleModalContent::-webkit-scrollbar, 
#currentSelectionsContainer::-webkit-scrollbar, 
#multiSelectTableContainer::-webkit-scrollbar, 
#lista-zonas::-webkit-scrollbar, 
.legend-body::-webkit-scrollbar {
  /* Mantiene el ancho delgado */
  width: 7px; 
  height: 7px;
  /* Mantiene el fondo transparente */
  background-color: transparent; 
}

/* ------------------------------------------------ */
/* 2. PISTA (Track) (Sin Fondo) */
/* ------------------------------------------------ */

#civix-neo .panel::-webkit-scrollbar-track, 
#vehicleModalContent::-webkit-scrollbar-track, 
#multiSelectTableContainer::-webkit-scrollbar-track, 
#currentSelectionsContainer::-webkit-scrollbar-track, 
#lista-zonas::-webkit-scrollbar-track, 
.legend-body::-webkit-scrollbar-track {
  background-color: transparent; /* Elimina el fondo de la pista */
}

/* ------------------------------------------------ */
/* 3. PULGAR (Thumb) */
/* ------------------------------------------------ */

#civix-neo .panel::-webkit-scrollbar-thumb, 
#multiSelectTableContainer::-webkit-scrollbar-thumb, 
#currentSelectionsContainer::-webkit-scrollbar-thumb, 
#vehicleModalContent::-webkit-scrollbar-thumb, 
#lista-zonas::-webkit-scrollbar-thumb, 
.legend-body::-webkit-scrollbar-thumb {
  background-color: rgba(136, 136, 136, 0.5); 
  border-radius: 10px;
}
 
/* Opcional: Estilo al pasar el mouse sobre el pulgar */
#civix-neo .panel::-webkit-scrollbar-thumb:hover, 
#multiSelectTableContainer::-webkit-scrollbar-thumb:hover, 
#currentSelectionsContainer::-webkit-scrollbar-thumb:hover, 
#vehicleModalContent::-webkit-scrollbar-thumb:hover, 
#lista-zonas::-webkit-scrollbar-thumb:hover, 
.legend-body::-webkit-scrollbar-thumb:hover {
  background-color: rgba(136, 136, 136, 0.8);
}

/* ------------------------------------------------ */
/* 4. BOTONES (Flechas de navegaci√≥n) üõ†Ô∏è NUEVO ESTILO */
/* ------------------------------------------------ */
#civix-neo .panel::-webkit-scrollbar-button, 
#multiSelectTableContainer::-webkit-scrollbar-button, 
#vehicleModalConten::-webkit-scrollbar-button, 
#currentSelectionsContainer::-webkit-scrollbar-button, 
#lista-zonas::-webkit-scrollbar-button, 
.legend-body::-webkit-scrollbar-button {
  /* Debes definir el tama√±o de los botones para que se muestren */
  height: 7px; /* Debe ser al menos el mismo tama√±o que el 'width' del scrollbar */
  width: 7px;
  
  /* Color de fondo del bot√≥n. Puedes hacerlo transparente */
  background-color: transparent; 
  
  /* Si deseas ocultar las flechas internas pero mantener el espacio: 
     display: none; */
  
  /* Si deseas ver las flechas que el sistema renderiza,
     puedes experimentar con otros estilos. */
}
    #civix-neo h3{ margin:0 0 10px; font-size:16px; color:var(--teal); }

    #multiSelectTableContainer{
        max-height: 400px;
        overflow: auto;
    }
    /* Timeline */
    #civix-neo .timeline {
      list-style: none; 
      margin: 0; 
      padding: 0;
    }
    
    #civix-neo .timeline li {
      cursor: pointer;
      margin: 0;
      padding: 12px 15px 12px 25px;
      position: relative;
      border-left: 2px solid rgba(34,230,217,.2);
      transition: all 0.3s ease;
      background: rgba(11, 31, 42, 0.7);
    }
    /* Mapa oscuro + tinte teal */
    #civix-neo #boardCanvas{width:100%;border-radius:12px;}
    /* Controles */
    #civix-neo .top-right{position:fixed; top: 2em; right: 25.5em; display:none; gap:8px; z-index:1000;}

    /* Modal superpuesto (estilo panel) */
    #civix-neo .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.75); z-index:10000;}
    #civix-neo .modal{
      width:min(920px,95vw); max-height:85vh; overflow:auto; background:var(--panel); border-radius:12px; padding:16px;
      color:var(--ink); box-shadow:0 0 0 1px rgba(255,122,47,.15) inset, 0 0 24px rgba(34,230,217,.1);
    }
    #civix-neo .modal h4{margin:0 0 8px; color:var(--orange);}
    #civix-neo .modal .hdr{display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #143241; padding-bottom:8px; margin-bottom:10px;}
    #civix-neo .modal .x{cursor:pointer; color:var(--ink-strong); font-size:20px;}
    /* Timeline estilo New Map HTML.html */
    
    #civix-neo .timeline li:hover {
      background: rgba(34, 230, 217, 0.1);
      transform: translateX(5px);
    }
    
    #civix-neo .timeline li::before {
      content: "";
      position: absolute;
      left: -7px;
      top: 16px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--teal);
      box-shadow: 0 0 10px var(--teal);
      transition: all 0.3s ease;
    }
    
    #civix-neo .timeline li[data-type*="accidente"]::before {
      background: red;
      box-shadow: 0 0 12px red;
    }
    
    #civix-neo .timeline li[data-type*="aglomeracion"]::before,
    #civix-neo .timeline li[data-type*="restringida"]::before,
    #civix-neo .timeline li[data-type*="zona"]::before {
      background: var(--orange);
      box-shadow: 0 0 12px var(--orange);
    }
    
    #civix-neo .timeline strong {
      color: var(--ink-strong);
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    #civix-neo .timeline time {
      display: block;
      color: #84a9b3;
      font-size: 12px;
      margin-top: 4px;
    }
    
    /* Spinner de carga */
    #civix-neo .spinner {
      margin: 20px auto;
      width: 30px;
      height: 30px;
      border: 3px solid rgba(34, 230, 217, 0.3);
      border-radius: 50%;
      border-top-color: var(--teal);
      animation: spin 1s ease-in-out infinite;
    }
    
    /* MEJORA: Centrar contenido de carga en timeline */
    #civix-neo .timeline .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2em;
      text-align: center;
    }
    
    /* MEJORA: Centrar contenido en modales */
    #interesModalContent .loading,
    #multiSelectModalContent .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      text-align: center;
    }
    
    #interesModalContent{
        margin: auto;
    }
    
    /* MEJORA: Centrar spinner en b√∫squedas */
    #placa-results .loading,
    #caracteristicas-results .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      text-align: center;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Estilos para el modal de video */
    #civix-neo .modal-video {
      overflow: auto;
      background: var(--panel);
      border-radius: 12px;
      color: var(--ink);
      box-shadow: 0 0 0 1px rgba(255,122,47,.15) inset, 0 0 24px rgba(34,230,217,.1);
    }
    
    #civix-neo .modal-content {
      background: var(--panel);
      border-radius: 12px;
      color: var(--ink);
      box-shadow: 0 0 0 1px rgba(255,122,47,.15) inset, 0 0 24px rgba(34,230,217,.1);
      border: none;
    }
    
    #civix-neo .modal-header {
        background: var(--panel);
      border-bottom: 1px solid rgba(181,214,223,0.2);
      padding-bottom: 8px;
      margin-bottom: 10px;
    }
    
    #civix-neo .modal-header h3, 
    #civix-neo .modal-header h5 {
      color: var(--ink);
      margin: 0 0 8px;
    }
    
    .table-hover-1 > tbody > tr:hover{
        border-left:5px solid var(--teal) !important;
    }
    
    #civix-neo .modal-header h3 span, 
    #civix-neo .modal-header h5 span {
      color: var(--teal);
      font-weight: bold;
    }
    
    #civix-neo .modal-header .c-white {
      color: var(--ink-strong) !important;
    }
    
    #civix-neo .modal-body {
      display: flex;
      gap: 20px;
      padding: 16px;
      height: max-content;
    }
    
    #civix-neo .video-player-wrapper {
      flex-grow: 1;
      min-width: 500px;
    }
    
    #civix-neo .person-info-panel {
      width: 280px;
      flex-shrink: 0;
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid rgba(34,230,217,.1);
      color: var(--ink);
    }
    
    #civix-neo .person-info-panel h4 {
      color: var(--orange);
      margin-top: 0;
      border-bottom: 1px solid rgba(181, 214, 223, 0.2);
      padding-bottom: 8px;
      margin-bottom: 12px;
    }
    
    #civix-neo .image-section {
      margin-bottom: 15px
    }
    
    #civix-neo .image-container {
      min-width: 90px;
      margin: auto;
      height: 100px;
      border-radius: 6px;
      background-size: cover;
      background-position: center;
      overflow: hidden;
    }
    
    #civix-neo .image-label {
      font-size: 13px;
      color: var(--ink-strong);
      margin-bottom: 4px;
    }
    
    #civix-neo .modal-footer {
        background: var(--panel);
      border-top: 1px solid rgba(181,214,223,0.2);
      padding: 16px;
      text-align: right;
    }
    
    .btn-default {
      background: var(--teal);
      color: var(--bg);
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    #civix-neo .modal-footer .btn-default:hover {
      background: #1cb5a9;
    }
    
    #civix-neo .alert-details-panel {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 800;
        background: var(--panel);
        padding: 12px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(34, 230, 217, 0.2);
        min-width: 460px;
        max-height: 70vh;
        overflow-y: auto;
        transition: all 0.3s ease;
        display: none;
        color: var(--ink);
    }
    
    #civix-neo .alert-details-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(34, 230, 217, 0.2);
    }
    
    #civix-neo .alert-details-header h4 {
        margin: 0;
        color: var(--teal);
    }
    
    #civix-neo .close-details {
        background: none;
        border: none;
        color: var(--ink);
        font-size: 20px;
        cursor: pointer;
    }
    
    #civix-neo .alert-details-content {
        display: flex;
        gap: 1em;
    }
    
    #civix-neo .detail-item {
        margin-bottom: 8px;
        font-size: 13px;
        flex: 1 1 300px;
    }
    
    #civix-neo .detail-label {
        color: var(--teal);
        font-weight: bold;
        margin-right: 5px;
    }
    
    #civix-neo .person-details-section {
        padding-left: 15px;
        border-left: 1px solid rgba(181, 214, 223, 0.2);
        flex: 1 1 100%;
    }
    
    #civix-neo .person-details-title {
        color: var(--orange);
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 16px;
    }
    
    #civix-neo .person-details-images {
        width: max-content;
        margin: auto;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    #civix-neo .person-image-container {
        position: relative;
        border-radius: 6px;
        overflow: hidden;
        background: var(--bg);
        border: 1px solid rgba(34, 230, 217, 0.1);
        height: 150px;
        width: 150px;
    }
    
    #civix-neo .person-image-label {
        font-size: 11px;
        padding: 4px;
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        position: absolute;
        bottom: 0;
        width: 100%;
    }
    
    #civix-neo .person-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background-size: cover;
        background-position: center;
    }
    
    #civix-neo .person-name {
        font-weight: bold;
        color: var(--teal);
        margin-bottom: 10px;
        padding: 12px;
        background: rgba(34, 230, 217, 0.1);
        border-radius: 4px;
    }
    
    #civix-neo .alert-details-footer {
        margin-top: 1em;
        text-align: right;
        flex: 1 1 100%;
    }
    /* M√©tricas */
    .metric-container {
        padding: 10px 0;
    }
    
    .metric-list {
        margin-top: 5px;
    }
    
    .metric-list-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        padding: 3px 0;
        border-bottom: 1px solid rgba(34, 230, 217, 0.1);
    }
    
    .metric-list-label {
        font-size: 11px;
        color: var(--ink);
        overflow: hidden;
        max-width: 70%;
    }
    
    .metric-list-value {
        font-size: 12px;
        font-weight: bold;
        color: var(--teal);
    }
    
    .system-metric {
        margin-bottom: 10px;
        text-align: center;
    }
    
    .system-metric-label {
        font-size: 11px;
        color: var(--ink);
        margin-bottom: 3px;
    }
    
    .system-metric-value {
        font-size: 14px;
        font-weight: bold;
        color: var(--teal);
    }
    
    .no-data {
        text-align: center;
        color: var(--ink);
        font-size: 11px;
        padding: 10px 0;
    }
    
    .kpi-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .kpi-header{
        display: flex;
        justify-content: space-between;
    }
    
    .bar-chart-container {
        padding: 10px 0;
    }
    
    .bar-label {
        font-size: 11px;
        color: var(--ink);
        width: 40%;
        overflow: hidden;
    }
    
    .bar-chart {
        flex-grow: 1;
        margin-left: 10px;
        background: rgba(34, 230, 217, 0.1);
        border-radius: 2px;
        overflow: hidden;
    }
    
    .bar-fill {
        height: 15px;
        background: var(--teal);
        border-radius: 2px;
        transition: width 0.5s ease;
    }
    
    .bar-value {
        font-size: 11px;
        color: var(--teal);
        margin-left: 8px;
        font-weight: bold;
        min-width: 30px;
        text-align: right;
    }
    
    /* Nuevos estilos para el gr√°fico de tipos de alerta */
    .alert-type-item, .bar-item, .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: var(--transition);
    }
    .alert-type-item:hover, .bar-item:hover, .legend-item:hover {
      background: rgba(34, 230, 217, 0.1);
    }
    
    .alert-type-label {
      font-size: 11px;
      color: var(--ink);
      width: 40%;
    }
    
    .alert-type-chart {
      flex-grow: 1;
      margin-left: 10px;
      background: rgba(34, 230, 217, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .alert-type-fill {
      height: 15px;
      border-radius: 2px;
      transition: width 0.5s ease;
    }
    
    .alert-type-value {
      font-size: 11px;
      margin-left: 8px;
      font-weight: bold;
      min-width: 30px;
      text-align: right;
    }
    
    /* Colores para diferentes tipos de alertas */
    .alert-type-fill.teal {
      background: var(--teal);
    }
    
    .alert-type-fill.orange {
      background: var(--orange);
    }
    
    .alert-type-fill.red {
      background: var(--teal);
    }
    
    .alert-type-value.teal {
      color: var(--teal);
    }
    
    .alert-type-value.orange {
      color: var(--orange);
    }
    
    .alert-type-value.red {
      color: var(--teal);
    }

  /* Estilos para el bot√≥n de limpiar filtros */
  .clear-filters-btn {
        background: var(--orange);
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        width: 100%;
        margin-bottom: 15px;
        text-align: center;
        opacity: 0;
        transform: translateY(-10px);
        height: 0;
        padding: 0;
        overflow: hidden;
        display: none;
    }
    
    .clear-filters-btn.visible {
        display: block;
        animation: filterBtnPopup 0.5s ease forwards;
        height: auto;
        padding: 10px 15px;
    }
    
    @keyframes filterBtnPopup {
        0% {
            opacity: 0;
            transform: translateY(-10px);
        }
        70% {
            transform: translateY(5px);
        }
        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .clear-filters-btn:hover {
        background: #e66625;
    }
    
    .clear-filters-btn:disabled {
        background: #84a9b3;
        cursor: not-allowed;
    }

  /* Estilos para la leyenda del mapa */
  #civix-neo .map-legend {
    position: absolute;
    bottom: 1.5em;
    background: var(--panel);
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(34, 230, 217, 0.2);
    z-index: 800;
    max-width: 250px;
    left:1.2em;
  }

  #civix-neo .map-legend.minimized .legend-body {
    display: none;
  }

  #civix-neo .legend-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    cursor: pointer;
  }

  #civix-neo .legend-title {
    color: var(--teal);
    font-weight: bold;
    margin: 0;
  }

  #civix-neo .legend-toggle {
    background: none;
    border: none;
    color: var(--ink);
    font-size: 16px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
    
    .legend-item.active {
        background: rgba(34, 230, 217, 0.15);
    }
    
    .legend-item-content {
        display: flex;
        align-items: center;
        flex: 1;
    }

  #civix-neo .legend-dot {
    min-width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
  }

  #civix-neo .all-dot {
    background-color: var(--teal);
    box-shadow: 0 0 5px var(--teal);
  }

  #civix-neo .teal-dot {
    background-color: var(--teal);
    box-shadow: 0 0 5px var(--teal);
  }

  #civix-neo .red-dot {
    background-color: red;
    box-shadow: 0 0 5px red;
  }

  #civix-neo .orange-dot {
    background-color: var(--orange);
    box-shadow: 0 0 5px var(--orange);
  }

  #civix-neo .legend-label {
    font-size: 12px;
    color: var(--ink-strong);
  }

  #civix-neo .legend-count {
    font-size: 12px;
    color: var(--ink);
    background: rgba(0, 0, 0, 0.3);
    padding: 2px 6px;
    border-radius: 10px;
    min-width: 24px;
    text-align: center;
  }
  /* A√±ade estos estilos al bloque de estilo existente */
    .interes-item:hover {
        background-color: rgba(34, 230, 217, 0.1);
    }
    
    #searchInteres:focus {
        outline: none;
        border-color: var(--teal);
        box-shadow: 0 0 0 2px rgba(34, 230, 217, 0.2);
    }
    #civix-neo .interes-item:hover {
        background-color: rgba(34, 230, 217, 0.1);
    }
    #civix-neo th {
        color: var(--teal);
    }
    /* Estilos para los controles de filtro del mapa */
    #civix-neo .map-filters {
      position: absolute;
      top: 20px;
      left: 20px;
      background: var(--panel);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(34, 230, 217, 0.2);
      z-index: 800;
      max-width: 200px;
    }
    
    #civix-neo .map-filters h4 {
      color: var(--teal);
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: bold;
    }
    
    #civix-neo .filter-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    #civix-neo .filter-item {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.3s ease;
    }
    
    #civix-neo .filter-item:hover {
      background: rgba(34, 230, 217, 0.1);
    }
    
    #civix-neo .filter-item input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--teal);
    }
    
    #civix-neo .filter-item label {
      font-size: 12px;
      color: var(--ink-strong);
      cursor: pointer;
      margin: 0;
    }
    /* Estilos para el gr√°fico de tendencia */
    .trend-chart {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        height: 100% !important;
        margin-top: 5px;
    }
    
    .trend-bar-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100%;
        position: relative;
    }
    
    .trend-bar {
        width: 12px;
        background-color: var(--teal);
        border-radius: 3px 3px 0 0;
        margin-bottom: 5px;
        transition: height 0.5s ease;
    }
    
    .trend-label {
        font-size: 9px;
        color: var(--ink);
        text-align: center;
    }
    
    .trend-value {
        font-size: 10px;
        color: var(--teal);
        font-weight: bold;
        margin-bottom: 2px;
    }
    
    .trend-icon {
        font-size: 14px;
        font-weight: bold;
        margin-top: 2px;
    }
    
    .trend-title {
        font-weight: bold;
        border-bottom: 1px solid rgba(34, 230, 217, 0.3);
        padding-bottom: 4px;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    /* Ajustes para el contenido de las pesta√±as */
    #civix-neo #vehicleModalContent{
        max-height: 600px;
        overflow: hidden;
    }
    
    /* Estilos para la nueva leyenda de estado de c√°maras */
    #civix-neo .camera-status-legend {
      position: absolute;
      top: 13em;
      left: 1.5em;
      background: var(--panel);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(34, 230, 217, 0.2);
      z-index: 800;
      max-width: 280px;
    }
    
    #civix-neo .camera-status-legend h4 {
      color: var(--teal);
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: bold;
    }
    
    #civix-neo .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      color: var(--ink-strong);
    }
    
    #civix-neo .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    #civix-neo .status-dot.alertCamera {
      background: #FFD700; /* Dorado para c√°maras con alertas */
      box-shadow: 0 0 8px #FFD700;
    }
    
    #civix-neo .status-dot.normal {
      background: red; /* Rojo para c√°maras normales */
      box-shadow: 0 0 5px red;
    }
    
    #civix-neo .status-dot.vehicle {
      background: var(--orange); /* Naranja para c√°maras vehiculares */
    }
    
    #civix-neo .status-label {
      flex: 1;
    }
    
    #civix-neo .status-count {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 10px;
      min-width: 24px;
      text-align: center;
      font-size: 11px;
    }
    #selectedPersonBox {
        transition: all 0.3s ease;
    }
    /* A√±adir al final del bloque de estilos */
    .multi-select-item {
        cursor: pointer;
        transition: background-color 0.3s ease;
    }
    
    .multi-select-item:hover {
        background-color: rgba(34, 230, 217, 0.1);
    }
    
    .multi-select-item td {
        padding: 8px;
        border-bottom: 1px solid rgba(34,230,217,0.2);
    }
    .multiSelectModalContent{
        width: 100%;
    }
    
    /* Estilos para el contenedor de personas seleccionadas */
    #selected-persons-container {
        background: var(--panel);
        border-radius: 8px;
        padding: 12px;
        border: 1px solid rgba(34,230,217,0.2);
        margin-top: 20px;
    }
    
    #current-selections-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .selection-placeholder {
        text-align: center;
        color: var(--ink);
        font-size: 14px;
        padding: 20px;
        font-style: italic;
    }
    
    .selection-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid rgba(34,230,217,0.2);
        transition: background-color 0.3s ease;
    }
    
    .selection-item:hover {
        background-color: rgba(34, 230, 217, 0.1);
    }
    
    .selection-item-info {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
    }
    
    .selection-item-photo {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        object-fit: cover;
    }
    
    .selection-item-details {
        flex: 1;
    }
    
    .selection-item-name {
        color: var(--ink-strong);
        font-size: 14px;
        font-weight: bold;
    }
    
    .selection-item-document {
        color: var(--ink);
        font-size: 12px;
    }
    
    .btn-remove-selection {
        background: none;
        border: none;
        color: var(--orange);
        cursor: pointer;
        font-size: 16px;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background-color 0.3s ease;
    }
    
    .btn-remove-selection:hover {
        background-color: rgba(255, 122, 47, 0.1);
    }
    
    /* Estilos para el panel de personas de inter√©s en el mapa */
    #civix-neo .selected-persons-map-panel {
        position: absolute;
        top: 3em;
        right: 0;
        background: var(--panel);
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(34, 230, 217, 0.2);
        z-index: 800;
        max-width: 200px;
        transition: all 0.3s ease;
    }
    
    #civix-neo .selected-persons-map-panel.minimized {
        max-height: 40px;
        overflow: hidden;
    }
    
    #civix-neo .selected-persons-map-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        cursor: pointer;
    }
    
    #civix-neo .selected-persons-map-title {
        color: var(--teal);
        font-weight: bold;
        margin: 0;
        font-size: 14px;
    }
    
    #civix-neo .selected-persons-map-toggle {
        background: none;
        border: none;
        color: var(--ink);
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* CAMBIO PRINCIPAL: Cambiar a dise√±o vertical */
    #civix-neo .selected-persons-map-body {
        display: flex;
        flex-direction: column; /* Cambiado de row a column */
        gap: 8px;
        max-height: 200px;
        overflow-y: auto;
    }
    
    #civix-neo .selected-person-photo {
        width: 50px;
        height: 50px;
        border-radius: 8px;
        object-fit: cover;
        border: 2px solid transparent;
        transition: all 0.3s ease;
        cursor: pointer;
        margin: auto; /* A√±adido margen vertical para separaci√≥n */
    }
    
    /* MEJORA: Aumentar el espacio del resaltado */
    #civix-neo .selected-person-photo.active-alert {
        border: 3px solid #FFD700; /* Aumentado de 2px a 3px */
        box-shadow: 0 0 12px #FFD700; /* Aumentado el blur */
        animation: pulse-gold 1s infinite;
        padding: 2px; /* A√±adido padding interno para m√°s espacio */
        background-color: rgba(255, 215, 0, 0.1); /* Fondo sutil para m√°s √©nfasis */
    }
    
    @keyframes pulse-gold {
        0% { 
            box-shadow: 0 0 5px #FFD700; 
            border-width: 3px;
        }
        50% { 
            box-shadow: 0 0 18px #FFD700; /* Aumentado el efecto de pulso */
            border-width: 4px; /* Aumenta ligeramente el borde durante el pulso */
        }
        100% { 
            box-shadow: 0 0 5px #FFD700;
            border-width: 3px;
        }
    }
    
    /* Estilos para el selector de piso */
    #civix-neo select, #txtFechaIni, #txtFechaFin{
        background: var(--panel);
        border: 1px solid var(--teal);
        color: var(--ink);
        border-radius: 4px;
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
    }
    
    #civix-neo #selectPiso:focus {
        outline: none;
        border-color: var(--orange);
        box-shadow: 0 0 0 2px rgba(255, 122, 47, 0.2);
    }
    
    #civix-neo #selectPiso option {
        background: var(--panel);
        color: var(--ink);
    }
    #civix-neo .panel {
  background: rgba(11, 31, 42, 0.9); /* Solo transparencia alpha */
  border-radius: 12px; 
  padding: 12px; 
  overflow: auto;
  color: var(--ink);
  box-shadow: 0 0 0 1px rgba(34,230,217,.06) inset;
  margin-bottom: 0px;
}

/* Panel del canvas - mantener completamente opaco para m√°ximo rendimiento */
#civix-neo .panel:last-child {
  background: var(--panel); /* #0b1f2a s√≥lido */
}

/* Elementos superpuestos en el mapa con transparencia ligera */
#civix-neo .map-legend,
#civix-neo .map-filters,
#civix-neo .camera-status-legend,
#civix-neo .selected-persons-map-panel {
  background: rgba(11, 31, 42, 0.6);
}

/* Panel de detalles de alerta */
#civix-neo .alert-details-panel {
  background: rgba(11, 31, 42, 0.6);
}

/* Modales */
#civix-neo .modal,
#civix-neo .modal-video {
  background: rgba(11, 31, 42,1);
}

/* Overlay - mantener transparencia */
#civix-neo .overlay {
  background: rgba(0, 0, 0, 0.6);
}
    
    
    /* A√±adir al final del bloque de estilos existente */

/* Nueva leyenda de conteo de personas */
#civix-neo .person-count-legend {
  position: absolute;
  top: 20em;
  right: 1.5em;
  background: var(--panel);
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(34, 230, 217, 0.2);
  z-index: 800;
  max-width: 200px;
  max-height: 300px;
  overflow-y: auto;
}

#civix-neo .person-count-legend h4 {
  color: var(--teal);
  margin: 0 0 10px 0;
  font-size: 14px;
  font-weight: bold;
  border-bottom: 1px solid rgba(34, 230, 217, 0.3);
  padding-bottom: 5px;
}

#civix-neo .person-count-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
  font-size: 12px;
  color: var(--ink-strong);
  padding: 4px 0;
  border-bottom: 1px solid rgba(34, 230, 217, 0.1);
}

#civix-neo .person-count-label {
  flex: 1;
}

#civix-neo .person-count-value {
  background: rgba(0, 0, 0, 0.3);
  padding: 2px 8px;
  border-radius: 10px;
  min-width: 24px;
  text-align: center;
  font-weight: bold;
  color: var(--teal);
}

#civix-neo .total-count {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(34, 230, 217, 0.3);
  font-weight: bold;
}

/* A√±adir al bloque de estilos existente */
#civix-neo .persona-marker {
    filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.8));
}

#civix-neo .persona-marker.moving {
    filter: drop-shadow(0 0 5px rgba(34, 230, 217, 0.8));
}
  </style>

 <div class="splash" id="splash">
    <h2 style="color:var(--ink-strong)">Monitor de Personas</h2>
    <button id="enter" class="btn btn-accent">Ingresar al Dashboard</button>
  </div>
    <!--
  <div class="top-right" id="controls">
    <button id="exit" class="btn btn-accent">Salir de pantalla completa</button>
  </div>
  -->

  <div id="dashboard">
    <div class="grid">
        <div class="panel">
            <div id="busquedaContent">
                <div id="selected-persons-container" style="margin-bottom:20px; border-top: 1px solid rgba(34,230,217,0.2); padding-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="color: var(--teal); margin: 0;">Personas de Inter√©s Seleccionadas</h4>
                        <button type="button" class="btn btn-default" data-search-type="personas-interes" 
                            style="padding: 8px 12px; font-size: 12px;">
                            Seleccionar
                        </button>
                    </div>
                    <div id="current-selections-list">
                        <!-- Las selecciones se cargar√°n aqu√≠ din√°micamente -->
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: auto; gap: 10px; margin-bottom: 15px;">
                    <button type="button" class="btn btn-default" data-search-type="personas">
                        B√∫squeda de Personas
                    </button>
                    <button type="button" class="btn btn-default" data-search-type="vehiculos">
                        B√∫squeda de Veh√≠culos
                    </button>
                    <button type="button" class="btn btn-default" data-search-type="placa">
                        B√∫squeda Por Placa de veh√≠culos
                    </button>
                    <button type="button" class="btn btn-default" data-search-type="caracteristicas">
                        B√∫squeda por caracter√≠sticas
                    </button>
                </div>
                
                <!-- Por este: -->
                <div id="selectedPersonBox" style="display: none; background: var(--panel); padding: 12px; margin-bottom: 12px; border-radius: 8px; border: 1px solid rgba(34,230,217,0.2);">
                    <div id="selectedPersonDetails"></div>
                </div>
                <!-- Formulario de b√∫squeda por placa -->
                <div id="placa-search-form" class="search-form" style="display: none;">
                    <h4>B√∫squeda por Placa</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="text" id="placa-input" placeholder="Ingrese n√∫mero de placa" 
                            style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
                        <button type="button" class="btn btn-accent" id="search-placa-btn">Buscar</button>
                    </div>
                    <div id="placa-results"></div>
                </div>
                            
                <!-- Formulario de b√∫squeda por caracter√≠sticas -->
                <div id="caracteristicas-search-form" class="search-form" style="display: none;">
                    <h4>B√∫squeda por Caracter√≠sticas</h4>
                        <div style="display: grid; grid-template-columns: 48% 48%; gap: 10px; margin-bottom: 15px;">
                            <div>
                                <label>Sexo</label>
                                <div class=form-group>
                                    <select id="txtsexo" class="form-control">
                                        <option value="all" selected>Seleccione sexo</option>
                                        <option value=0>Mujer</option>
                                        <option value=1>Hombre</option>
                                    </select>
                                </div>
                            </div>
                            <div>
                                <div class=form-group>
                                    <label>Color Prenda Superior</label>
                                            <select id="txtcolorsup" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <div class=form-group>
                                            <label>Color Prenda Inferior</label>
                                            <select id="txtcolorinf" class="form-control">
                                                <option value="all" selected>Seleccione color</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label>Edad</label>
                                        <div class=form-group>
                                            <select id="txtedad" class="form-control">
                                                <option value="all" selected>Seleccione Rango</option>
                                                <option value=0>0-2 a√±os</option>
                                                <option value=1>3-6 a√±os</option>
                                                <option value=2>7-13 a√±os</option>
                                                <option value=3>14-22 a√±os</option>
                                                <option value=4>23-35 a√±os</option>
                                                <option value=5>36-46 a√±os</option>
                                                <option value=6>47-56 a√±os</option>
                                                <option value=7>57-100 a√±os</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div>
                                        <label for="txtFechaIni">Fecha Inicio</label>
                                        <div class="form-group ">
                                            <input id="txtFechaIni" type="date" class="form-control">
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label for="txtFechaFin">Fecha Fin</label>
                                        <div class="form-group ">
                                            <input id="txtFechaFin" type="date" class="form-control">
                                        </div>
                                    </div>
                                    <div style="grid-column: 1 / span 2;">
                                        <label>Zonas/Subzonas</label>
                                        <div class="form-group">
                                            <button type="button" class="btn btn-default" id="btnSeleccionarZonas" 
                                                    style="width: 100%; text-align: left; background: var(--panel); border: 1px solid var(--teal); color: var(--ink); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                                Seleccionar Zonas/Subzonas
                                            </button>
                                            <div id="zonas-seleccionadas" style="margin-top: 5px; font-size: 12px; color: var(--ink);">
                                                No hay zonas seleccionadas
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button type="button" class="btn btn-accent" id="search-caracteristicas-btn" style="width: 100%;">Buscar por Caracter√≠sticas</button>
                                <div id="caracteristicas-results" style="margin-top: 15px;"></div>
                            </div>
                            
                            <!-- Contenedor para resultados de listas (personas/veh√≠culos) -->
                            <div id="search-results"></div>
                    
                            <!-- NUEVO: Contenedor de personas seleccionadas en la parte inferior -->
                            
                        </div>
        </div>
        
        <div class="panel">
          <h3>Alertas en tiempo real (√öltimas 4 horas)</h3>
            <div style="margin-bottom: 1em;">
                <button id="btnBackToAll" class="btn btn-accent" style="width: 100%; display: none;">Volver a todas las alertas</button>
            </div>
            
          <ul class="timeline" id="timelineList">
            <div style="text-align:center;margin:2em;">
              <!--
              <div class="spinner"></div>
              <div>Cargando alertas...</div>
              -->
              <div>
                  Puedes realizar la b√∫squeda de personas
              </div>
            </div>
          </ul>
        </div>

      <div class="panel" style="overflow-y:hidden; position:relative">
            <canvas id="boardCanvas"  width="900" height="600"  style="border:1px solid #333; width:100%; height:95vh; cursor: grab;"></canvas>
            <div style="display:flex; gap:1em; margin-bottom:1em;position: absolute;top: 1.5em;right: 1.5em;">
              <select id="selectPiso" class="form-select">
                <option value="ALL">Todos los pisos</option>
                <option value="S1">S√≥tano 1</option>
                <option value="S2">S√≥tano 2</option>
                <option value="S3">S√≥tano 3</option>
                <option value="1">Piso 1</option>
                <option value="2">Piso 2</option>
                <option value="3">Piso 3</option>
                <option value="4">Piso 4</option>
                <option value="5">Piso 5</option>
              </select>
              <button id="btnAutoRotate" class="btn btn-accent mb-2">Rotaci√≥n autom√°tica: OFF</button>
              <div class="selected-persons-map-panel" id="selected-persons-map-panel">
                <div class="selected-persons-map-header">
                    <div class="selected-persons-map-title">Personas de Inter√©s</div>
                    <button class="selected-persons-map-toggle">‚àí</button>
                </div>
                <div class="selected-persons-map-body" id="selected-persons-map-body">
                    <div class="selection-placeholder">No hay personas seleccionadas</div>
                </div>
              </div>
            </div>
            <div class="map-filters" id="map-filters">
              <h4>Mostrar en mapa</h4>
              <div class="filter-group">
                <div class="filter-item">
                  <input type="checkbox" id="show-cameras" checked="">
                  <label for="show-cameras">C√°maras</label>
                </div>
                <div class="filter-item">
                  <input type="checkbox" id="show-zones" checked>
                  <label for="show-zones">Zonas</label>
                </div>
                <div class="filter-item">
                  <input type="checkbox" id="show-subzones" checked>
                  <label for="show-subzones">Subzonas</label>
                </div>
                <div class="filter-item">
                  <input type="checkbox" id="show-routes" checked>
                  <label for="show-routes">Rutas</label>
                </div>
              </div>
            </div>
            <div class="camera-status-legend" id="camera-status-legend">
              <h4>Estado de C√°maras</h4>
              <div class="status-item">
                <span class="status-dot alertCamera"></span>
                <span class="status-label">Con alertas registradas</span>
                <span class="status-count" id="alert-cameras-count">0</span>
              </div>
              <div class="status-item">
                <span class="status-dot normal"></span>
                <span class="status-label">C√°maras</span>
                <span class="status-count" id="normal-cameras-count">0</span>
              </div>
            </div>
            <div class="person-count-legend" id="person-count-legend">
              <h4>Personas por Piso</h4>
              <div id="person-count-list">
                <div class="person-count-item">
                  <span class="person-count-label">Cargando...</span>
                  <span class="person-count-value">0</span>
                </div>
              </div>
              <div class="total-count" id="total-person-count">
                Total: 0 personas
              </div>
            </div>
               <div class="alert-details-panel" id="alert-details">
                  <div class="alert-details-header">
                     <h4 class="alert-details-title" id="alert-details-title">Detalles de Alerta</h4>
                     <button class="close-details">&times;</button>
                  </div>
                  <div class="alert-details-content" id="alert-details-content"></div>
                  <div class="alert-details-footer">
                     <button id="view-video-btn" class="btn btn-accent">Ver Video</button>
                  </div>
                </div>
      </div>

        
    </div>
  </div>

  <div class="overlay" id="ovl" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="hdr">
        <h4 id="mtitle">Detalle de alerta</h4>
        <span class="x" id="mclose">&times;</span>
      </div>
      <div id="mbody">...</div>
    </div>
  </div>
  
  <!-- Modal para mostrar videos (similar al 2D) -->
    <div class="overlay" id="videoOvl" aria-hidden="true" style="display: none;">
      <div class="modal-video" role="dialog" aria-modal="true">
        <div class="modal-content">
          <div class="modal-header text-left" style="display: flex;justify-content: space-between;">
              <div style="width:100%">
                <span class="c-white" style="float:right" id="showtime"></span>
                <h3>Identificador: <span class="c-white" id="showId"></span></h3>
                <h5>Alerta: <span class="c-white" id="showAlert"></span></h5>
                <h5>C√°mara: <span class="c-white" id="showcamera"></span></h5>
                <h5>Ubicaci√≥n: <span class="c-white" id="showUbication"></span></h5>
                <div id="showlocation"></div>
              </div>
            <div id="photo-short" style="display:none; width:100% justify-content:end; gap: 1em;">
                  <div class="image-section" style="overflow:hidden;">
                    <div class="image-label">Detecci√≥n Recortada</div>
                    <div class="image-container" id="cropped-detection"></div>
                  </div>
                  <div class="image-section" id="photo-name" >
                    <div class="image-label">Foto de Referencia</div>
                    <div class="image-container" id="person-photo"></div>
                  </div>
              </div>
          </div>
          
          <div class="modal-body">
            <div class="video-player-wrapper" style="height:400px;"></div>  
            <div class="person-info-panel" id="person-info-panel" style="display: none;">
              <h4>Detecci√≥n</h4>
              <div id="person-data" style=""></div>
            </div>
          </div>
          
          <div class="modal-footer">
            <button type="button" class="btn btn-default btn-rounded" id="closeVideoModal">Cerrar</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="overlay" id="interesOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="interesModalTitle">B√∫squeda Avanzada - Personas de Inter√©s</h4>
                </div>
                <div class="modal-body">
                    <!-- Contenido directo sin pesta√±as -->
                    <div id="interesModalContent">
                        <div class="loading">Cargando personas de inter√©s...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="closeInteresModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Nuevo modal para selecci√≥n m√∫ltiple -->
    <div class="overlay" id="multiSelectOvl" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header text-left">
                    <h4 id="multiSelectModalTitle">Selecci√≥n de Personas de Inter√©s</h4>
                </div>
                <div class="modal-body">
                    <div id="multiSelectModalContent">
                        <div class="loading">Cargando personas de inter√©s...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default btn-rounded" id="saveMultiSelection">Guardar Selecci√≥n</button>
                    <button type="button" class="btn btn-default btn-rounded" id="closeMultiSelectModal">Cerrar</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NUEVO: Modal para selecci√≥n de zonas/subzonas - CORREGIDO -->
    <div class="overlay" id="zonasModal" aria-hidden="true" style="display: none;">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h4>Seleccionar Zonas/Subzonas</h4>
                </div>
                <div class="modal-body">
                    <div style="width:100%">
                        <!-- A√ëADIR BOT√ìN DE SELECCIONAR TODAS -->
                        <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                            <input type="text" id="filterZonas" placeholder="Buscar zonas..." 
                                   style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
                            <button type="button" class="btn btn-default" id="btnSelectAllZonas" 
                                    style="padding: 8px 12px; white-space: nowrap;">
                                Seleccionar Todas
                            </button>
                        </div>
                        <div id="lista-zonas" style="max-height: 350px; overflow-y: auto;">
                            <div class="loading">Cargando zonas...</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer" style="border-top: 1px solid rgba(181,214,223,0.2); padding: 16px; text-align: right;">
                    <button type="button" class="btn btn-default btn-rounded" id="btnAplicarZonas">Aplicar</button>
                    <button type="button" class="btn btn-default btn-rounded" id="btnLimpiarZonas" style="background: var(--orange);">Limpiar</button>
                    <button type="button" class="btn btn-default btn-rounded" id="btnCerrarZonas">Cerrar</button>
                </div>
            </div>
        </div>
    </div>

</div>


<script>
      
let tempSelectedItems = [];
const hoy = new Date();
const ayer = new Date(hoy);
ayer.setDate(hoy.getDate() - 1);
const formatear = d => {
    const limaDate = new Date(d);
    limaDate.setHours(limaDate.getUTCHours() - 5);
    return limaDate.toISOString().split('T')[0];
};

$('#txtFechaIni').val(formatear(ayer));
$('#txtFechaFin').val(formatear(hoy));
    
// --- Fullscreen flow
const enterBtn = document.querySelector('#civix-neo #enter');
//const exitBtn = document.querySelector('#civix-neo #exit');
const splash = document.getElementById('splash');
const dashboard = document.getElementById('dashboard');
//const controls = document.getElementById('controls');
const appRoot = document.getElementById('civix-neo');
let forceShowCamera = null;
let selectedInteresItem = null;

// Variable para almacenar el intervalo de actualizaci√≥n
let alertasInterval = null;
let busqueda = null;
let showCameras = true;
let showZones = true;
let showRoutes = true;

// ==========================
// Variables para controlar el estado de b√∫squeda
// ==========================
let currentSearchType = null; // 'placa', 'caracteristicas', 'interes', null
let currentSearchResults = null;

// ==========================
// Variables para KPI est√°tico
// ==========================
let initialAlerts = []; // Almacena las alertas iniciales (sin filtros)
let lastKPUpdate = null; // Timestamp de √∫ltima actualizaci√≥n de KPIs
let kpiTrendData = []; // Datos para el gr√°fico de tendencia

// ==========================
// Variables para personas detectadas en frames
// ==========================
let personasEnFrames = []; // Array de personas detectadas
let frameDetectionInterval = null;
const FRAME_UPDATE_INTERVAL = 2000; // 2 segundos
let lastFrameUpdate = 0;

// Configuraci√≥n para visualizaci√≥n de personas - REDUCIDO EL RADIO
const configPersonasFrame = {
    radioPersona: 1.5, // Reducido de 3 a 1.5
    colorPersona: "#22e6d9",
    colorResaltado: "#FFD700",
    duracionResaltado: 10000
};

let personasPorCamara = new Map();

enterBtn.addEventListener('click', async () => {
  try {
    if (!document.fullscreenElement) await appRoot.requestFullscreen({navigationUI: 'hide'});
  } catch (_) {}
  splash.style.display = 'none'; 
  dashboard.style.display = 'block'; 
  
  // Reinicializar par√°metros de renderizado
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  zoom = configTablero.zoomInicial;
  yaw = 0 * Math.PI/180;
  pitch = configTablero.pitchInicial * Math.PI/180;
  
  // Cerrar el panel de detalles de alerta al ingresar al dashboard
  const alertDetails = document.getElementById('alert-details');
  if (alertDetails) {
    alertDetails.style.display = 'none';
  }
  
  // Resetear variables relacionadas con alertas seleccionadas
  highlightedCamera = null;
  forceShowCamera = null;
  selectedAlert = null;
  
  // Limpiar resaltado de alertas
  alertHighlightedCameras = {};
  
  // INICIAR OBTENCI√ìN DE FRAMES CADA 2 SEGUNDOS
  if (frameDetectionInterval) {
    clearInterval(frameDetectionInterval);
  }
  frameDetectionInterval = setInterval(obtenerFramesPersonas, FRAME_UPDATE_INTERVAL);
  
  // Obtener primeros frames inmediatamente
  obtenerFramesPersonas();
  
  // Forzar renderizado inicial
  render();
  
  // Iniciar animaci√≥n
  animate();
});


/*
exitBtn.addEventListener('click', () => {
  if(document.fullscreenElement) document.exitFullscreen();
  hideDash();
});
*/
document.addEventListener('keydown', e => {
  if(e.key==='Escape' && document.fullscreenElement){ document.exitFullscreen(); hideDash(); }
});

document.addEventListener('fullscreenchange', () => { 
  if(!document.fullscreenElement) {
    hideDash(); 
  } else {
    // Re-iniciar animaci√≥n cuando se vuelve a fullscreen
    if (dashboard.style.display === 'block') {
      animate();
    }
  }
});

// ==========================
function hideDash(){
    // RESETEO DE B√öSQUEDAS ACTIVAS
    currentSearchType = null;
    currentSearchResults = null;
    
    // Ocultar formularios de b√∫squeda
    document.getElementById('placa-search-form').style.display = 'none';
    document.getElementById('caracteristicas-search-form').style.display = 'none';
    document.getElementById('search-results').innerHTML = '';
    
    // Limpiar inputs de b√∫squeda
    document.getElementById('placa-input').value = '';
    document.getElementById('txtFechaIni').value = '';
    document.getElementById('txtFechaFin').value = '';
    document.getElementById('txtsexo').value = 'all';
    document.getElementById('txtcolorsup').value = 'all';
    document.getElementById('txtcolorinf').value = 'all';
    document.getElementById('txtedad').value = 'all';
    
    // Resto del c√≥digo existente...
    dashboard.style.display='none';
    splash.style.display='flex';
    
    closeModal();
    
    personasEnFrames = [];
    
    // DETENER INTERVALO DE FRAMES
    if (frameDetectionInterval) {
        clearInterval(frameDetectionInterval);
        frameDetectionInterval = null;
    }
    
    // Cerrar el panel de detalles de alerta al salir del dashboard
    const alertDetails = document.getElementById('alert-details');
    if (alertDetails) {
        alertDetails.style.display = 'none';
    }

    // Detener animaci√≥n de ruta
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }
    
    currentRoute = null;
    routeAnimationProgress = 0;
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }

    // ==========================
    // RESETEO COMPLETO DEL ESTADO
    // ==========================
    
    alertas = [];
    filteredAlerts = null;
    currentFilter = 'all';
    lastAlertIds = new Set();
    filteredCamerasByInteres = null;
    
    // LIMPIAR VARIABLES DE B√öSQUEDA
    currentSearchType = null;
    currentSearchResults = null;
    
    // LIMPIAR VARIABLES DE RUTA
    currentRoute = null;
    routeAnimationProgress = 0;
    
    // Resetear selecciones de interfaz
    highlightedCamera = null;
    forceShowCamera = null;
    selectedInteresItem = null;
    selectedAlert = null;
    
    // Limpiar resaltado permanente de alertas
    alertHighlightedCameras = {};
  
  // Cerrar y resetear modal de inter√©s si est√° abierto
  if (interesOvl.style.display !== 'none') {
    interesOvl.style.display = 'none';
    document.getElementById('interesModalContent').innerHTML = '<div class="loading">Cargando...</div>';
  }
  
  // Cerrar y resetear modal de video si est√° abierto
  if (videoOvl.style.display !== 'none') {
    closeVideoModal();
  }
  
  // RESET CR√çTICO: Limpiar el canvas y forzar re-renderizado
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  render();

  // Ocultar el panel de persona seleccionada y restaurar el bot√≥n de b√∫squeda avanzada
  document.getElementById('selectedPersonBox').style.display = 'none';
  document.getElementById('btnBackToAll').style.display = 'none';
  document.getElementById('selectedPersonDetails').innerHTML = 'Seleccione una persona o veh√≠culo para continuar.';
  
  // Restaurar el t√≠tulo del timeline
  document.querySelector('.panel h3').textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
}

// ==========================
// Funci√≥n para actualizar leyenda de conteo de personas
// ==========================
function updatePersonCountLegend() {
    const legend = document.getElementById('person-count-legend');
    if (!legend) return;
    
    const currentTime = Date.now();
    
    // Filtrar personas activas (menos de 10 segundos)
    const personasActivas = personasEnFrames.filter(persona => 
        currentTime - persona.timestamp <= 10000
    );
    
    // Contar por piso
    const conteoPorPiso = {};
    personasActivas.forEach(persona => {
        const piso = persona.piso || 'Desconocido';
        conteoPorPiso[piso] = (conteoPorPiso[piso] || 0) + 1;
    });
    
    let html = '<h4>Personas Detectadas</h4>';
    
    if (Object.keys(conteoPorPiso).length === 0) {
        html += '<div class="person-count-item">';
        html += '<span class="person-count-label">No hay personas activas</span>';
        html += '<span class="person-count-value">0</span>';
        html += '</div>';
    } else {
        Object.keys(conteoPorPiso).forEach(piso => {
            html += '<div class="person-count-item">';
            html += `<span class="person-count-label">${piso}</span>`;
            html += `<span class="person-count-value">${conteoPorPiso[piso]}</span>`;
            html += '</div>';
        });
    }
    
    const total = personasActivas.length;
    html += `<div class="total-count">Total: ${total} persona(s)</div>`;
    
    legend.innerHTML = html;
}

// --- Modal de la aplicaci√≥n
const modal = document.querySelector("#civix-neo .modal");
const overlay = document.getElementById("ovl");
const mtitle = document.getElementById("mtitle");
const mbody = document.getElementById("mbody");
const mclose = document.getElementById("mclose");

function showModal(title, content) {
    mtitle.textContent = title;
    mbody.innerHTML = content;
    overlay.style.display = 'flex';
}

function closeModal() {
    overlay.style.display = 'none';
}

mclose.addEventListener('click', closeModal);
overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
        closeModal();
    }
});


// Timeline ‚Üí centra y abre modal

// ==========================
// Configuraci√≥n del tablero
// ==========================
const configTablero = {
  grid: true,
  gridSize: 20,
  colorFondo: "#061922",
  colorLineas: "#ff7a2f88",
  zoomInicial: 1.5,
  pitchInicial: -20
};

// ==========================
// JSON del edificio
// ==========================
let edificio = {
  "pisos": [
    // --- S√≥tanos ---
    {
      "nombre": "S√≥tano 1",
      "altura": -40,
      "ambientes": [
        { "nombre": "Estacionamientos S1", "color": "#aaaaaa",
          "vertices": [[-100,-40,-60],[100,-40,-60],[100,-40,60],[-100,-40,60]] },
        { "nombre": "Bombas de agua", "color": "#8888ff",
          "vertices": [[-40,-40,20],[-20,-40,20],[-20,-40,40],[-40,-40,40]] },
        { "nombre": "Bombas de agua2", "color": "#8888ff",
          "vertices": [[40,-40,20],[20,-40,20],[20,-40,40],[40,-40,40]] }
      ]
    },
    {
      "nombre": "S√≥tano 2",
      "altura": -80,
      "ambientes": [
        { "nombre": "Estacionamientos S2", "color": "#999999",
          "vertices": [[-100,-80,-60],[100,-80,-60],[100,-80,60],[-100,-80,60]] },
        { "nombre": "Cuarto el√©ctrico", "color": "#ffcc00",
          "vertices": [[-40,-80,-40],[-20,-80,-40],[-20,-80,-20],[-40,-80,-20]] }
      ]
    },
    {
      "nombre": "S√≥tano 3",
      "altura": -120,
      "ambientes": [
        { "nombre": "Estacionamientos S3", "color": "#888888",
          "vertices": [[-100,-120,-60],[100,-120,-60],[100,-120,60],[-100,-120,60]] },
        { "nombre": "Servidores / Generadores", "color": "#cc0000",
          "vertices": [[20,-120,20],[60,-120,20],[60,-120,60],[20,-120,60]] }
      ]
    },
    // --- Piso 1 ---
    {
      "nombre": "Piso 1",
      "altura": 0,
      "ambientes": [
        { "nombre": "Piso 1", "color": "#b8b8b8",
          "vertices": [[-100,0,-60],[100,0,-60],[100,0,60],[-100,0,60]]},
        { "nombre": "Recepci√≥n", "color": "#66aaff",
          "vertices": [[60,0,-60],[90,0,-60],[90,0,-30],[60,0,-30]] },
        { "nombre": "Sala de espera", "color": "#99ccff",
          "vertices": [[90,0,-60],[120,0,-60],[120,0,-30],[90,0,-30]] },
        { "nombre": "Jard√≠n frontal", "color": "#77dd77",
          "vertices": [[-100,0,-80],[120,0,-80],[120,0,-60],[-100,0,-60]] },
        { "nombre": "Estacionamientos", "color": "#aaaaaa",
          "vertices": [[-100,0,0],[120,0,0],[120,0,40],[-100,0,40]] },
        { "nombre": "Ba√±os Piso 1", "color": "#66ccff",
          "vertices": [[-60,0,0],[-40,0,0],[-40,0,20],[-60,0,20]] },
        { "nombre": "Salida Emergencia P1", "color": "#ff3333",
          "vertices": [[-100,0,20],[-90,0,20],[-90,0,40],[-100,0,40]] }
      ]
    },
    // --- Pisos 2, 3 y 4 ---
    ...[40,80,120].map((altura,i)=>({
      "nombre": "Piso "+(i+2),
      "altura": altura,
      "ambientes": [
        { "nombre": "Piso "+(i+2), "color": "#b8b8b8",
          "vertices": [[-100,altura,-60],[100,altura,-60],[100,altura,60],[-100,altura,60]]},
        { "nombre": "Recepci√≥n", "color": "#66aaff",
          "vertices": [[60,altura,-60],[90,altura,-60],[90,altura,-30],[60,altura,-30]] },
        { "nombre": "Sala de espera", "color": "#99ccff",
          "vertices": [[90,altura,-60],[120,altura,-60],[120,altura,-30],[90,altura,-30]] },
        { "nombre": "Oficina del Presidente", "color": "#cc9966",
          "vertices": [[-90,altura,0],[-60,altura,0],[-60,altura,30],[-90,altura,30]] },
        { "nombre": "Oficina de Contabilidad", "color": "#ffcc66",
          "vertices": [[-60,altura,-30],[-30,altura,-30],[-30,altura,0],[-60,altura,0]] },
        { "nombre": "Sala de Reuniones", "color": "#ff9966",
          "vertices": [[-90,altura,-60],[-30,altura,-60],[-30,altura,-30],[-90,altura,-30]] },
        { "nombre": "Jefe de Marketing", "color": "#cc6699",
          "vertices": [[30,altura,0],[60,altura,0],[60,altura,30],[30,altura,30]] },
        { "nombre": "Jefe de Personal", "color": "#993366",
          "vertices": [[60,altura,0],[90,altura,0],[90,altura,30],[60,altura,30]] },
        { "nombre": "Ba√±os", "color": "#66ccff",
          "vertices": [[-90,altura,30],[-60,altura,30],[-60,altura,60],[-90,altura,60]] },
        { "nombre": "Salida Emergencia", "color": "#ff3333",
          "vertices": [[-100,altura,20],[-90,altura,20],[-90,altura,40],[-100,altura,40]] }
      ]
    })),
    // --- Piso 5 ---
    {
      "nombre": "Piso 5",
      "altura": 160,
      "ambientes": [
        { "nombre": "Piso 5", "color": "#b8b8b8",
          "vertices": [[-100,160,-60],[100,160,-60],[100,160,60],[-100,160,60]]},
        { "nombre": "Oficinas ejecutivas", "color": "#cc6699",
          "vertices": [[-80,160,-40],[0,160,-40],[0,160,40],[-80,160,40]] },
        { "nombre": "Sala de directorio", "color": "#993366",
          "vertices": [[0,160,-40],[80,160,-40],[80,160,0],[0,160,0]] },
        { "nombre": "Terraza", "color": "#77dd77",
          "vertices": [[0,160,0],[80,160,0],[80,160,40],[0,160,40]] },
        { "nombre": "Ba√±os Piso 5", "color": "#66ccff",
          "vertices": [[-90,160,0],[-70,160,0],[-70,160,20],[-90,160,20]] },
        { "nombre": "Salida Emergencia P5", "color": "#ff3333",
          "vertices": [[-100,160,20],[-90,160,20],[-90,160,40],[-100,160,40]] }
      ]
    }
  ]
};

// ==========================
// Par√°metros de c√°mara
// ==========================
const canvas = document.getElementById("boardCanvas");
const ctx = canvas.getContext("2d");

let yaw = 0 * Math.PI/180;
let pitch = configTablero.pitchInicial * Math.PI/180;
let zoom = configTablero.zoomInicial;
let offsetX = 0;
let offsetY = 0;

let autoRotate = true;
let rotateSpeed = 0.003;

let screenPolygons=[];
let pisoActivo="ALL";
let highlightedAmbiente = null;
let highlightedCamera = null; // C√°mara seleccionada manualmente
let alertHighlightedCameras = {}; // C√°maras con alertas recientes
let alertHighlightTimers = {};

let camerasData = []; // Variable global para almacenar las c√°maras
let filteredCamerasByInteres = null;
let currentRoute = null;
let routeAnimation = null;
let routeAnimationProgress = 0;

// ==========================
// Funciones utilitarias
// ==========================
function rotateY([x,y,z], a){ const c=Math.cos(a),s=Math.sin(a); return [x*c+z*s,y,-x*s+z*c]; }
function rotateX([x,y,z], a){ const c=Math.cos(a),s=Math.sin(a); return [x,y*c-z*s,y*s+z*c]; }
function project([x,y,z]){
  [x,y,z] = rotateY([x,y,z], yaw);
  [x,y,z] = rotateX([x,y,z], pitch);
  const d=600;
  const scale=(d*zoom)/(d+z);
  return [x*scale+offsetX, -y*scale+offsetY];
}
function hexToRgba(hex, alpha=0.5){
  const bigint=parseInt(hex.replace("#",""),16);
  const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

function filterCamerasByInteres(itemBusqueda) {
    // Primero obtener las alertas relacionadas con este inter√©s
    callAPI({
        method: 'gestion/getalerts',
        params: {
            camera_name: "UTEC",
            ...(itemBusqueda.matched_plate && { matched_plate: itemBusqueda.matched_plate }),
            ...(itemBusqueda.id && { matched_ident: itemBusqueda.id })
        },
        ok: function (vals) {
            const alertasInteres = vals.data;
            
            // **MODIFICADO: Solo filtrar c√°maras si hay alertas**
            if (alertasInteres && alertasInteres.length > 0) {
                // Extraer nombres √∫nicos de c√°maras de las alertas
                const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];
                
                // Filtrar las c√°maras que coinciden con estos nombres
                filteredCamerasByInteres = camerasData.filter(cam => 
                    cameraNames.includes(cam.camera_id)
                );
            } else {
                // **MODIFICADO: Si no hay alertas, no mostrar c√°maras filtradas**
                filteredCamerasByInteres = [];
                alertHighlightedCameras = {};
            }
            
            // Forzar re-renderizado del mapa
            render();
        },
        error: function (error) {
            log("Error al obtener alertas para filtrar c√°maras:", error);
            // En caso de error, no mostrar c√°maras filtradas
            filteredCamerasByInteres = [];
            alertHighlightedCameras = {};
            render();
        }
    });
}

// ==========================
// Funci√≥n para transformar el JSON del edificio - COMPLETAMENTE MODIFICADA
// ==========================
function transformarNuevoEdificio(nuevoJSON) {
    let edificioTransformado = {  // Cambiar const por let
        pisos: []
    };

    // Verificar que hay datos
    if (!nuevoJSON || nuevoJSON.length === 0) {
        log("No hay datos de edificio en la respuesta");
        return obtenerEdificioEjemplo();
    }

    const area = nuevoJSON[0];
    
    if (!area.zonas || area.zonas.length === 0) {
        log("No hay zonas en el √°rea");
        return obtenerEdificioEjemplo();
    }
    
    // Mapear zonas a pisos
    area.zonas.forEach((zona) => {
        // Calcular altura basada en el nombre del piso
        let altura = 0;
        const nombrePiso = zona.nombre_zona;
        
        // Asignar altura seg√∫n el nombre del piso
        if (nombrePiso.includes('S√≥tano') || nombrePiso.includes('Sotano')) {
            if (nombrePiso.includes('1')) altura = -40;
            else if (nombrePiso.includes('2')) altura = -80;
            else if (nombrePiso.includes('3')) altura = -120;
            else altura = -40;
        } else if (nombrePiso.includes('Piso')) {
            if (nombrePiso.includes('1')) altura = 0;
            else if (nombrePiso.includes('2')) altura = 40;
            else if (nombrePiso.includes('3')) altura = 80;
            else if (nombrePiso.includes('4')) altura = 120;
            else if (nombrePiso.includes('5')) altura = 160;
            else altura = 0;
        }
        
        const pisoTransformado = {
            nombre: nombrePiso,
            altura: altura,
            ambientes: []
        };

        // PRIMERO: Crear ambiente para la ZONA completa
        if (zona.poligono_zona) {
            let verticesZona;
            try {
                verticesZona = JSON.parse(zona.poligono_zona);
                if (!Array.isArray(verticesZona) || verticesZona.length === 0) {
                    throw new Error("Pol√≠gono de zona no es un array v√°lido");
                }
            } catch (e) {
                console.error('Error al parsear pol√≠gono de zona:', zona.poligono_zona, e);
                verticesZona = calcularBoundingBoxDeSubzonas(zona.subzonas);
            }

            // Aplicar la altura correcta a todos los v√©rtices
            const verticesZona3D = verticesZona.map(vertice => {
                if (Array.isArray(vertice) && vertice.length === 2) {
                    return [vertice[0], pisoTransformado.altura, vertice[1]];
                } else if (Array.isArray(vertice) && vertice.length === 3) {
                    return [vertice[0], pisoTransformado.altura, vertice[2]];
                }
                return vertice;
            });

            const ambienteZona = {
                nombre: `${zona.nombre_zona}`,
                color: '#aaaaaa',
                vertices: verticesZona3D,
                id_zona: zona.id_zona,
                tipo: 'zona'
            };

            pisoTransformado.ambientes.push(ambienteZona);
        }

        // SEGUNDO: Mapear subzonas a ambientes
        if (zona.subzonas && zona.subzonas.length > 0) {
            zona.subzonas.forEach(subzona => {
                let vertices;
                try {
                    vertices = JSON.parse(subzona.poligono_subzona);
                    if (!Array.isArray(vertices) || vertices.length === 0) {
                        throw new Error("Pol√≠gono de subzona no es un array v√°lido");
                    }
                } catch (e) {
                    console.error('Error al parsear pol√≠gono de subzona:', subzona.poligono_subzona, e);
                    vertices = [[-10, -10], [10, -10], [10, 10], [-10, 10]];
                }

                // Aplicar la misma altura del piso a las subzonas
                const vertices3D = vertices.map(vertice => {
                    if (Array.isArray(vertice) && vertice.length === 2) {
                        return [vertice[0], pisoTransformado.altura, vertice[1]];
                    } else if (Array.isArray(vertice) && vertice.length === 3) {
                        return [vertice[0], pisoTransformado.altura, vertice[2]];
                    }
                    return vertice;
                });

                const ambienteSubzona = {
                    nombre: subzona.nombre_subzona || `Subzona ${subzona.id_subzona}`,
                    color: generarColorAleatorio(),
                    vertices: vertices3D,
                    id_subzona: subzona.id_subzona,
                    tipo: 'subzona',
                    piso: pisoTransformado.nombre
                };

                pisoTransformado.ambientes.push(ambienteSubzona);
                
                // TERCERO: Mapear cuadrantes dentro de las subzonas - MEJORADO
                if (subzona.cuadrantes && subzona.cuadrantes.length > 0) {
                    subzona.cuadrantes.forEach(cuadrante => {
                        if (cuadrante.puntos_cuadrante && cuadrante.puntos_cuadrante.length > 0) {
                            let verticesCuadrante;
                            
                            try {
                                // Procesar puntos del cuadrante
                                let puntos = cuadrante.puntos_cuadrante;
                                if (typeof puntos === 'string') {
                                    puntos = JSON.parse(puntos);
                                }
                                
                                if (!Array.isArray(puntos)) {
                                    puntos = [puntos];
                                }
                                
                                // Convertir a formato 3D con altura correcta
                                verticesCuadrante = puntos.map(punto => {
                                    if (Array.isArray(punto) && punto.length >= 2) {
                                        return [punto[0], pisoTransformado.altura, punto[1]];
                                    } else if (punto.x !== undefined && punto.y !== undefined) {
                                        return [punto.x, pisoTransformado.altura, punto.y];
                                    } else if (punto.lat !== undefined && punto.lon !== undefined) {
                                        return [punto.lat, pisoTransformado.altura, punto.lon];
                                    } else {
                                        // Punto por defecto si no se puede procesar
                                        const centro = calcularCentroSubzona(subzona);
                                        return [centro[0], pisoTransformado.altura, centro[2]];
                                    }
                                });
                                
                            } catch (e) {
                                console.error('Error al procesar puntos de cuadrante:', cuadrante.puntos_cuadrante, e);
                                // Crear un √°rea peque√±a alrededor del centro de la subzona
                                const centro = calcularCentroSubzona(subzona);
                                verticesCuadrante = [
                                    [centro[0]-2, pisoTransformado.altura, centro[2]-2],
                                    [centro[0]+2, pisoTransformado.altura, centro[2]-2],
                                    [centro[0]+2, pisoTransformado.altura, centro[2]+2],
                                    [centro[0]-2, pisoTransformado.altura, centro[2]+2]
                                ];
                            }

                            const ambienteCuadrante = {
                                nombre: cuadrante.nombre_cuadrante || `Cuadrante ${cuadrante.id_cuadrante}`,
                                color: generarColorAleatorio(),
                                vertices: verticesCuadrante,
                                id_cuadrante: cuadrante.id_cuadrante,
                                id_subzona: subzona.id_subzona,
                                tipo: 'cuadrante',
                                piso: pisoTransformado.nombre
                            };

                            pisoTransformado.ambientes.push(ambienteCuadrante);
                        }
                    });
                }
            });
        }

        edificioTransformado.pisos.push(pisoTransformado);
    });
    
    // NUEVO: Aplicar normalizaci√≥n completa a todo el edificio
    edificioTransformado = normalizarCoordenadasEdificio(edificioTransformado);
    
    log("Edificio transformado y normalizado:", edificioTransformado);
    return edificioTransformado;
}

// NUEVA FUNCI√ìN: Calcular centro de subzona para cuadrantes fallback
function calcularCentroSubzona(subzona) {
    if (subzona.poligono_subzona) {
        try {
            const vertices = JSON.parse(subzona.poligono_subzona);
            if (Array.isArray(vertices) && vertices.length > 0) {
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                
                vertices.forEach(vertice => {
                    const x = Array.isArray(vertice) ? (vertice[0] || 0) : 0;
                    const z = Array.isArray(vertice) ? (vertice[1] || 0) : 0;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                });
                
                return [(minX + maxX) / 2, 0, (minZ + maxZ) / 2];
            }
        } catch (e) {
            console.error('Error al calcular centro de subzona:', e);
        }
    }
    return [0, 0, 0];
}
function obtenerEdificioEjemplo() {
    return {
        "pisos": [
            {
                "nombre": "S√≥tano 1",
                "altura": -40,
                "ambientes": [
                    { 
                        "nombre": "Estacionamientos S1", 
                        "color": "#aaaaaa",
                        "vertices": [[-100,-40,-60],[100,-40,-60],[100,-40,60],[-100,-40,60]] 
                    }
                ]
            },
            {
                "nombre": "Piso 1", 
                "altura": 0,
                "ambientes": [
                    { 
                        "nombre": "Piso 1", 
                        "color": "#b8b8b8",
                        "vertices": [[-100,0,-60],[100,0,-60],[100,0,60],[-100,0,60]]
                    }
                ]
            }
            // ... otros pisos b√°sicos
        ]
    };
}

// ==========================
// Funci√≥n para calcular posici√≥n central en un ambiente
// ==========================
function calcularPosicionEnAmbiente(ambiente) {
    if (!ambiente || !ambiente.vertices || ambiente.vertices.length === 0) {
        return null;
    }
    
    const vertices = ambiente.vertices;
    const xCoords = vertices.map(v => v[0]);
    const zCoords = vertices.map(v => v[2]);
    
    const centerX = (Math.min(...xCoords) + Math.max(...xCoords)) / 2;
    const centerZ = (Math.min(...zCoords) + Math.max(...zCoords)) / 2;
    const y = vertices[0][1]; // Altura del piso
    
    return [centerX, y, centerZ];
}

// ==========================
// Funci√≥n para calcular el bounding box de las subzonas
// ==========================
function calcularBoundingBoxDeSubzonas(subzonas) {
    if (!subzonas || subzonas.length === 0) {
        return [[-10, -10], [10, -10], [10, 10], [-10, 10]];
    }

    let minX = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxZ = -Infinity;

    subzonas.forEach(subzona => {
        if (subzona.poligono_subzona) {
            try {
                const vertices = JSON.parse(subzona.poligono_subzona);
                if (Array.isArray(vertices)) {
                    vertices.forEach(vertice => {
                        const x = vertice[0] || 0;
                        const z = vertice[1] || 0;
                        minX = Math.min(minX, x);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxZ = Math.max(maxZ, z);
                    });
                }
            } catch (e) {
                console.error('Error al parsear subzona para bounding box:', e);
            }
        }
    });

    // Si no se encontraron coordenadas v√°lidas, usar valores por defecto
    if (minX === Infinity) {
        return [[-10, -10], [10, -10], [10, 10], [-10, 10]];
    }

    // Agregar un margen
    const margin = 5;
    return [
        [minX - margin, minZ - margin],
        [maxX + margin, minZ - margin],
        [maxX + margin, maxZ + margin],
        [minX - margin, maxZ + margin]
    ];
}

function generarColorAleatorio() {
    const colores = [
        '#66aaff', '#99ccff', '#cc9966', '#ffcc66', '#ff9966', 
        '#cc6699', '#993366', '#66ccff', '#ff5252', '#77dd77',
        '#aaaaaa', '#8888ff', '#ffcc00', '#cc0000', '#b8b8b8',
        '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4',
        '#8BC34A', '#FF5722', '#607D8B', '#795548', '#E91E63'
    ];
    return colores[Math.floor(Math.random() * colores.length)];
}

function actualizarSelectorPisos() {
    const selectPiso = document.getElementById('selectPiso');
    
    if (!selectPiso) {
        log("Selector de pisos no encontrado");
        return;
    }
    
    // Limpiar opciones existentes (manteniendo "Todos los pisos")
    const allOption = selectPiso.querySelector('option[value="ALL"]');
    selectPiso.innerHTML = '';
    if (allOption) {
        selectPiso.appendChild(allOption);
    } else {
        const defaultOption = document.createElement('option');
        defaultOption.value = "ALL";
        defaultOption.textContent = "Todos los pisos";
        selectPiso.appendChild(defaultOption);
    }
    
    // Agregar opciones basadas en las zonas del edificio
    if (edificio.pisos && edificio.pisos.length > 0) {
        edificio.pisos.forEach(piso => {
            const option = document.createElement('option');
            option.value = piso.nombre;
            option.textContent = piso.nombre;
            selectPiso.appendChild(option);
        });
    } else {
        log("No hay pisos para mostrar en el selector");
    }
}

// ==========================
// Dibujo del edificio y c√°maras
// ==========================
// ==========================
function drawEdificio(){
    screenPolygons = [];
    
    // Verificar que el edificio est√© cargado
    if (!edificio || !edificio.pisos || edificio.pisos.length === 0) {
        // Dibujar mensaje de carga si no hay datos
        ctx.fillStyle = "var(--teal)";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Cargando edificio...", canvas.width/2, canvas.height/2);
        return;
    }
    
    // Calcular el conjunto de c√°maras con alertas a partir de las alertas actuales
    const currentAlerts = filteredAlerts !== null && filteredAlerts.length >= 0 ? filteredAlerts : alertas;
    const camerasWithAlerts = new Set();
    currentAlerts.forEach(alert => {
        if (alert.camera_name) {
            camerasWithAlerts.add(alert.camera_name);
        }
    });

    // PRIMERO: Dibujar todos los elementos del edificio (zonas y subzonas)
    if (showZones && showSubzones) {
        for (const piso of edificio.pisos){
            if(pisoActivo !== "ALL" && piso.nombre !== pisoActivo) continue;

            // Dibujar las ZONAS (fondo)
            for (const amb of piso.ambientes){
                if (amb.tipo !== 'zona') continue;
                
                // VERIFICAR: Que la zona pertenezca a este piso
                if (amb.piso && amb.piso !== piso.nombre) {
                    console.warn(`Zona ${amb.nombre} no pertenece al piso ${piso.nombre}`);
                    continue;
                }
                
                const poly2D = amb.vertices.map(v => project(v));

                // Pol√≠gono de ZONA (fondo m√°s oscuro)
                ctx.beginPath();
                poly2D.forEach(([px,py],i) => { 
                    if(i === 0) ctx.moveTo(px,py); 
                    else ctx.lineTo(px,py); 
                });
                ctx.closePath();
                
                ctx.fillStyle = hexToRgba(amb.color, 0.3);
                ctx.fill();
                ctx.strokeStyle = amb.color;
                ctx.lineWidth = 1;
                ctx.stroke();

                screenPolygons.push({amb, poly2D, piso});

                // Texto de las ZONAS (m√°s grande y centrado)
                let cx=0, cy=0, cz=0;
                for(const v of amb.vertices){ 
                    cx += v[0]; 
                    cy += v[1]; 
                    cz += v[2]; 
                }
                cx /= amb.vertices.length; 
                cy /= amb.vertices.length; 
                cz /= amb.vertices.length;
                const [tx, ty] = project([cx, cy, cz]);
                
                const xs3D = amb.vertices.map(v => v[0]);
                const zs3D = amb.vertices.map(v => v[2]);
                const width3D = Math.max(...xs3D) - Math.min(...xs3D);
                const height3D = Math.max(...zs3D) - Math.min(...zs3D);
                const size3D = Math.min(width3D, height3D);
                
                const fontSize = Math.min(24, Math.max(12, size3D * zoom * 0.1));
                
                let alpha = (pisoActivo === "ALL" ? 0.5 : 0.8);
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(amb.nombre, tx, ty);
                ctx.restore();
            }

            // Dibujar las SUBZONAS principales
            for (const amb of piso.ambientes){
                if (amb.tipo !== 'subzona') continue;
                
                // VERIFICAR: Que la subzona pertenezca a este piso
                if (amb.piso && amb.piso !== piso.nombre) {
                    console.warn(`Subzona ${amb.nombre} no pertenece al piso ${piso.nombre}`);
                    continue;
                }
                
                const poly2D = amb.vertices.map(v => project(v));

                // Pol√≠gono de SUBZONA (m√°s visible)
                ctx.beginPath();
                poly2D.forEach(([px,py],i) => { 
                    if(i === 0) ctx.moveTo(px,py); 
                    else ctx.lineTo(px,py); 
                });
                ctx.closePath();
                
                if (highlightedAmbiente === amb) {
                    ctx.fillStyle = hexToRgba(amb.color, 0.8);
                    ctx.fill();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = hexToRgba(amb.color, 0.6);
                    ctx.fill();
                    ctx.strokeStyle = amb.color;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                screenPolygons.push({amb, poly2D, piso});

                // Texto para subzonas principales
                let cx=0, cy=0, cz=0;
                for(const v of amb.vertices){ 
                    cx += v[0]; 
                    cy += v[1]; 
                    cz += v[2]; 
                }
                cx /= amb.vertices.length; 
                cy /= amb.vertices.length; 
                cz /= amb.vertices.length;
                const [tx, ty] = project([cx, cy, cz]);
                
                const xs3D = amb.vertices.map(v => v[0]);
                const zs3D = amb.vertices.map(v => v[2]);
                const width3D = Math.max(...xs3D) - Math.min(...xs3D);
                const height3D = Math.max(...zs3D) - Math.min(...zs3D);
                const size3D = Math.min(width3D, height3D);
                
                const fontSize = Math.min(14, Math.max(8, size3D * zoom * 0.15));
                
                let alpha = (pisoActivo === "ALL" ? 0.7 : 0.9);
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.font = `${fontSize}px Arial`;
                ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(amb.nombre, tx, ty);
                ctx.restore();
            }
        }
    }
    
    // SEGUNDO: Dibujar personas ENCIMA de las subzonas
    if (personasEnFrames.length > 0) {
        const currentTime = Date.now();
        
        // Agrupar personas por piso para optimizar
        const personasPorPiso = {};
        personasEnFrames.forEach(persona => {
            if (!personasPorPiso[persona.piso]) {
                personasPorPiso[persona.piso] = [];
            }
            personasPorPiso[persona.piso].push(persona);
        });
        
        // Dibujar solo personas del piso activo
        const personasADibujar = pisoActivo === "ALL" 
            ? personasEnFrames 
            : (personasPorPiso[pisoActivo] || []);
        
        personasADibujar.forEach(persona => {
            const [px, py] = project(persona.posicion);
            
            // Verificar si la posici√≥n proyectada es v√°lida y est√° en pantalla
            if (!isFinite(px) || !isFinite(py) || px < -100 || px > canvas.width + 100 || py < -100 || py > canvas.height + 100) {
                return;
            }
            
            // Determinar alpha basado en antig√ºedad (se desvanece despu√©s de 20 segundos)
            const edad = currentTime - persona.timestamp;
            const alpha = Math.max(0.3, 1 - (edad / 20000));
            
            // RADIO M√ÅS PEQUE√ëO - ajustado de 1.5 a 1.2 con factores menores
            const baseRadio = 1.2; // Reducido a√∫n m√°s
            const radio = baseRadio * zoom * (0.4 + (persona.accuracy / 100) * 0.2);
            
            // RESALTADO PERMANENTE para personas de inter√©s
            const esResaltada = persona.resaltado;
            
            // Dibujar persona (c√≠rculo)
            ctx.beginPath();
            ctx.arc(px, py, radio, 0, 2 * Math.PI);
            
            if (esResaltada) {
                // PERSONA DE INTER√âS - RESALTADO PERMANENTE DORADO
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                ctx.strokeStyle = '#FF8C00'; // Naranja oscuro para contraste
                ctx.lineWidth = 1.5;
                
                // Efecto de pulso permanente para personas de inter√©s
                const pulse = Math.sin(currentTime / 300) * 0.4 + 0.6;
                ctx.beginPath();
                ctx.arc(px, py, radio * (1 + pulse * 0.2), 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                // Persona normal (teal)
                ctx.fillStyle = `rgba(34, 230, 217, ${alpha})`;
                ctx.strokeStyle = '#1cb5a9';
                ctx.lineWidth = 1;
            }
            
            ctx.fill();
            ctx.stroke();
            
            // Efecto de pulso suave para personas recientes (no de inter√©s)
            if (edad < 5000 && !esResaltada) {
                const pulse = Math.sin(currentTime / 250) * 0.2 + 0.8;
                ctx.beginPath();
                ctx.arc(px, py, radio * pulse, 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(34, 230, 217, ${alpha * 0.2})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            
            // Etiqueta con informaci√≥n (solo con zoom suficiente)
            if (zoom > 1.8) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Fondo para la etiqueta
                const idCorto = persona.tracking_id ? persona.tracking_id.substring(0, 6) : 'N/A';
                const texto = `${idCorto} (${Math.round(persona.accuracy)}%)`;
                const textWidth = ctx.measureText(texto).width;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                ctx.fillRect(px - textWidth/2 - 3, py - radio - 22, textWidth + 6, 14);
                
                // Texto
                ctx.fillStyle = esResaltada ? `rgba(255, 255, 255, ${alpha})` : `rgba(255, 255, 255, ${alpha})`;
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(texto, px, py - radio - 10);
                
                ctx.restore();
            }
        });
    }
    
    currentAlerts.forEach(alert => {
        if (alert.camera_name) {
            camerasWithAlerts.add(alert.camera_name);
        }
    });

    // DETERMINAR QU√â C√ÅMARAS MOSTRAR - VERSI√ìN SIMPLIFICADA
    let camerasToShow = [];
    
    // CASO 1: Si hay una c√°mara forzada (selecci√≥n manual), solo mostrar esa
    if (forceShowCamera) {
        camerasToShow = [forceShowCamera];
    } 
    // CASO 2: Si hay un inter√©s seleccionado, mostrar solo las c√°maras filtradas
    else if (selectedInteresItem !== null && filteredCamerasByInteres !== null) {
        camerasToShow = [...filteredCamerasByInteres];
    }
    // CASO 3: Si hay un filtro de c√°mara espec√≠fico activo
    else if (currentFilter !== 'all' && currentFilter !== 'todas') {
        const isAlertType = currentAlerts.some(alert => alert.type_event_name === currentFilter);
        
        if (isAlertType) {
            // Filtro por tipo de alerta - mostrar c√°maras con ese tipo de alerta
            const cameraNamesInFilter = [...new Set(currentAlerts
                .filter(alert => alert.type_event_name === currentFilter)
                .map(alert => alert.camera_name))];
            camerasToShow = camerasData.filter(cam => cameraNamesInFilter.includes(cam.camera_id));
        } else {
            // Filtro por c√°mara espec√≠fica
            camerasToShow = camerasData.filter(cam => cam.camera_id === currentFilter);
        }
    }
    // CASO 4: MODO NORMAL - MOSTRAR TODAS LAS C√ÅMARAS (si showCameras es true)
    else {
        camerasToShow = [...camerasData];
    }

    // Aplicar filtro de piso
    camerasToShow = camerasToShow.filter(cam => {
        if (pisoActivo === "ALL") return true;
        return cam.piso.includes(pisoActivo);
    });

    // Contadores para la leyenda
    let alertCamerasCount = 0;
    let normalCamerasCount = 0;

    // Obtener tiempo actual para efectos de animaci√≥n
    const currentTime = new Date().getTime();

    camerasToShow.forEach(cam => {
        const [x, y, z] = cam.coords;
        const [px, py] = project([x, y, z]);

        // Guardar la posici√≥n proyectada para la detecci√≥n de clic
        cam.screenPos = { x: px, y: py };

        // Determinar si la c√°mara tiene alertas
        const hasAlerts = camerasWithAlerts.has(cam.camera_id);
        let isManuallyHighlighted = null;
        
        if(highlightedCamera){
            isManuallyHighlighted = cam.camera_id === highlightedCamera.camera_id;
        }
        
        // Contar c√°maras seg√∫n su estado
        if (hasAlerts || isManuallyHighlighted) {
            alertCamerasCount++;
        } else {
            normalCamerasCount++;
        }

    if (isManuallyHighlighted) {
            // Estilo resaltado manual (selecci√≥n de usuario) - DORADO FIJO
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.fill();
            
            const pulseStrong = Math.sin(currentTime / 100) * 0.5 + 0.5;
            
            ctx.beginPath();
            ctx.arc(px, py, 16 + pulseStrong * 8, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + pulseStrong * 0.4})`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // A√±adir etiqueta con nombre de c√°mara
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(cam.camera_id, px, py - 25);
        } 
        else if (hasAlerts) {
            // C√°maras con alertas - DORADO con pulso
            const pulse = Math.sin(currentTime / 200) * 0.5 + 0.5;
            
            // C√≠rculo interior con pulso
            ctx.beginPath();
            ctx.arc(px, py, 6 + pulse * 3, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(255, 215, 0, ${0.8 + pulse * 0.2})`;
            ctx.fill();
            
            // Anillo exterior con pulso m√°s amplio
            ctx.beginPath();
            ctx.arc(px, py, 10 + pulse * 8, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + pulse * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // A√±adir etiqueta con nombre de c√°mara
            if (zoom > 1.2) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(cam.camera_id, px, py - 25);
                ctx.restore();
            }
        }
        else {
            // C√°maras normales - ROJO sin pulso (solo si showCameras es true)
            if (showCameras) {
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#ff5252'; // Rojo
                ctx.fill();
                ctx.strokeStyle = '#cc0000'; // Borde rojo oscuro
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // A√±adir etiqueta con nombre de c√°mara (solo si est√° cerca)
                if (zoom > 1.5) {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(cam.camera_id, px, py - 15);
                    ctx.restore();
                }
            }
        }
    });

  // Actualizar contadores en la leyenda - MODIFICADO
  updateCameraLegendCounts(alertCamerasCount, normalCamerasCount);
}

let areaSeleccionada = null;

function obtainEdificio(id_area) {
    callAPI({
        method: 'gestion/getbuilding',
        params: { id_area: id_area }, // A√±adir par√°metro id_area
        ok: function (vals) {
            // Transformar los datos del API a la estructura esperada
            edificio = transformarNuevoEdificio(vals);
            
            areaSeleccionada = id_area;
            
            // NORMALIZAR COORDENADAS - NUEVO
            edificio = normalizarCoordenadasEdificio(edificio);
            
            //log("Edificio normalizado:", edificio);
            
            // Ya no llamamos a actualizarSelectorPisos aqu√≠
            // porque ahora se maneja por separado

            setTimeout(() => getCamaras(), 2000);
            //log("Edificio cargado, transformado y normalizado exitosamente");
        },
        error: function (error) {
            log("Error al obtener el edificio:", error);
            
            // En caso de error, usar datos de ejemplo
            edificio = obtenerEdificioEjemplo();
            
            log("Usando datos de ejemplo debido a error en la API");
        }
    });
}

function render(){
  ctx.fillStyle=configTablero.colorFondo;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawGrid();
  drawEdificio();
  updatePersonCountLegend();
  // Dibujar rutas solo si showRoutes es true

  if (showRoutes) {
    drawRoute(); // Asegurar que esta l√≠nea est√© presente
  }
}

function drawGrid(){
  if (!configTablero.grid) return;
  const size=configTablero.gridSize, half=200;
  ctx.strokeStyle=configTablero.colorLineas; ctx.lineWidth=1;
  for(let x=-half;x<=half;x+=size){
    const p1=project([x,0,-half]), p2=project([x,0,half]);
    ctx.beginPath(); ctx.moveTo(...p1); ctx.lineTo(...p2); ctx.stroke();
  }
  for(let z=-half;z<=half;z+=size){
    const p1=project([-half,0,z]), p2=project([half,0,z]);
    ctx.beginPath(); ctx.moveTo(...p1); ctx.lineTo(...p2); ctx.stroke();
  }
}

// ==========================
// Detecci√≥n de clic mejorada
// ==========================
function pointInPolygon(x, y, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i][0], yi = poly[i][1];
    const xj = poly[j][0], yj = poly[j][1];
    
    // Check if the point is exactly on a vertex
    if ((xi === x && yi === y) || (xj === x && yj === y)) return true;
    
    // Check if the point is on a horizontal edge
    if (yi === yj && yi === y && x > Math.min(xi, xj) && x < Math.max(xi, xj)) return true;
    
    // Check if the point is on a vertical edge
    if (xi === xj && xi === x && y > Math.min(yi, yj) && y < Math.max(yi, yj)) return true;
    
    // Check if the point is inside using the ray casting algorithm
    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function polygonArea2D(poly) {
  let area = 0;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    area += (poly[j][0] + poly[i][0]) * (poly[j][1] - poly[i][1]);
  }
  return Math.abs(area / 2);
}

function pickPolygon(mx, my) {
  let insideCandidates = [];
  let nearCandidates = [];

  for (let {amb, poly2D, piso} of screenPolygons) {
    // Verificar si el punto est√° dentro del pol√≠gono con mayor precisi√≥n
    if (isPointInPolygon(mx, my, poly2D)) {
      const area = polygonArea2D(poly2D);
      insideCandidates.push({amb, piso, area});
    } else {
      // Calcular distancia m√≠nima al pol√≠gono para fallback
      const minDist = minDistanceToPolygon(mx, my, poly2D);
      const area = polygonArea2D(poly2D);
      
      // Solo considerar pol√≠gonos cercanos
      if (minDist < 30) {
        nearCandidates.push({amb, piso, dist: minDist, area});
      }
    }
  }

  // Priorizar pol√≠gonos donde el clic est√° dentro
  if (insideCandidates.length > 0) {
    insideCandidates.sort((a, b) => a.area - b.area);
    return insideCandidates[0];
  }

  // Si no hay pol√≠gonos donde el clic est√© dentro, usar los cercanos
  if (nearCandidates.length > 0) {
    nearCandidates.sort((a, b) => {
      if (a.dist !== b.dist) return a.dist - b.dist;
      return a.area - b.area;
    });
    return nearCandidates[0];
  }

  return null;
}

function minDistanceToPolygon(x, y, polygon) {
  let minDist = Infinity;
  for (let i = 0; i < polygon.length; i++) {
    const p1 = polygon[i];
    const p2 = polygon[(i + 1) % polygon.length];
    const dist = pointToLineDistance(x, y, p1[0], p1[1], p2[0], p2[1]);
    if (dist < minDist) minDist = dist;
  }
  return minDist;
}

function isPointInPolygon(x, y, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], yi = polygon[i][1];
    const xj = polygon[j][0], yj = polygon[j][1];
    
    const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function pointToLineDistance(x, y, x1, y1, x2, y2) {
  const A = x - x1;
  const B = y - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const len_sq = C * C + D * D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;

  let xx, yy;

  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  const dx = x - xx;
  const dy = y - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// Event listener para clic en el canvas
canvas.addEventListener("click", e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Primero, verificar si se hizo clic en una c√°mara
  for (const cam of camerasData) {
    if (cam.screenPos) {
      const dist = Math.hypot(mx - cam.screenPos.x, my - cam.screenPos.y);
      if (dist < 15) { // Un radio de 15px para el clic
        // Usar el modal interno de la aplicaci√≥n en lugar de SweetAlert
        const content = `
          <b>ID:</b> ${cam.id}<br>
          <b>Ubicaci√≥n:</b> ${cam.location}<br>
          <b>Latitud:</b> ${cam.latitud}<br>
          <b>Longitud:</b> ${cam.longitud}<br>
          <b>Estado:</b> ${cam.estado_general}<br>
          <b>√öltimo registro:</b> ${new Date(cam.fecha_registro).toLocaleString()}
        `;
        showModal(`C√°mara: ${cam.camera_id}`, content);
        return; // Detener la ejecuci√≥n si se hizo clic en una c√°mara
      }
    }
  }

  // Si no se hizo clic en una c√°mara, se ejecuta la l√≥gica existente para el pol√≠gono
  const picked = pickPolygon(mx, my);
  if (!picked) return;

  const {amb, piso} = picked;
  highlightedAmbiente = amb;
  render();

  // Zoom autom√°tico al centroide
  let cx=0,cy=0,cz=0;
  for(const v of amb.vertices){ cx+=v[0]; cy+=v[1]; cz+=v[2]; }
  cx/=amb.vertices.length; cy/=amb.vertices.length; cz/=amb.vertices.length;
  const [tx,ty] = project([cx,cy,cz]);

  zoom = 2.0;
  offsetX = canvas.width/2 - (tx - canvas.width/2);
  offsetY = canvas.height/2 - (ty - canvas.height/2);
  render();

  // Actualizar el panel de la derecha inmediatamente
  highlightedAmbiente = null;
  // Volver a renderizar sin el resaltado despu√©s de un breve retraso para que sea visible
  setTimeout(() => render(), 200);
});

// ==========================
// Animaci√≥n autom√°tica
// ==========================
function animate(){
  if(autoRotate){ 
    yaw += rotateSpeed; 
  }
  
  if (dashboard.style.display !== 'none') {
    render();
    requestAnimationFrame(animate);
  }
}

// ==========================
// Interacci√≥n mouse
// ==========================
let dragging=false,lastX=0,lastY=0;
let dragMode=null;

canvas.addEventListener("mousedown", e=>{
  dragging=true;
  lastX=e.clientX; lastY=e.clientY;
  dragMode=(e.button===2?"pan":"rotate");
  canvas.style.cursor=(dragMode==="pan"?"move":"grabbing");
});
["mouseup","mouseleave"].forEach(ev=>canvas.addEventListener(ev,()=>{
  dragging=false; dragMode=null; canvas.style.cursor="grab";
}));
canvas.addEventListener("mousemove", e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  if(dragMode==="pan"){ offsetX+=dx; offsetY+=dy; }
  else if(dragMode==="rotate"){
    yaw -= dx*0.01;
    pitch -= dy*0.01;
    const limit=Math.PI/2-0.1;
    if(pitch>limit) pitch=limit;
    if(pitch<-limit) pitch=-limit;
  }
  lastX=e.clientX; lastY=e.clientY;
  render();
});
canvas.addEventListener("contextmenu", e=>e.preventDefault());

// ==========================
// Zoom
// ==========================
canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const prev=zoom;
  zoom*=(e.deltaY>0?0.9:1.1);
  zoom=Math.max(0.25,Math.min(5.0,zoom));
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  offsetX=mx-(mx-offsetX)*(zoom/prev);
  offsetY=my-(my-offsetY)*(zoom/prev);
  render();
},{passive:false});

// ==========================
// Botones y filtros
// ==========================
/*
document.getElementById("btnFullscreen").addEventListener("click",()=>{
  if(!document.fullscreenElement) canvas.requestFullscreen(); else document.exitFullscreen();
});
*/
document.getElementById("btnAutoRotate").addEventListener("click",()=>{
  autoRotate=!autoRotate;
  document.getElementById("btnAutoRotate").textContent="Rotaci√≥n autom√°tica: "+(autoRotate?"ON":"OFF");
});

document.getElementById("selectPiso").addEventListener("change", e => {
    pisoActivo = e.target.value;
    if(pisoActivo === "ALL"){ 
        zoom = configTablero.zoomInicial; 
        offsetX = canvas.width/2; 
        offsetY = canvas.height/2; 
    }
    else{
        const piso = edificio.pisos.find(p => p.nombre === pisoActivo);
        if(piso){
            zoom = 1.2;
            offsetX = canvas.width/2;
            offsetY = canvas.height/2 - piso.altura * zoom * 0.5;
        }
    }
    render();
    
    // A√ëADIR: Actualizar la leyenda de personas cuando cambia el piso
    updatePersonCountLegend();
});

// ==========================
// Llamada inicial para evitar fallo en primer clic
// ==========================

// ===========
// Llamada a servicios API
// ===========

// Variable global para almacenar las alertas
let alertas = [];

// Funci√≥n para renderizar la lista de alertas
function renderTimelineList(data) {
    const timelineList = document.getElementById('timelineList');
    if (!data || data.length === 0) {
        timelineList.innerHTML = '<div class="loading">No hay alertas disponibles</div>';
        return;
    }
    
    timelineList.innerHTML = '';
    
    // Ordenar por fecha m√°s reciente primero
    const sortedData = [...data].sort((a, b) => new Date(b.init_time_frame) - new Date(a.init_time_frame));
    
    // Obtener el tiempo actual para calcular opacidades
    const now = new Date();
    
    sortedData.forEach(item => {
        const li = document.createElement('li');
        li.setAttribute('data-id', item.id);
        li.setAttribute('data-type', item.type_event_name.toLowerCase());
        
        const time = new Date(item.init_time_frame);
        const formattedTime = time.toLocaleString('es-PE');
        
        // CALCULAR OPACIDAD BASADA EN EL TIEMPO TRANSCURRIDO
        const timeDiff = now - time; // Diferencia en milisegundos
        const minutesDiff = timeDiff / (1000 * 60); // Convertir a minutos
        
        // Reducir opacidad 0.1 cada 10 minutos, m√≠nimo 0.5
        const opacity = Math.max(0.3, 1 - (Math.floor(minutesDiff / 10) * 0.15));
        
        // APLICAR OPACIDAD AL ELEMENTO
        li.style.opacity = opacity;
        li.style.transition = 'opacity 0.3s ease'; // Transici√≥n suave
        
        // Formato timeline como en el mapa
        li.innerHTML = `
            <strong>${item.id + " - " +item.type_event_name || 'Alerta'}</strong>
            <strong>${formattedTime}</strong>
            ${item.camera_name} ¬∑ ${item.location || 'Ubicaci√≥n no especificada'}
        `;
        
        // Agregar evento click para mostrar detalles
        li.addEventListener('click', () => {
            showAlertDetails(item);
        });
        
        timelineList.appendChild(li);
    });
}

// Funci√≥n para resaltar c√°maras con nuevas alertas
function highlightCameraForAlert(cameraId, duration = 5000) {
  const camera = camerasData.find(cam => cam.camera_id === cameraId);
  if (!camera) return;
  
  // Guardar referencia a la c√°mara resaltada
  alertHighlightedCameras[cameraId] = camera;
  
  // Programar para quitar el resaltado despu√©s del tiempo especificado
  if (alertHighlightTimers[cameraId]) {
    clearTimeout(alertHighlightTimers[cameraId]);
  }
  
  alertHighlightTimers[cameraId] = setTimeout(() => {
    delete alertHighlightedCameras[cameraId];
    render();
  }, duration);
  
  render();
}

function isValidParam(value) {
    return value !== null && 
           value !== undefined && 
           value.toString().trim() !== '' &&
           value.toString().toLowerCase() !== 'null' &&
           value.toString().toLowerCase() !== 'undefined';
}

// Modificar la funci√≥n getAlertas para usar los datos
function getAlertas(item) {
    // NO actualizar si hay una b√∫squeda activa (excepto cuando item no es null)
    if (currentSearchType !== null && item === null) {
        return; // Salir sin hacer cambios si hay b√∫squeda activa
    }

    // MOSTRAR LOADER - MEJORADO
    const timelineList = document.getElementById('timelineList');
    
    // NO mostrar loader si hay una b√∫squeda activa de placa o caracter√≠sticas
    if (!(currentSearchType === 'placa' && item === null) && 
        !(currentSearchType === 'caracteristicas' && item === null)) {
        if (timelineList) {
            timelineList.innerHTML = '<div style="text-align:center;margin:2em; display:flex; flex-direction:column; align-items:center; justify-content:center;"><div>Puedes realizar la b√∫squeda de personas</div></div>';
        }
        showGlobalLoader(true);
    }

    // Crear objeto de par√°metros base
    let params = {
        camera_name: "UTEC" // identificador del usuario
    };
    
    // Si hay un inter√©s seleccionado, preservar el filtro
    if (selectedInteresItem !== null && item === null) {
        let itemBusqueda = interesData.find(data => data.id == selectedInteresItem.id);
        if (itemBusqueda) {
            params = {
                camera_name: "UTEC",
                ...(itemBusqueda.matched_plate && { matched_plate: itemBusqueda.matched_plate }),
                ...(itemBusqueda.id && { matched_ident: itemBusqueda.id })
            };
            item = itemBusqueda;
        }
    }
    
    // Agregar par√°metros solo si son v√°lidos
    if (item && isValidParam(item.matched_plate)) {
        params.matched_plate = item.matched_plate;
    }
    
    if (item && isValidParam(item.id)) {
        params.matched_ident = item.id;
    }
    
    callAPI({
        method: 'gestion/getalerts',
        params: params,
        ok: function (vals) {
            
            showGlobalLoader(false);
            
            // NO actualizar el timeline si hay una b√∫squeda activa (excepto inter√©s)
            if (currentSearchType !== null && currentSearchType !== 'interes' && item === null) {
                return; // Salir sin hacer cambios al timeline
            }
            
            // Guardar las alertas
            alertas = vals.data;
            
            // Identificar nuevas alertas vs todas
            const alertResult = identificarNuevasAlertas(alertas);
            const newAlerts = alertResult.nuevas;
            
            /*
            // Verificar solo las NUEVAS alertas contra personas de inter√©s
            if (newAlerts.length > 0) {
                const matchingAlert = checkAlertsAgainstInteres(newAlerts);
                if (matchingAlert) {
                    // Mostrar autom√°ticamente los detalles de la alerta coincidente
                    setTimeout(() => {
                        showAlertDetails(matchingAlert);
                    }, 500);
                }
            }
            */
            
            // El resto del c√≥digo permanece igual...
            if (selectedInteresItem !== null && item !== null) {
                if (vals.data && vals.data.length > 0) {
                    filteredAlerts = [...vals.data];
                } else {
                    filteredAlerts = [];
                }
            } else if (item === null) {
                filteredAlerts = null;
            }
            
            // **A√ëADIDO: Calcular ruta si hay un inter√©s seleccionado y suficientes alertas**
            if (selectedInteresItem !== null && filteredAlerts && filteredAlerts.length >= 2) {
                calculateAndDrawRoute();
            }
            
            if (camerasData.length > 0) {
                const totalAlertCameras = new Set(alertas.map(alert => alert.camera_name)).size;
                const vehicleCameras = camerasData.filter(cam => 
                    cam.camera_id.toLowerCase().includes('vehicular') || 
                    cam.camera_id.toLowerCase().includes('salida') || 
                    cam.camera_id.toLowerCase().includes('estacionamiento') ||
                    cam.camera_id.toLowerCase().includes('parking') ||
                    cam.camera_id.toLowerCase().includes('ssgg')
                ).length;
                const normalCameras = camerasData.length;
                
                updateCameraLegendCounts(totalAlertCameras, normalCameras);
            }
            
            // Guardar alertas iniciales solo si no hay filtro activo
            if (item === null && selectedInteresItem === null && currentSearchType === null) {
                initialAlerts = [...vals.data];
                lastKPUpdate = new Date();
                calculateTrendData();
                
                // Limpiar y actualizar resaltado permanente de c√°maras con alertas
                alertHighlightedCameras = {};
            }
            
            lastAlertIds = new Set(alertas.map(alert => alert.id));
            
            // Renderizar con las alertas filtradas si existen, sino con todas
            const alertsToRender = filteredAlerts !== null ? filteredAlerts : alertas;
            renderTimelineList(alertsToRender);
            
            // Actualizar la leyenda y KPIs (siempre con datos iniciales)
            const uniqueAlertTypes = [...new Set(initialAlerts.map(alert => alert.type_event_name))];
        },
        error: function (error) {
            showGlobalLoader(false);
            
            // NO mostrar error si hay una b√∫squeda activa
            if (currentSearchType !== null && item === null) {
                return;
            }
            
            log("Error al obtener las alertas:", error);
            // Mostrar alertas de ejemplo en caso de error
            const alertasEjemplo = [
                {
                    id: 1,
                    type_event_name: "Accidente",
                    camera_name: "C√°mara 1",
                    location: "Estacionamientos S1",
                    init_time_frame: new Date().toISOString()
                },
                {
                    id: 2,
                    type_event_name: "Aglomeraci√≥n",
                    camera_name: "C√°mara 2",
                    location: "Recepci√≥n",
                    init_time_frame: new Date(Date.now() - 10000000).toISOString()
                }
            ];
            
            // Guardar tambi√©n en caso de error
            if (item === null && currentSearchType === null) {
                initialAlerts = [...alertasEjemplo];
                lastKPUpdate = new Date();
                calculateTrendData();
            }
            
            currentRoute = null;
            routeAnimationProgress = 0;
            if (routeAnimation) {
                cancelAnimationFrame(routeAnimation);
                routeAnimation = null;
            }
            
            renderTimelineList(alertasEjemplo);
        }
    });
}

function showGlobalLoader(show) {
    // Crear loader global si no existe
    let globalLoader = document.getElementById('global-loader');
    if (!globalLoader) {
        globalLoader = document.createElement('div');
        globalLoader.id = 'global-loader';
        globalLoader.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(6, 25, 34, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100000;
            flex-direction: column;
        `;
        globalLoader.innerHTML = `
            <div class="spinner" style="margin-bottom: 20px;"></div>
            <div style="color: var(--teal); font-size: 16px;">Cargando...</div>
        `;
        document.body.appendChild(globalLoader);
    }
    
    globalLoader.style.display = show ? 'flex' : 'none';
}

forceShowCamera = null;

// ==========================
// Funci√≥n para limpiar resaltado de alertas
// ==========================
function clearAlertHighlights() {
  alertHighlightedCameras = {};
  forceShowCamera = null; // A√±adir esta l√≠nea
  render();
}

// ==========================
// Funci√≥n para calcular datos de tendencia
// ==========================
function calculateTrendData() {
    if (initialAlerts.length === 0) return;
    
    const now = new Date();
    kpiTrendData = [];
    
    // Crear intervalos de 1 hora para las √∫ltimas 4 horas, incluyendo la hora actual parcial
    for (let i = 4; i >= 1; i--) {
        const hourStart = new Date(now.getTime() - i * 60 * 60 * 1000);
        const hourEnd = i === 1 ? now : new Date(now.getTime() - (i - 1) * 60 * 60 * 1000);
        
        const alertsInHour = initialAlerts.filter(alert => {
            const alertTime = new Date(alert.init_time_frame);
            return alertTime >= hourStart && alertTime < hourEnd;
        });
        
        // Formatear la etiqueta del intervalo
        let hourLabel;
        if (i === 1) {
            // Para el √∫ltimo intervalo (hora actual), mostrar hora inicio - hora actual
            const startHour = hourStart.getHours().toString().padStart(2, '0');
            const endHour = hourEnd.getHours().toString().padStart(2, '0');
            const endMinutes = hourEnd.getMinutes().toString().padStart(2, '0');
            hourLabel = `${startHour}:00-${endHour}:${endMinutes}`;
        } else {
            const startHour = hourStart.getHours().toString().padStart(2, '0');
            const endHour = hourEnd.getHours().toString().padStart(2, '0');
            hourLabel = `${startHour}:00-${endHour}:00`;
        }
        
        kpiTrendData.push({
            hour: hourLabel,
            count: alertsInHour.length,
            timestamp: hourStart
        });
    }
}

// Funci√≥n utilitaria para obtener un ambiente aleatorio
function getRandomAmbiente() {
    const allAmbientes = [];
    edificio.pisos.forEach(piso => {
        piso.ambientes.forEach(ambiente => {
            // Se puede filtrar por ambientes con pol√≠gonos grandes, si se desea
            ambiente.piso = piso; // Agregamos la referencia del piso
            allAmbientes.push(ambiente);
        });
    });
    if (allAmbientes.length > 0) {
        const randomIndex = Math.floor(Math.random() * allAmbientes.length);
        return allAmbientes[randomIndex];
    }
    return null;
}
    
$(document).ready(function() {
    // Inicializar fechas por defecto
    const hoy = new Date();
    const ayer = new Date(hoy);
    ayer.setDate(hoy.getDate() - 1);
    
    $('#txtFechaIni').val(formatear(ayer));
    $('#txtFechaFin').val(formatear(hoy));
    // Asegurar que la pesta√±a KPI est√© activa por defecto
    
    //loadSavedSelections();
    //updateMapSelectedPersonsPanel();
    loadEdificiosData();
    /*
    initMapFilters();
    
    personasEnFrames = [];
    
    initSelectionsContainer();
    initMapSelectedPersonsPanel();*/
    
});
// Variables globales para el modal de video
let videoPlayer = null;
let selectedAlert = null;

let areasData = [];

function loadEdificiosData() {
    log("hola");
    callAPI({
        method: 'gestion/get_areas',
        ok: function(areas) {
            /*
            if (areas && areas.length > 0) {
                areasData = areas;
                actualizarSelectorPisos();
                
                // Obtener el primer id_area √∫nico
                const areasAgrupadas = new Map();
                areas.forEach(area => {
                    if (!areasAgrupadas.has(area.id_area)) {
                        areasAgrupadas.set(area.id_area, area);
                    }
                });
                
                // Seleccionar el primer edificio por defecto
                const primerEdificio = areasAgrupadas.values().next().value;
                if (primerEdificio) {
                    document.getElementById('selectPiso').value = primerEdificio.id_area;
                    
                    // Cargar el edificio seleccionado
                    obtainEdificio(primerEdificio.id_area);
                }
            } else {
                console.error('No se recibieron √°reas');
            }
            */
        },
        error: function(error) {
            console.error('Error al cargar las √°reas:', error);
        }
    });
}


// Funci√≥n para mostrar detalles de alerta
function showAlertDetails(alert) {
  selectedAlert = alert;
  const panel = document.getElementById('alert-details');
  const content = document.getElementById('alert-details-content');
  const title = document.getElementById('alert-details-title');
  
  if (!panel || !content || !title) {
    log("Elementos del panel de detalles no encontrados");
    return;
  }
  
  // IMPORTANTE: Limpiar cualquier c√°mara previamente resaltada
  clearAlertHighlights();
  highlightedCamera = null;
  
  // BUSCAR Y ESTABLECER LA C√ÅMARA ASOCIADA A LA ALERTA
  highlightedCamera = camerasData.find(cam => 
    cam.camera_id === alert.camera_name
  );
  
  // FORZAR MOSTRAR SOLO ESTA C√ÅMARA
  forceShowCamera = highlightedCamera;
  
  // Si encontramos una c√°mara, centrar la vista en ella
  if (highlightedCamera) {
    const [x, y, z] = highlightedCamera.coords;
    const [tx, ty] = project([x, y, z]);
    
    // Ajustar zoom y posici√≥n
    zoom = 2.0;
    offsetX = canvas.width/2 - (tx - canvas.width/2);
    offsetY = canvas.height/2 - (ty - canvas.height/2);
  }
  
  // MODIFICACI√ìN: Buscar la c√°mara por ID exacto
    highlightedCamera = camerasData.find(cam => 
        cam.camera_id === alert.camera_name
    );
    
    // Forzar mostrar solo esta c√°mara
    forceShowCamera = highlightedCamera;
  
  // Formatear la fecha
  const time = new Date(alert.init_time_frame);
  const formattedTime = time.toLocaleString('es-PE');
  
  title.textContent = `Detalle de Alerta: ${alert.id} - ${alert.type_event_name}`;
  
  // Construir el contenido b√°sico
  let html = `
    <div style="max-width:320px">
        <h4 class="person-details-title">C√°mara: ${alert.camera_name}</h4>
      <div class="detail-item">
        Ubicaci√≥n: ${alert.location}
      </div>
      <div class="detail-item">
        Fecha y Hora:
        ${formattedTime}
      </div>
  `;
  
  // A√±adir informaci√≥n adicional si est√° disponible
  if (alert.nombre_objetivo) {
    html += `
      <div class="detail-item">
        Objetivo:
        ${alert.nombre_objetivo}
      </div>
    `;
  }
  
  if (alert.nombre_cuadrante) {
    html += `
      <div class="detail-item">
        Cuadrante:
        ${alert.nombre_cuadrante}
      </div>
    `;
  }
  
  // A√±adir frame si est√° disponible
  if (alert.foto) {
    html += `
      <div class="detail-item">
        Frame:<br>
        <img src="${alert.foto}" style="max-width:100%; margin-top:5px; border-radius:4px;">
      </div>
    `;
  }
  
  html += `</div>`;
  
  // A√±adir informaci√≥n de persona/veh√≠culo si est√° disponible
  if (alert.person_coords_face !== null || alert.vehicle_coords_plate !== null) {
    const personName = alert.nombre ? `${alert.nombre} ${alert.apellido}` : alert.vehicle_plate;
    const personTitle = alert.nombre ? "Persona Detectada" : "Veh√≠culo Detectado";
    const subTitle = alert.nombre ? "Nombre:" : "Placa:";
    const regTime = new Date(alert.fecha_registro || alert.fecha_robo);
    const formattedRegTime = regTime.toLocaleString('es-PE');
    
    html += `
      <div class="person-details-section">
        <h4 class="person-details-title">${personTitle}</h4>
          <div class="detail-item">${subTitle} ${personName}</div>
          ${alert.documento_contacto || alert.num_documento ? 
            `<div class="detail-item">${alert.tipo_documento || alert.vtipo_documento}: ${alert.documento_contacto || alert.num_documento}</div>` : ''}
          <div class="detail-item">Reportado: ${formattedRegTime}</div>
          <div class="detail-item">Precisi√≥n: ${alert.person_accuracy || alert.vehicle_accuracy}%</div>
          ${alert.persona_contacto || alert.nombre_propietario ? 
            `<div class="detail-item">Persona de Contacto: ${alert.parentesco || 'Propietario'} - ${alert.persona_contacto || alert.nombre_propietario}</div>` : ''}
          ${alert.numero_contacto || alert.contacto_propietario ? 
            `<div class="detail-item">Tel√©fono de contacto: ${alert.numero_contacto || alert.contacto_propietario}</div>` : ''}
        <div class="person-details-images">
          <div class="person-image-container">
            <div class="person-image-label">Detecci√≥n Recortada</div>
            <div id="cropped-detection-detail" class="person-image"></div>
          </div>
          <div class="person-image-container">
            <div class="person-image-label">Foto de Referencia</div>
            <div id="person-detection-detail" class="person-image" 
                 style="background-image: url(${alert.person_coords_face ? 
                   `/personimages/inputs/${alert.matched_ident}.jpg` : 
                   alert.foto})">
            </div>
          </div>
        </div>
      </div>
    `;
  }
  
  content.innerHTML = html;
  
  // Mostrar el panel
  panel.style.display = 'block';
  
  // Si hay una detecci√≥n recortada, aplicar el recorte
  if (alert.tracking_id !== null && alert.foto) {
    setTimeout(() => {
      applyImageCropping(alert);
    }, 100);
  }
  render();
}

// Funci√≥n para aplicar recorte a la imagen de detecci√≥n
function applyImageCropping(alert) {
  const croppedDetection = document.getElementById('cropped-detection-detail');
  if (!croppedDetection) return;
  
  croppedDetection.innerHTML = '';
  createCroppedImage(croppedDetection, alert.foto, 
                    (alert.person_coords_face || alert.vehicle_coords_plate), 
                    'Detecci√≥n', 
                    (alert.person_coords_obj || alert.vehicle_coords_obj), 
                    150, 125);
}

// Funci√≥n para crear imagen recortada
function createCroppedImage(parentElement, imageUrl, coordsString, label, coordsObj, width, height) {
  if (!coordsString) return;
  
  const coords = coordsString.split(",").map(Number);
  const coords1 = coordsObj.split(",").map(Number);
  const [xf1, yf1, xf2, yf2] = coords;
  const [xb1, yb1] = coords1;
  
  const containerW = width;
  const containerH = height;
  
  const x1 = xf1 + xb1;
  const y1 = yf1 + yb1;
  const w = xf2 - xf1;
  const h = yf2 - yf1;

  const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
  const w_obj = xo2 - xo1;
  const h_obj = yo2 - yo1;

  const container = document.createElement('div');
  container.className = 'image-section';

  const img = new Image();
  img.src = imageUrl;
  img.onload = () => {
    const imgW = img.naturalWidth;
    const imgH = img.naturalHeight;
    const scale = Math.min(containerW / w, containerH / h);
    const bgW = imgW * scale;
    const bgH = imgH * scale;

    const bgX = (containerW - w * scale) / 2 - x1 * scale;
    const bgY = (containerH - h * scale) / 2 - y1 * scale;

    container.style.backgroundImage = `url(${imageUrl})`;
    container.style.backgroundSize = `${bgW}px ${bgH}px`;
    container.style.backgroundPosition = `${bgX}px ${bgY}px`;
    container.style.backgroundRepeat = "no-repeat";
    container.style.width = `${containerW}px`;
    container.style.height = `${containerH}px`;
  };
  parentElement.appendChild(container);
}

function createCroppedImageCaracteristicas(parentElement, imageUrl, coordsObj, width, height) {
    if (!coordsObj) return;
    
    const [xo1, yo1, xo2, yo2] = coordsObj.split(",").map(Number);
    const w_obj = xo2 - xo1;
    const h_obj = yo2 - yo1;

    const containerW = width;
    const containerH = height;

    const img = new Image();
    img.src = imageUrl;
    img.onload = () => {
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;
        const scale = Math.min(containerW / w_obj, containerH / h_obj);
        const bgW = imgW * scale;
        const bgH = imgH * scale;

        const bgX = (containerW - w_obj * scale) / 2 - xo1 * scale;
        const bgY = (containerH - h_obj * scale) / 2 - yo1 * scale;

        parentElement.style.backgroundImage = `url(${imageUrl})`;
        parentElement.style.backgroundSize = `${bgW}px ${bgH}px`;
        parentElement.style.backgroundPosition = `${bgX}px ${bgY}px`;
        parentElement.style.backgroundRepeat = "no-repeat";
        parentElement.style.width = `${containerW}px`;
        parentElement.style.height = `${containerH}px`;
        parentElement.style.borderRadius = "6px";
    };
    img.onerror = () => {
        parentElement.innerHTML = '<div style="color: var(--ink); text-align: center; padding-top: 40px;">Error al cargar imagen</div>';
    };
}

const videoOvl = document.getElementById('videoOvl');
const closeVideoModalBtn = document.getElementById('closeVideoModal');

const interesOvl = document.getElementById('interesOvl');
const closeinteresOvlBtn = document.getElementById('closeInteresModal');

// Funci√≥n para mostrar el modal de video
function showVideoModal() {
  videoOvl.style.display = 'flex';
}

function closeVideoModal() {
  videoOvl.style.display = 'none';
  
  if (videoPlayer) {
    try {
      videoPlayer.stop();
    } catch (e) {
      log("Error al detener video player:", e);
    }
    videoPlayer = null;
  }
}

// Event listeners para el modal de video
closeVideoModalBtn.addEventListener('click', closeVideoModal);
closeinteresOvlBtn.addEventListener('click', closeInteresModal);
videoOvl.addEventListener('click', (e) => {
  if (e.target === videoOvl) {
    closeVideoModal();
  }
});
interesOvl.addEventListener('click', (e) => {
  if (e.target === interesOvl) {
    closeInteresModal();
  }
});

// Funci√≥n para ver video de alerta normal
function verVideo(item) {
  resetVideoModal('regular');
  
  // Actualizar informaci√≥n en el modal
  document.getElementById("showcamera").textContent = item.camera_name;
  document.getElementById("showUbication").textContent = item.location;
  document.getElementById("showAlert").textContent = item.type_event_name;
  document.getElementById("showId").textContent = item.id;

  let coords_data = null;
  if(item.coords_zone){
    try {
      let poligono = JSON.parse(item.coords_zone);
      coords_data = [{
        points: poligono,
        lineColor: "blue",
        fillColor: "rgba(0,0,255,0.3)",
        lineWidth: 3
      }];
    } catch (e) {
      log("Error parsing coords_zone:", e);
    }
  }
  
  // Mostrar el modal primero
  showVideoModal();
  
  // Luego cargar el video
  callAPI({
    method: 'gestion/dolistimgevents',
    params: {
      camid: item.camera_id,
      date_start: item.init_time_frame,
      tracking_id: item.tracking_id
    },
    ok: function (data) {
      const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
      if (!videoContainer) return;
      
      videoContainer.innerHTML = '';
      try {
        videoPlayer = new videoplay(videoContainer);
      } catch (e) {
        log("Error al crear video player:", e);
        return;
      }
      
      const grouped = Object.values(
        data[1].reduce((acc, item) => {
          if (!acc[item.foto]) {
            acc[item.foto] = {
              foto: item.foto,
              coords_obj: []
            };
          }
          acc[item.foto].coords_obj.push({
            categoria: item.category,
            accuracy_obj: item.accuracy_obj,
            colorupper: item.color_name_upper,
            colorlower: item.color_name_lower,
            plate: item.plate,
            coords: item.coords_obj.split(","),
            coordsplate: (item.coords_plate || '').split(",")
          });
          return acc;
        }, {})
      );
      
      try {
        videoPlayer.update(grouped, "foto", "coords_obj", coords_data);
        setTimeout(() => { 
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 500);
      } catch (e) {
        log("Error al actualizar video player:", e);
      }
    },
    error: function(error) {
      log("Error al cargar el video:", error);
    }
  });
}

// Funci√≥n para ver video de persona
function verVideoPersona(item) {
  resetVideoModal('person');
  
  // Actualizar informaci√≥n en el modal
  document.getElementById("showcamera").textContent = item.camera_name;
  document.getElementById("showUbication").textContent = item.location;
  document.getElementById("showAlert").textContent = item.type_event_name;
  document.getElementById("showId").textContent = item.id;

  const personInfoPanel = document.getElementById('person-info-panel');
  const photoShort = document.getElementById('photo-short');
  photoShort.style.display = 'none';
  if (personInfoPanel) {
    personInfoPanel.style.display = 'block';
    photoShort.style.display = 'flex';
    
    log("item",item);
    
    dataPerson =  document.getElementById('person-data');
    const personName = item.nombre ? `${item.nombre} ${item.apellido}` : item.vehicle_plate;
    const personTitle = item.nombre ? "Persona Detectada" : "Veh√≠culo Detectado";
    const subTitle = item.nombre ? "Nombre:" : "Placa:";
    const regTime = new Date(item.fecha_registro || item.fecha_robo);
    const formattedRegTime = regTime.toLocaleString('es-PE');
    //document.getElementById('person-name').textContent = `${item.nombre ? (`Nombre: ` + item.nombre + " " + item.apellido) : `Placa: ` + item.vehicle_plate}`;
    dataPerson.innerHTML = `
        <div class="detail-item">${subTitle} ${personName}</div>
          ${item.documento_contacto || item.num_documento ? 
            `<div class="detail-item">${item.tipo_documento || item.vtipo_documento}: ${item.documento_contacto || item.num_documento}</div>` : ''}
          <div class="detail-item">Reportado: ${formattedRegTime}</div>
          <div class="detail-item">Precisi√≥n: ${item.person_accuracy || item.vehicle_accuracy}%</div>
          ${item.persona_contacto || item.nombre_propietario ? 
            `<div class="detail-item">Persona de Contacto: ${item.parentesco || 'Propietario'} - ${item.persona_contacto || item.nombre_propietario}</div>` : ''}
          ${item.numero_contacto || item.contacto_propietario ? 
            `<div class="detail-item">Tel√©fono de contacto: ${item.numero_contacto || item.contacto_propietario}</div>` : ''}
        `;
    
    const personPhoto = document.getElementById('person-photo');
    if(item.person_coords_face != null){
      personPhoto.style.backgroundImage = `url(/personimages/inputs/${item.matched_ident}.jpg)`;
    } else {
      // L√≥gica para vehicle photo
      const containerW = 90;
      const containerH = 100;
      const [xf1, yf1, xf2, yf2] = (item.vehicle_coords_plate || "0,0,1,1").split(",").map(Number);
      const [xb1, yb1] = (item.vehicle_coords_obj || "0,0").split(",").map(Number);
      
      const x1 = xf1 + xb1;
      const y1 = yf1 + yb1;
      const w = xf2 - xf1;
      const h = yf2 - yf1;

      const [xo1, yo1, xo2, yo2] = (item.vehicle_coords_obj || "0,0,1,1").split(",").map(Number);
      const w_obj = xo2 - xo1;
      const h_obj = yo2 - yo1;
      
      const img = new Image();
      img.src = item.foto;
      img.onload = () => {
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;
        const scale_ = Math.min(containerW / w_obj, containerH / h_obj);
        const bgW_ = imgW * scale_;
        const bgH_ = imgH * scale_;
        const bgX_ = (containerW - w_obj * scale_) / 2 - xo1 * scale_;
        const bgY_ = (containerH - h_obj * scale_) / 2 - yo1 * scale_;
    
        personPhoto.style.backgroundImage = `url(${item.foto})`;
        personPhoto.style.backgroundSize = `${bgW_}px ${bgH_}px`;
        personPhoto.style.backgroundPosition = `${bgX_}px ${bgY_}px`;
      };
    }   
    
    const croppedDetection = document.getElementById('cropped-detection');
    croppedDetection.innerHTML = '';
    
    createCroppedImage(croppedDetection, item.foto, 
                      (item.person_coords_face||item.vehicle_coords_plate), 
                      'Detecci√≥n', 
                      (item.person_coords_obj||item.vehicle_coords_obj),
                      90, 100);
  } else {
    if (personInfoPanel) personInfoPanel.style.display = 'none';
  }

  // Mostrar el modal primero
  showVideoModal();
  
  // Luego cargar el video seg√∫n el tipo
  if(item.person_coords_face != null){
    callAPI({
      method: 'gestion/getframesperson',
      params: {
        camara: item.camera_id,
        tracking_id: item.tracking_id,
        documento: item.matched_ident,
      },
      ok: function (data) {
        const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
        if (!videoContainer) return;
        
        videoContainer.innerHTML = '';
        videoPlayer = new videoplay(videoContainer);
        
        const frames = data;
        const grouped = Object.values(
          frames.reduce((acc, frame) => {
            if (!acc[frame.foto]) {
              acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
            }
            acc[frame.foto].coords_obj.push({
              categoria: frame.category,
              accuracy_obj: frame.acc_parecido,
              colorupper: frame.color_name_upper,
              colorlower: frame.color_name_lower,
              coords: (frame.coords_obj || '').split(","),
              coordsplate: (frame.coords_face || '').split(","),
              plate: item.nombre + " " + item.apellido
            });
            return acc;
          }, {})
        ).sort((a, b) => a.foto.localeCompare(b.foto));
        
        videoPlayer.update(grouped, "foto", "coords_obj", null);
        setTimeout(() => { 
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 100);
      },
      error: function(error) {
        log("Error al cargar video de persona:", error);
      }
    });
  } else {
    callAPI({
      method: 'gestion/dolistimgbytrackid',
      params: { 
        cameraid: item.camera_id,
        tracking_id: item.tracking_id
      },
      ok: function(data) {
        const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
        if (!videoContainer) return;
        
        videoContainer.innerHTML = '';
        videoPlayer = new videoplay(videoContainer);
        
        const frames = data[2];
        const grouped = Object.values(
          frames.reduce((acc, frame) => {
            if (!acc[frame.foto]) {
              acc[frame.foto] = { foto: frame.foto, coords_obj: [] };
            }
            acc[frame.foto].coords_obj.push({
              categoria: frame.category,
              accuracy_obj: frame.accuracy_obj,
              colorupper: frame.color_name_upper,
              colorlower: frame.color_name_lower,
              coords: (frame.coords_obj || '').split(","),
              coordsplate: (frame.coords_plate || '').split(","),
              plate: frame.plate
            });
            return acc;
          }, {})
        ).sort((a, b) => a.foto.localeCompare(b.foto));
        
        videoPlayer.update(grouped, "foto", "coords_obj", null);
        setTimeout(() => { 
          try {
            videoPlayer.play();
          } catch (e) {
            log("Error al reproducir video:", e);
          }
        }, 100);
      },
      error: function(error) {
        log("Error al cargar video por trackid:", error);
      }
    });
  }
}

// Funci√≥n para ver video de b√∫squeda por caracter√≠sticas
function playVideoCaracteristicas(row) {
    resetVideoModal('caracteristicas');
    
    // Actualizar informaci√≥n en el modal
    document.getElementById("showcamera").textContent = row.cameraname;
    document.getElementById("showUbication").textContent = row.location;
    document.getElementById("showAlert").textContent = "B√∫squeda por Caracter√≠sticas";
    document.getElementById("showId").textContent = row.j || row.id;

    const personInfoPanel = document.getElementById('person-info-panel');
    const photoShort = document.getElementById('photo-short');
    
    if (personInfoPanel && photoShort) {
        personInfoPanel.style.display = 'block';
        photoShort.style.display = 'flex';
        
        const dataPerson = document.getElementById('person-data');
        dataPerson.innerHTML = `
            <div class="detail-item">ID: ${row.j || row.id}</div>
            <div class="detail-item">C√°mara: ${row.cameraname}</div>
            <div class="detail-item">Fecha: ${row.date_start}</div>
            <div class="detail-item">Color Superior: ${row.colorup || 'N/A'}</div>
            <div class="detail-item">Color Inferior: ${row.colorlow || 'N/A'}</div>
            <div class="detail-item">Sexo: ${row.sexo || 'N/A'}</div>
            <div class="detail-item">Edad: ${row.val_edad || 'N/A'}</div>
            <div class="detail-item">Ubicaci√≥n: ${row.location}</div>
        `;
        
        const croppedDetection = document.getElementById('cropped-detection');
        const personPhoto = document.getElementById('person-photo');
        
        if (croppedDetection) {
            croppedDetection.innerHTML = '';
            createCroppedImageCaracteristicas(croppedDetection, row.foto_frame, row.coords_obj, 90, 100);
        }
        
        if (personPhoto) {
            personPhoto.style.backgroundImage = `none`;
            personPhoto.innerHTML = '<div style="color: var(--ink); text-align: center; padding-top: 40px;">Sin foto de referencia</div>';
        }
    }

    // Mostrar el modal primero
    showVideoModal();
    
    // Luego cargar el video
    callAPI({
        method: 'gestion/getframespersoncaract',
        params: {
            camara: row.camera_id,
            tracking_id: row.xtracking_id,
        },
        ok: function (data) {
            const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
            if (!videoContainer) return;
            
            videoContainer.innerHTML = '';
            try {
                videoPlayer = new videoplay(videoContainer);
            } catch (e) {
                log("Error al crear video player:", e);
                return;
            }

            const grouped = Object.values(
                data.reduce((acc, item) => {
                    if (!item.coords_obj) return data;

                    if (!acc[item.foto]) {
                        acc[item.foto] = {
                            foto: item.foto,
                            coords_obj: []
                        };
                    }

                    acc[item.foto].coords_obj.push({
                        categoria: item.category,
                        accuracy_obj: item.accuracy_obj,
                        colorupper: item.color_name_upper,
                        colorlower: item.color_name_lower,
                        coords: (item.coords_obj || '').split(","),
                        coordsface: (item.coords_face || '').split(","),
                        plate: row.nombre
                    });
                    return acc;
                    
                }, {})
            ).sort((a, b) => a.foto.localeCompare(b.foto));

            try {
                videoPlayer.update(grouped, "foto", "coords_obj")
                setTimeout(() => { 
                    try {
                        videoPlayer.play();
                    } catch (e) {
                        log("Error al reproducir video:", e);
                    }
                }, 100)
            } catch (e) {
                log("Error al actualizar video player:", e);
            }
        },
        error: function (error) {
            log("Error al cargar el video de caracter√≠sticas:", error);
        }
    });
}

let cameraCount=0;

function getCamaras() {
    
    const canvas = document.getElementById("boardCanvas");
    if (canvas) {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = configTablero.colorFondo;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = "var(--teal)";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Cargando c√°maras y subzonas...", canvas.width/2, canvas.height/2);
    }
    
    callAPI({
        method: 'gestion/camarabytype',
        params: {},
        ok: function (vals) {
            
            cameraCount = vals.length;
            let camarasAsignadas = 0;
            let camarasNoAsignadas = 0;
            
            // MEJORADO: Asignaci√≥n mejorada de c√°maras a cuadrantes
            vals.forEach(cam => {
                let ambienteEncontrado = null;
                let pisoEncontrado = null;
                
                // B√öSQUEDA MEJORADA: Buscar en todos los tipos de ambientes
                if (cam.id_cuadrante) {
                    ambienteEncontrado = findAmbienteByCuadranteId(cam.id_cuadrante);
                    
                    if (ambienteEncontrado) {
                        pisoEncontrado = ambienteEncontrado.piso;
                        //log(`‚úì C√°mara ${cam.camera_id} asignada a: ${ambienteEncontrado.ambiente.nombre} (${ambienteEncontrado.ambiente.tipo})`);
                    } else {
                        // B√∫squeda alternativa por nombre
                        ambienteEncontrado = findAmbienteByCameraName(cam);
                        if (ambienteEncontrado) {
                            pisoEncontrado = ambienteEncontrado.piso;
                            //log(`‚úì C√°mara ${cam.camera_id} asignada por nombre a: ${ambienteEncontrado.ambiente.nombre}`);
                        }
                    }
                }
                
                if (ambienteEncontrado && pisoEncontrado) {
                    // Posicionar c√°mara en el v√©rtice del ambiente
                    const posicion = calcularPosicionEnVertice(ambienteEncontrado.ambiente);
                    if (posicion) {
                        cam.coords = posicion;
                        cam.piso = pisoEncontrado;
                        cam.location = `${pisoEncontrado} - ${ambienteEncontrado.ambiente.nombre}`;
                        cam.ambiente_asignado = ambienteEncontrado.ambiente;
                        camarasAsignadas++;
                    } else {
                        asignarPosicionPorDefecto(cam);
                        camarasNoAsignadas++;
                        log(`‚úó No se pudo calcular posici√≥n para c√°mara ${cam.camera_id}`);
                    }
                } else {
                    asignarPosicionPorDefecto(cam);
                    camarasNoAsignadas++;
                    log(`‚úó No se encontr√≥ ambiente para c√°mara ${cam.camera_id} (ID cuadrante: ${cam.id_cuadrante})`);
                }
            });
            
            log(`Resumen de asignaci√≥n: ${camarasAsignadas} c√°maras asignadas, ${camarasNoAsignadas} no asignadas`);
            
            camerasData = vals;
            cameraIds = camerasData.map(item => item.id);
            
            if (dashboard.style.display === 'block') {
                obtenerFramesPersonas();
            }
            
            render();
        },
        error: function (error) {
            log("Error al obtener las c√°maras:", error);
            // Datos de respaldo para pruebas
            camerasData = [
                {
                    "id": 1,
                    "camera_id": "C√°mara Vehicular S1",
                    "location": "S√≥tano 1 - Estacionamientos S1",
                    "latitud": -12.070,
                    "longitud": -77.039,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [-50, -40, 0],
                    "piso": "S√≥tano 1"
                },
                {
                    "id": 2,
                    "camera_id": "C√°mara Salida Vehicular",
                    "location": "S√≥tano 2 - Estacionamientos S2",
                    "latitud": -12.071,
                    "longitud": -77.038,
                    "estado_general": "inactivo",
                    "fecha_registro": new Date(Date.now() - 3600000).toISOString(),
                    "coords": [-30, -80, 20],
                    "piso": "S√≥tano 2"
                },
                {
                    "id": 3,
                    "camera_id": "C√°mara Parking",
                    "location": "S√≥tano 3 - Estacionamientos S3",
                    "latitud": -12.072,
                    "longitud": -77.037,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [40, -120, -30],
                    "piso": "S√≥tano 3"
                },
                {
                    "id": 4,
                    "camera_id": "C√°mara Recepci√≥n",
                    "location": "Piso 1 - Recepci√≥n",
                    "latitud": -12.073,
                    "longitud": -77.036,
                    "estado_general": "activo",
                    "fecha_registro": new Date().toISOString(),
                    "coords": [75, 0, -45],
                    "piso": "Piso 1"
                }
            ];
            render();
        }
    });
}

function findAmbienteByCuadranteId(cuadranteId) {
    if (!edificio.pisos) return null;
    
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            // Buscar por id_cuadrante
            if (ambiente.id_cuadrante && ambiente.id_cuadrante.toString() === cuadranteId.toString()) {
                return { ambiente, piso: piso.nombre };
            }
            // Buscar por id_subzona
            if (ambiente.id_subzona && ambiente.id_subzona.toString() === cuadranteId.toString()) {
                return { ambiente, piso: piso.nombre };
            }
            // Buscar por id_zona
            if (ambiente.id_zona && ambiente.id_zona.toString() === cuadranteId.toString()) {
                return { ambiente, piso: piso.nombre };
            }
        }
    }
    return null;
}

// NUEVA FUNCI√ìN: Buscar ambiente por nombre de c√°mara
function findAmbienteByCameraName(camara) {
    if (!edificio.pisos) return null;
    
    const camName = (camara.camera_name || '').toLowerCase();
    const camLocation = (camara.location || '').toLowerCase();
    
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            const ambientName = (ambiente.nombre || '').toLowerCase();
            const pisoName = (piso.nombre || '').toLowerCase();
            
            // Coincidencia directa en nombre de ambiente
            if (ambientName && camName.includes(ambientName)) {
                return { ambiente, piso: piso.nombre };
            }
            
            // Coincidencia en ubicaci√≥n
            if (ambientName && camLocation.includes(ambientName)) {
                return { ambiente, piso: piso.nombre };
            }
            
            // Coincidencia por piso
            if (camLocation.includes(pisoName) && ambientName.includes(pisoName)) {
                return { ambiente, piso: piso.nombre };
            }
        }
    }
    
    return null;
}

// NUEVA FUNCI√ìN: Calcular posici√≥n en v√©rtice de ambiente
function calcularPosicionEnVertice(ambiente) {
    if (!ambiente.vertices || ambiente.vertices.length === 0) {
        return null;
    }
    
    // Usar el primer v√©rtice como posici√≥n (puedes ajustar esta l√≥gica)
    const primerVertice = ambiente.vertices[0];
    
    // Verificar que el v√©rtice tenga coordenadas v√°lidas
    if (Array.isArray(primerVertice) && primerVertice.length >= 2) {
        const x = primerVertice[0];
        const y = primerVertice[1];
        const z = primerVertice.length >= 3 ? primerVertice[2] : 0;
        return [x, y, z];
    }
    
    return null;
}


function calcularPosicionCentral(ambiente) {
    if (!ambiente.vertices || ambiente.vertices.length < 3) {
        return null;
    }
    
    const vertices = ambiente.vertices;
    let sumX = 0, sumZ = 0;
    
    vertices.forEach(vertex => {
        sumX += vertex[0];
        sumZ += vertex[2];
    });
    
    const centerX = sumX / vertices.length;
    const centerZ = sumZ / vertices.length;
    const y = vertices[0][1]; // Altura del piso
    
    return [centerX, y, centerZ];
}

function asignarPosicionPorDefecto(camara) {
    // Asignar posici√≥n basada en el tipo de c√°mara o nombre
    const camLocation = (camara.location || '').toLowerCase();
    let piso = "Piso 1";
    let coords = [0, 0, 0];
    
    if (camLocation.includes('s√≥tano') || camLocation.includes('sotano')) {
        if (camLocation.includes('1')) {
            piso = "S√≥tano 1";
            coords = [-50, -40, 0];
        } else if (camLocation.includes('2')) {
            piso = "S√≥tano 2";
            coords = [-30, -80, 20];
        } else if (camLocation.includes('3')) {
            piso = "S√≥tano 3";
            coords = [40, -120, -30];
        }
    } else if (camLocation.includes('piso')) {
        if (camLocation.includes('1')) {
            piso = "Piso 1";
            coords = [75, 0, -45];
        } else if (camLocation.includes('2')) {
            piso = "Piso 2";
            coords = [60, 40, -30];
        } else if (camLocation.includes('3')) {
            piso = "Piso 3";
            coords = [45, 80, -15];
        } else if (camLocation.includes('4')) {
            piso = "Piso 4";
            coords = [30, 120, 0];
        } else if (camLocation.includes('5')) {
            piso = "Piso 5";
            coords = [15, 160, 15];
        }
    }
    
    camara.coords = coords;
    camara.piso = piso;
}


// ==========================
// Funci√≥n para buscar ambiente por id_cuadrante
// ==========================
function findAmbienteByCuadrante(cuadranteId) {
    if (!edificio.pisos) return null;
    
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            // Buscar por id_cuadrante
            if (ambiente.id_cuadrante && ambiente.id_cuadrante.toString() === cuadranteId.toString()) {
                return { ambiente, piso };
            }
            // Tambi√©n buscar por id_subzona como fallback
            if (ambiente.id_subzona && ambiente.id_subzona.toString() === cuadranteId.toString()) {
                return { ambiente, piso };
            }
        }
    }
    return null;
}

// Funci√≥n para obtener ambientes por tipo (MODIFICADA)
function getAmbientesByType(type) {
    const ambientes = [];
    
    if (!edificio.pisos) return ambientes;
    
    edificio.pisos.forEach(piso => {
        piso.ambientes.forEach(ambiente => {
            // CORRECCI√ìN: Usar el nombre del piso en lugar del objeto completo
            const nombreAmbiente = ambiente.nombre ? ambiente.nombre.toLowerCase() : '';
            const nombrePiso = piso.nombre ? piso.nombre.toLowerCase() : '';
            
            if (type === 'estacionamiento') {
                if ((nombrePiso.includes('s√≥tano') || nombrePiso.includes('piso 1')) && 
                    (nombreAmbiente.includes('estacionamiento') || 
                     nombreAmbiente.includes('parking') ||
                     nombreAmbiente.includes('estacionamientos'))) {
                    // CORRECCI√ìN: Crear copia del ambiente con referencia al nombre del piso
                    ambientes.push({
                        ...ambiente,
                        piso: piso.nombre // Solo el nombre, no el objeto completo
                    });
                }
            } else if (type === 'piso') {
                if (!nombrePiso.includes('s√≥tano') &&
                    !nombrePiso.includes('piso 5') &&
                    !nombreAmbiente.includes('estacionamiento') &&
                    !nombreAmbiente.includes('parking')) {
                    // CORRECCI√ìN: Crear copia del ambiente con referencia al nombre del piso
                    ambientes.push({
                        ...ambiente,
                        piso: piso.nombre // Solo el nombre, no el objeto completo
                    });
                }
            }
        });
    });
    
    return ambientes;
}

// Funci√≥n para resetear el modal de video
function resetVideoModal(type) {
  if (videoPlayer) {
    try {
      videoPlayer.stop();
    } catch (e) {
      log("Error al detener video player:", e);
    }
    videoPlayer = null;
  }
  
  const videoContainer = document.querySelector("#videoOvl .video-player-wrapper");
  if (videoContainer) videoContainer.innerHTML = '';
  
  const personInfoPanel = document.getElementById('person-info-panel');
  const photoShort = document.getElementById('photo-short');
  
  if (photoShort) {
    photoShort.style.display = type === 'person' || type === 'caracteristicas' ? 'flex' : 'none';
  }
  
  if (personInfoPanel) {
    personInfoPanel.style.display = (type === 'person' || type === 'caracteristicas') ? 'block' : 'none';
  }
}

function closeZonasModal() {
    const modal = document.getElementById('zonasModal');
    modal.style.display = 'none';
}

// Inicializar event listeners para el modal de video
document.addEventListener('DOMContentLoaded', function() {
    
    // Listener para el bot√≥n de seleccionar zonas
    const btnSeleccionarZonas = document.getElementById('btnSeleccionarZonas');
    if (btnSeleccionarZonas) {
        btnSeleccionarZonas.addEventListener('click', showUbicacionModal);
    }

    // Listener para cerrar el modal de zonas
    document.getElementById('btnCerrarZonas').addEventListener('click', closeZonasModal);
    
    document.getElementById('zonasModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeZonasModal();
        }
    });

    // Listener para el bot√≥n aplicar
    document.getElementById('btnAplicarZonas').addEventListener('click', function() {
        updateZonasSeleccionadasDisplay();
        closeZonasModal();
    });

    // Listener para el bot√≥n limpiar
    document.getElementById('btnLimpiarZonas').addEventListener('click', function() {
        subzonasSeleccionadas.clear();
        nombresSubzonasSeleccionadas.clear();
        // Desmarcar todos los checkboxes en la lista
        document.querySelectorAll('#lista-zonas input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = false;
        });
        updateZonasSeleccionadasDisplay();
        updateSelectAllButtonText(); // NUEVO: Actualizar texto del bot√≥n
    });
    
    document.getElementById('btnBackToAll').addEventListener('click', function() {
        // NUEVO: Mostrar loader
        showGlobalLoader(true);
        
        // LIMPIAR RUTA
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        
        // LIMPIAR ESTADO DE B√öSQUEDA - A√ëADIDO: Resetear currentSearchType
        currentSearchType = null;
        currentSearchResults = null;
        
        // Ocultar el box de persona seleccionada
        document.getElementById('selectedPersonBox').style.display = 'none';
        
        // Resetear el filtro de c√°maras por inter√©s
        filteredCamerasByInteres = null;
        selectedInteresItem = null;
        
        // Restaurar resaltado permanente de todas las alertas
        alertHighlightedCameras = {};
        // Volver a cargar todas las alertas (forzando actualizaci√≥n)
        getAlertas(null);
        
        // Restaurar t√≠tulo
        document.querySelector('.panel h3').textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
        
        // Ocultar bot√≥n de volver
        document.getElementById('btnBackToAll').style.display = 'none';
        
        // Ocultar resultados de b√∫squeda por placa
        document.getElementById('placa-results').innerHTML = '';
        document.getElementById('placa-search-form').style.display = 'none';
        document.getElementById('placa-input').value = '';
        
        document.getElementById('placa-search-form').style.display = 'none';
        document.getElementById('caracteristicas-search-form').style.display = 'none';
        document.getElementById('placa-input').value = '';
        
        // Ocultar resultados de b√∫squeda por caracter√≠sticas
        document.getElementById('caracteristicas-results').innerHTML = '';
        document.getElementById('caracteristicas-search-form').style.display = 'none';
        
        // Forzar re-renderizado para mostrar todas las c√°maras
        render();
        setTimeout(() => {
            // NUEVO: Ocultar loader
            showGlobalLoader(false);
        }, 1000);
    });


    // Event listener para cerrar el panel de detalles
    const closeButton = document.querySelector('.close-details');
    if (closeButton) {
        closeButton.addEventListener('click', function() {
            const alertDetails = document.getElementById('alert-details');
            if (alertDetails) {
                alertDetails.style.display = 'none';
            }
            
            // Restaurar completamente el estado de las c√°maras
            highlightedCamera = null;
            forceShowCamera = null;
            selectedAlert = null;
            
            // Restaurar el resaltado dorado permanente de todas las alertas
            alertHighlightedCameras = {};
            
            // Si hay un inter√©s seleccionado, restaurar sus c√°maras
            if (selectedInteresItem !== null) {
                // Recargar las alertas del inter√©s para restaurar el resaltado
                let itemBusqueda = interesData.find(data => data.id == selectedInteresItem.id);
                if (itemBusqueda) {
                    callAPI({
                        method: 'gestion/getalerts',
                        params: {
                            camera_name: "UTEC",
                            ...(itemBusqueda.matched_plate && { matched_plate: itemBusqueda.matched_plate }),
                            ...(itemBusqueda.id && { matched_ident: itemBusqueda.id })
                        },
                        ok: function (vals) {
                            const alertasInteres = vals.data;
                            const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];
                            render();
                        }
                    });
                }
            }
            
            // Forzar re-renderizado
            render();
        });
    }


  // Event listener para el bot√≥n de ver video
  const viewVideoBtn = document.getElementById('view-video-btn');
  if (viewVideoBtn) {
    viewVideoBtn.addEventListener('click', function() {
      if (selectedAlert) {
          log("selectedAlert",selectedAlert)
        if(selectedAlert.tracking_id != null){
          verVideoPersona(selectedAlert);   
        } else {
          verVideo(selectedAlert);
        }
      }
    });
  }
});

function applyFilter() {
    // **CORRECCI√ìN: Usar filteredAlerts si existe (para inter√©s seleccionado), sino usar alertas**
    const baseAlerts = filteredAlerts !== null && filteredAlerts.length >= 0 ? filteredAlerts : alertas;
    
    if (currentFilter === 'all') {
        // Si hay filteredAlerts, mantenerlas, sino usar todas las alertas
        const alertsToShow = filteredAlerts !== null && filteredAlerts.length >= 0 ? [...filteredAlerts] : [...alertas];
        renderTimelineList(alertsToShow);
        hideClearFiltersButton();
        
        // RESTAURAR RESALTADO seg√∫n el contexto
        alertHighlightedCameras = {};
        if (selectedInteresItem !== null && filteredAlerts && filteredAlerts.length >= 2) {
            calculateAndDrawRoute();
        } else {
            currentRoute = null;
            routeAnimationProgress = 0;
            if (routeAnimation) {
                cancelAnimationFrame(routeAnimation);
                routeAnimation = null;
            }
        }
    } else {
        // Verificar si currentFilter es un tipo de alerta o una c√°mara
        const isAlertType = baseAlerts.some(alert => alert.type_event_name === currentFilter);
        
        let filteredResult;
        if (isAlertType) {
            // Filtro por tipo de alerta
            filteredResult = baseAlerts.filter(alert => alert.type_event_name === currentFilter);
        } else {
            // Filtro por c√°mara
            filteredResult = baseAlerts.filter(alert => alert.camera_name === currentFilter);
        }
        
        renderTimelineList(filteredResult);
        showClearFiltersButton();
        
        // Limpiar resaltado permanente cuando se aplica un filtro
        clearAlertHighlights();
        
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
    }
    
    render();
}
// Variables globales para filtros
let currentFilter = 'all';
let filteredAlerts = [];
let lastAlertIds = new Set();

// ==========================
// Funci√≥n para identificar nuevas alertas (MODIFICADA)
// ==========================
function identificarNuevasAlertas(alertasActuales) {
  const nuevosIds = new Set(alertasActuales.map(a => a.id));
  const nuevasAlertas = alertasActuales.filter(a => !lastAlertIds.has(a.id));
  
  // ACTUALIZAR: Guardar los IDs actuales para la pr√≥xima verificaci√≥n
  lastAlertIds = nuevosIds;
  
  return {
    nuevas: nuevasAlertas,
    todas: alertasActuales
  };
}

// Modificar la funci√≥n showInteresModal para aceptar el tipo de b√∫squeda
function showInteresModal(searchType) {
    // Establecer el tipo de b√∫squeda activa
    currentSearchType = searchType;
    const modal = document.getElementById('interesOvl');
    modal.style.display = 'flex';
    
    // Cambiar el t√≠tulo seg√∫n el tipo de b√∫squeda
    const title = document.getElementById('interesModalTitle');
    if (title) {
        if (searchType === 'personas') {
            title.textContent = 'B√∫squeda de Personas de Inter√©s';
        } else if (searchType === 'vehiculos') {
            title.textContent = 'B√∫squeda de Veh√≠culos de Inter√©s';
        } else {
            title.textContent = 'B√∫squeda Avanzada';
        }
    }
    
    // Cargar directamente la lista correspondiente
    if (searchType === 'personas') {
        loadInteresList();
    } else if (searchType === 'vehiculos') {
        loadVehicleList();
    }
}

// Funci√≥n simplificada para cargar veh√≠culos
function loadVehicleList() {
    const container = document.getElementById('interesModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de veh√≠culos...</div></div>';
    
    callAPI({
        method: 'gestion/get_vehiculos_lista',
        ok: function(data) {
            interesData = data;
            renderInteresList(data, container, 2);
        },
        error: function(error) {
            log("Error al cargar la lista de veh√≠culos:", error);
            container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

// Funci√≥n para cerrar el modal de inter√©s
function closeInteresModal() {
    const modal = document.getElementById('interesOvl');
    modal.style.display = 'none';
}

// Event listeners para cerrar el modal
document.getElementById('closeInteresModal').addEventListener('click', closeInteresModal);
document.getElementById('interesOvl').addEventListener('click', function(e) {
    if (e.target === this) {
        closeInteresModal();
    }
});

// Funci√≥n para cargar la lista de inter√©s
function loadInteresList() {
    const container = document.getElementById('interesModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de inter√©s...</div></div>';
    callAPI({
        method: 'gestion/getiperson',
        params: {
            id_lista: 'all',
            nombre: 'all',
            ident_nro: 'all'
        },
        ok: function(data) {
            interesData = data;
            const container = document.getElementById('interesModalContent');
            renderInteresList(data, container, 1);
        },
        error: function(error) {
            log("Error al cargar la lista de inter√©s:", error);
            document.getElementById('interesModalContent').innerHTML = 
                '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

let interesData = null;
// Funci√≥n para renderizar la lista de inter√©s
function renderInteresList(data, container, category) {
    container.style.width='100%';
    
    if (!data || data.length === 0) {
        container.innerHTML = `<div class="loading">No hay ${category==1?"personas":"veh√≠culos"} de inter√©s</div>`;
        return;
    }
    
    // Generar un ID √∫nico para la tabla basado en la categor√≠a
    const tableId = `interesTable-${category}`;
    const filterId = `filterInteres-${category}`;
    
    let html = `
        <div style="margin-bottom: 15px;">
            <input type="text" id="${filterId}" placeholder="Buscar por nombre, apellido, documento, placa, etc..." 
                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal);background:var(--panel)">
        </div>
        <div style="max-height: 400px; overflow-y: auto;">
            <table class="table table-hover-1" id="${tableId}">
                <thead>
                    <tr>
                        ${data[0].foto?`<th>Foto</th>`:``}
                        <th>Nombre</th>
                        ${data[0].nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}
                        ${data[0].nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}
                        <th>Lista</th>
                        <th>Raz√≥n</th>
                        <th>Fecha de reporte</th>
                        ${data[0].nombre_propietario?`<th>Documento de propietario</th>`:``}
                        <th>Persona de contacto</th>
                        <th>N√∫mero de contacto</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    data.forEach(item => {
        let foto=null;
        if(item.foto){
            foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
            `<img src="${item.foto}" 
                  style="width:40px; height:40px; object-fit:cover; border-radius:8px;" 
                  onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
            `<img src="/public/images/logowin.png" 
                  style="width:40px; height:40px; object-fit:cover; border-radius:50%;">`;
        }
        const time = new Date(item.fh_crea||item.fecha_robo||item.created_at);
        const formattedTime = time.toLocaleString('es-PE');
        let name = (item.parentesco && item.parentesco!=null?item.parentesco+' - ':'') + (item.persocontacname||item.nombre_propietario?(item.persocontacname||item.nombre_propietario):'')
        html += `
            <tr class="interes-item" data-id="${item.id}" data-tipo="${item.tipo}" 
                style="cursor: pointer; border-bottom: 1px solid rgba(34,230,217,0.2);">
                ${foto?`<td>${foto}</td>`:``}
                <td>${item.personame || item.name || 'N/A'}</td>
                <td>${item.documento || item.marca+" "+item.modelo || 'N/A'}</td>
                <td>${item.edad || item.color || 'N/A'}</td>
                <td>${obtainList(item.id_lista.toString(),category) || 'N/A'}</td>
                <td>${item.descripcion || 'N/A'}</td>
                <td>${formattedTime || 'N/A'}</td>
                ${category==2?(item.nombre_propietario?`<td>${item.tipo_documento+' - '+item.num_documento || 'N/A'}</td>`:`<td>N/A</td>`):``}
                <td>${name!=''?name:'N/A' || 'N/A'}</td>
                <td>${item.persocontac || item.contacto_propietario || 'N/A'}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
    `;
    
    container.innerHTML = html;
    
    // A√±adir event listener para el filtro - CORREGIDO
    const filterInput = document.getElementById(filterId);
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const rows = container.querySelectorAll(`#${tableId} tbody tr`);
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                let found = false;
                
                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(filterText)) {
                        found = true;
                    }
                });
                
                row.style.display = found ? '' : 'none';
            });
        });
    }
    
    // A√±adir event listeners a las filas de la tabla - CORREGIDO
    container.querySelectorAll('.interes-item').forEach(item => {
        item.addEventListener('click', function() {
            const id = this.getAttribute('data-id');
            const tipo = this.getAttribute('data-tipo');
            selectInteresItem(id, tipo, category);
        });
    });
}

function obtainList(id_lista,category){
    switch(id_lista) {
        case "1":
            tipoPersona = 'Veh√≠culo Robado';
            break;
        case "2":
            tipoPersona = category==1?'Persona Sospechosa':'Veh√≠culo Sospechoso';
            break;
        case "3":
            tipoPersona = 'Persona Requisitoriada';
            break;
        case "4":
            tipoPersona = 'Persona Desaparecida';
            break;
        default:
            tipoPersona = 'Tipo no especificado';
    }
    
    return tipoPersona;
}

// Funci√≥n para seleccionar un item de inter√©s
function selectInteresItem(id, tipo, category) {
    // Limpiar ruta existente al seleccionar nuevo inter√©s
    currentRoute = null;
    
    routeAnimationProgress = 0;
    if (routeAnimation) {
        cancelAnimationFrame(routeAnimation);
        routeAnimation = null;
    }
    
    // Establecer el tipo de b√∫squeda activa
    currentSearchType = 'interes';
    
    // Limpiar filtros previos
    currentFilter = 'all';
    
    selectedInteresItem = { id, tipo };
    // INICIALIZAR CORRECTAMENTE EL FILTRO DE C√ÅMARAS
    filteredCamerasByInteres = []; // Inicializar como array vac√≠o
    
    let itemBusqueda = interesData.find(data => data.id == id);
    
    // Cerrar el modal
    closeInteresModal();
    
    // Ocultar bot√≥n de b√∫squeda avanzada y mostrar el de volver';
    document.getElementById('btnBackToAll').style.display = 'block';
    
    // Mostrar el box de persona seleccionada
    const selectedPersonBox = document.getElementById('selectedPersonBox');
    const selectedPersonDetails = document.getElementById('selectedPersonDetails');
    
    const time = new Date(itemBusqueda.fh_crea || itemBusqueda.fecha_robo || itemBusqueda.created_at);
    const formattedTime = time.toLocaleString('es-PE');
    
    // Determinar el tipo de persona seg√∫n id_lista
    let tipoPersona = obtainList(itemBusqueda.id_lista.toString(),category);
    
    // Limpiar resaltado permanente
    alertHighlightedCameras = {};
    
    if (itemBusqueda) {
        // Obtener alertas asociadas a esta persona de inter√©s
        callAPI({
            method: 'gestion/getalerts',
            params: {
                camera_name: "UTEC",
                ...(itemBusqueda.name && { matched_plate: itemBusqueda.name }),
                ...(itemBusqueda.id && { matched_ident: itemBusqueda.id })
            },
            ok: function (vals) {
                const alertasInteres = vals.data;
                
                // **CORRECCI√ìN: ASIGNAR LAS ALERTAS A filteredAlerts**
                filteredAlerts = alertasInteres ? [...alertasInteres] : [];
                
                // **ACTUALIZAR filteredCamerasByInteres CON LAS C√ÅMARAS FILTRADAS**
                if (alertasInteres && alertasInteres.length > 0) {
                    const cameraNames = [...new Set(alertasInteres.map(alert => alert.camera_name))];
                    filteredCamerasByInteres = camerasData.filter(cam => 
                        cameraNames.includes(cam.camera_id)
                    );
                } else {
                    // Si no hay alertas, mantener como array vac√≠o
                    filteredCamerasByInteres = [];
                }
                
                // **CORRECCI√ìN: Renderizar con las alertas filtradas**
                renderTimelineList(filteredAlerts);
                
                // **A√ëADIDO: Calcular y dibujar la ruta despu√©s de obtener las alertas**
                if (filteredAlerts.length >= 2) {
                    calculateAndDrawRoute();
                } else {
                    currentRoute = null;
                    routeAnimationProgress = 0;
                    if (routeAnimation) {
                        cancelAnimationFrame(routeAnimation);
                        routeAnimation = null;
                    }
                }
                
                render(); // Forzar re-renderizado del mapa
                
                // **CORRECCI√ìN: Actualizar KPIs con las alertas filtradas**
            },
            error: function (error) {
                log("Error al obtener alertas para el inter√©s:", error);
                // En caso de error, tratar como si no hubiera alertas
                filteredAlerts = [];
                filteredCamerasByInteres = [];
                renderTimelineList([]);
                
                // Limpiar ruta en caso de error
                currentRoute = null;
                routeAnimationProgress = 0;
                if (routeAnimation) {
                    cancelAnimationFrame(routeAnimation);
                    routeAnimation = null;
                }
                
                render();
            }
        });
    }
    
    // Llenar los detalles de la persona (siempre mostrar esto)
    let name = (itemBusqueda.parentesco && itemBusqueda.parentesco!=null?itemBusqueda.parentesco+' - ':'') + (itemBusqueda.persocontacname||itemBusqueda.nombre_propietario?(itemBusqueda.persocontacname||itemBusqueda.nombre_propietario):'')
    // En la funci√≥n selectInteresItem, cambiar:
    selectedPersonDetails.innerHTML = `
    <div style="display:flex; gap: 0.6em">
        <div>
        <div><strong>Nombre:</strong> ${itemBusqueda.nombre || itemBusqueda.name || 'N/A'}</div>
        <div><strong>Lista:</strong> ${tipoPersona}</div>
        <div><strong>${itemBusqueda.nombre_propietario?`<th>Modelo</th>`:`<th>Documento</th>`}:</strong> ${itemBusqueda.documento || itemBusqueda.marca+" "+itemBusqueda.modelo || 'N/A'}</div>
        <div><strong>${itemBusqueda.nombre_propietario?`<th>Color</th>`:`<th>Edad</th>`}:</strong> ${itemBusqueda.edad || itemBusqueda.color || 'N/A'}</div>
        <div><strong>Reportado:</strong> ${formattedTime || 'N/A'}</div>
        <div><strong>Raz√≥n:</strong> ${itemBusqueda.descripcion || 'N/A'}</div>
        <div><strong>Persona de contacto:</strong> ${name || 'N/A'}</div>
        <div><strong>N√∫mero de contacto:</strong> ${itemBusqueda.persocontac || itemBusqueda.contacto_propietario || 'N/A'}</div>
        </div>
        ${itemBusqueda.foto && !itemBusqueda.foto.startsWith('@') ? 
            `<div style="text-align:right;">
                <img src="${itemBusqueda.foto}" style="max-width: 100px; border-radius: 4px;">
            </div>` : ''}
    <div>
            
    `;
    selectedPersonBox.style.display = 'block';
      
    // Cambiar el t√≠tulo del timeline
    document.querySelector('.panel h3').textContent = 'Alertas relacionadas';
    closeInteresModal();
}

// Funci√≥n para cargar las alertas de inter√©s

function addBackButton() {
    // Verificar si ya existe el bot√≥n
    if (document.getElementById('backToAllAlerts')) return;
    
    const backButton = document.createElement('button');
    backButton.id = 'backToAllAlerts';
    backButton.className = 'btn btn-accent';
    backButton.textContent = 'Volver a todas las alertas';
    backButton.style.marginTop = '10px';
    
    backButton.addEventListener('click', function() {
        // LIMPIAR RUTA - NUEVO
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        
        // Ocultar el box de persona seleccionada
        document.getElementById('selectedPersonBox').style.display = 'none';
        
        // Resetear el filtro de c√°maras por inter√©s
        filteredCamerasByInteres = null;
        selectedInteresItem = null;
        
        // Volver a cargar todas las alertas
        getAlertas();
        
        // Restaurar t√≠tulo
        document.querySelector('.panel h3').textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
        
        // Forzar re-renderizado para mostrar todas las c√°maras
        render();
        
        // Eliminar el bot√≥n
        this.remove();
    });
    
    // Insertar despu√©s del timeline
    document.getElementById('timelineList').parentNode.appendChild(backButton);
}

// ==========================
// Funci√≥n para calcular y dibujar rutas de seguimiento
// ==========================
function calculateAndDrawRoute() {
    // MOSTRAR INDICADOR DE CARGA DE RUTA - NUEVO
    const canvas = document.getElementById("boardCanvas");
    if (canvas && currentRoute === null) {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "rgba(6, 25, 34, 0.8)";
        ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 20, 200, 40);
        ctx.fillStyle = "var(--teal)";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Calculando ruta...", canvas.width/2, canvas.height/2);
    }
    // Verificar que filteredAlerts tenga datos, si no, no dibujar ruta
    const alertsToUse = filteredAlerts && filteredAlerts.length > 0 ? filteredAlerts : [];
    
    // Verificaci√≥n m√°s estricta - solo dibujar si hay al menos 2 alertas
    if (!selectedInteresItem || !alertsToUse || alertsToUse.length < 2) {
        currentRoute = null;
        routeAnimationProgress = 0;
        if (routeAnimation) {
            cancelAnimationFrame(routeAnimation);
            routeAnimation = null;
        }
        render();
        return;
    }

    // Resto de la funci√≥n permanece igual...
    const sortedAlerts = [...alertsToUse].sort((a, b) => 
        new Date(a.init_time_frame) - new Date(b.init_time_frame)
    );

  // Obtener coordenadas de c√°maras en orden temporal
  const routePoints = [];
  sortedAlerts.forEach(alert => {
    const camera = camerasData.find(cam => cam.camera_id === alert.camera_name);
    if (camera && camera.coords) {
      routePoints.push({
        coords: camera.coords,
        cameraName: camera.camera_id,
        timestamp: alert.init_time_frame,
        alertType: alert.type_event_name
      });
    } else {
      log("C√°mara no encontrada para alerta:", alert.camera_name);
    }
  });

  // Eliminar duplicados consecutivos
  const uniqueRoutePoints = [];
  routePoints.forEach((point, index) => {
    if (index === 0 || point.cameraName !== routePoints[index-1].cameraName) {
      uniqueRoutePoints.push(point);
    }
  });

  if (uniqueRoutePoints.length < 2) {
    log("Ruta demasiado corta despu√©s de eliminar duplicados");
    currentRoute = null;
    if (routeAnimation) {
      cancelAnimationFrame(routeAnimation);
      routeAnimation = null;
    }
    return;
  }

  currentRoute = uniqueRoutePoints;
  routeAnimationProgress = 0;

  // Iniciar animaci√≥n
  if (currentRoute.length > 1) {
    startRouteAnimation();
  }
}

// ==========================
// Funci√≥n para animar la ruta
// ==========================
function startRouteAnimation() {
  if (routeAnimation) {
    cancelAnimationFrame(routeAnimation);
  }

  const startTime = Date.now();
  const duration = 10000; // 10 segundos para completar la animaci√≥n

  function animate() {
    const elapsed = Date.now() - startTime;
    routeAnimationProgress = Math.min(elapsed / duration, 1);
    
    render();
    
    if (routeAnimationProgress < 1) {
      routeAnimation = requestAnimationFrame(animate);
    } else {
      // Reiniciar la animaci√≥n cuando termine
      setTimeout(() => {
        routeAnimationProgress = 0;
        startRouteAnimation();
      }, 2000); // Esperar 2 segundos antes de reiniciar
    }
  }

  animate();
}

// ==========================
// Funci√≥n para dibujar la ruta en el mapa
// ==========================
function drawRoute() {
  // Verificar si debemos mostrar rutas y si hay una ruta v√°lida
  if (!showRoutes || !currentRoute || currentRoute.length < 2) {
    return;
  }

  // Validar que todos los puntos de la ruta tengan coordenadas v√°lidas
  const validRoute = currentRoute.filter(point => 
    point && point.coords && Array.isArray(point.coords) && point.coords.length === 3
  );
  
  if (validRoute.length < 2) {
    log("Ruta no v√°lida: menos de 2 puntos con coordenadas v√°lidas");
    return;
  }


  // Dibujar la l√≠nea de ruta completa (fondo)
  ctx.strokeStyle = 'rgba(255, 235, 59, 0.6)'; // Amarillo semi-transparente
  ctx.lineWidth = 4;
  ctx.setLineDash([10, 5]);
  ctx.beginPath();

  // Mover al primer punto
  const firstPoint = validRoute[0];
  const [firstX, firstY] = project(firstPoint.coords);
  ctx.moveTo(firstX, firstY);

  // Dibujar l√≠nea a trav√©s de todos los puntos
  for (let i = 1; i < validRoute.length; i++) {
    const point = validRoute[i];
    const [px, py] = project(point.coords);
    ctx.lineTo(px, py);
  }
  ctx.stroke();

  // Dibujar la animaci√≥n de progreso (l√≠nea s√≥lida)
  if (routeAnimationProgress > 0) {
    const totalSegments = validRoute.length - 1;
    const progressInSegments = routeAnimationProgress * totalSegments;
    const currentSegment = Math.floor(progressInSegments);
    const segmentProgress = progressInSegments - currentSegment;

    ctx.strokeStyle = '#22e6d9'; // Color teal
    ctx.lineWidth = 6;
    ctx.setLineDash([]); // L√≠nea s√≥lida
    ctx.beginPath();

    // Mover al primer punto
    ctx.moveTo(firstX, firstY);

    // Dibujar hasta el segmento actual completo
    for (let i = 1; i <= currentSegment; i++) {
      const point = validRoute[i];
      const [px, py] = project(point.coords);
      ctx.lineTo(px, py);
    }

    // Dibujar el segmento actual parcial si hay progreso
    if (currentSegment < totalSegments && segmentProgress > 0) {
      const startPoint = validRoute[currentSegment];
      const endPoint = validRoute[currentSegment + 1];
      
      const [startX, startY] = project(startPoint.coords);
      const [endX, endY] = project(endPoint.coords);
      
      const currentX = startX + (endX - startX) * segmentProgress;
      const currentY = startY + (endY - startY) * segmentProgress;
      
      ctx.lineTo(currentX, currentY);
    }

    ctx.stroke();
  }

  // Restablecer el estilo de l√≠nea
  ctx.setLineDash([]);

  // Dibujar puntos de la ruta
  validRoute.forEach((point, index) => {
    const [px, py] = project(point.coords);
    
    // Verificar si el punto es visible en pantalla
    if (px < 0 || px > canvas.width || py < 0 || py > canvas.height) {
      log(`Punto ${index + 1} fuera de pantalla:`, px, py);
      return; // Saltar puntos fuera de la pantalla
    }

    // Punto de ruta (c√≠rculo)
    ctx.beginPath();
    ctx.arc(px, py, 8, 0, 2 * Math.PI);
    
    // Color seg√∫n la posici√≥n en la ruta
    if (index === 0) {
      ctx.fillStyle = '#4caf50'; // Verde para inicio
    } else if (index === validRoute.length - 1) {
      ctx.fillStyle = '#f44336'; // Rojo para fin
    } else {
      ctx.fillStyle = '#ff9800'; // Naranja para puntos intermedios
    }
    
    ctx.fill();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // N√∫mero de secuencia
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((index + 1).toString(), px, py);

    // Etiqueta con timestamp (solo si hay zoom suficiente)
    if (zoom > 1.0) {
      const time = new Date(point.timestamp).toLocaleTimeString('es-PE', { 
        hour: '2-digit', 
        minute: '2-digit'
      });
      
      // Fondo para la etiqueta
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      const textWidth = ctx.measureText(time).width;
      const padding = 4;
      ctx.fillRect(px - textWidth/2 - padding, py - 35, textWidth + padding*2, 16);
      
      // Texto del timestamp
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px Arial';
      ctx.fillText(time, px, py - 27);
    }
  });

  // Dibujar flecha de direcci√≥n si hay m√°s de un punto
  if (validRoute.length > 1 && routeAnimationProgress > 0) {
    drawDirectionArrow(validRoute);
  }
}

// Funci√≥n auxiliar para dibujar flecha de direcci√≥n
function drawDirectionArrow(route) {
  const progressInSegments = routeAnimationProgress * (route.length - 1);
  const currentSegment = Math.floor(progressInSegments);
  const segmentProgress = progressInSegments - currentSegment;

  if (currentSegment < route.length - 1) {
    const startPoint = route[currentSegment];
    const endPoint = route[currentSegment + 1];
    
    const [startX, startY] = project(startPoint.coords);
    const [endX, endY] = project(endPoint.coords);
    
    const arrowX = startX + (endX - startX) * segmentProgress;
    const arrowY = startY + (endY - startY) * segmentProgress;
    
    // Calcular √°ngulo de la flecha
    const angle = Math.atan2(endY - startY, endX - startX);
    
    // Dibujar flecha
    ctx.save();
    ctx.translate(arrowX, arrowY);
    ctx.rotate(angle);
    
    ctx.fillStyle = '#22e6d9';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-10, -5);
    ctx.lineTo(-10, 5);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }
}


function initMapFilters() {
    const camerasCheckbox = document.getElementById('show-cameras');
    const zonasCheckbox = document.getElementById('show-zones');
    const subzonasCheckbox = document.getElementById('show-subzones');
    const routesCheckbox = document.getElementById('show-routes');
    
    // CORRECCI√ìN: Establecer showCameras como true por defecto
    showCameras = true;
    if (camerasCheckbox) {
        camerasCheckbox.checked = true;
        camerasCheckbox.addEventListener('change', function(e) {
            showCameras = e.target.checked;
            render();
        });
    }
    
    if (zonasCheckbox) {
        zonasCheckbox.addEventListener('change', function(e) {
            showZones = e.target.checked;
            render();
        });
    }
    
    if (subzonasCheckbox) {
        subzonasCheckbox.addEventListener('change', function(e) {
            showSubzones = e.target.checked;
            render();
        });
    }
    
    if (routesCheckbox) {
        routesCheckbox.addEventListener('change', function(e) {
            showRoutes = e.target.checked;
            render();
        });
    }
}

// Agregar variable global para controlar subzonas
let showSubzones = true;

// Funci√≥n para actualizar los contadores de la leyenda de c√°maras - MODIFICADO
function updateCameraLegendCounts(alertCount, normalCount) {
    const alertElement = document.getElementById('alert-cameras-count');
    const normalElement = document.getElementById('normal-cameras-count');
    
    // CORRECCI√ìN: Mostrar contadores reales basados en lo que se est√° mostrando
    if (alertElement) alertElement.textContent = alertCount;
    
    if (normalElement) {
        if (showCameras) {
            normalElement.textContent = normalCount;
        } else {
            // Si showCameras es false, no estamos mostrando c√°maras normales
            normalElement.textContent = "0";
        }
    }
}

// Event listeners para los botones de b√∫squeda
document.querySelectorAll('#busquedaContent .btn-default[data-search-type]').forEach(button => {
    button.addEventListener('click', function() {
        const searchType = this.getAttribute('data-search-type');
        
        // Ocultar todos los formularios primero
        document.getElementById('caracteristicas-search-form').style.display = 'none';
        document.getElementById('placa-search-form').style.display = 'none';
        document.getElementById('search-results').innerHTML = '';
        
        if (searchType === 'personas' || searchType === 'vehiculos') {
            // Mostrar modal de inter√©s para personas o veh√≠culos
            document.getElementById('selected-persons-container').style.display = 'block';
            showInteresModal(searchType);
        } else if (searchType === 'placa') {
            // Mostrar formulario de placa
            document.getElementById('selected-persons-container').style.display = 'block';
            document.getElementById('placa-search-form').style.display = 'block';
        } else if (searchType === 'caracteristicas') {
            // Mostrar formulario de caracter√≠sticas
            getColors();
            document.getElementById('selected-persons-container').style.display = 'block';
            document.getElementById('caracteristicas-search-form').style.display = 'block';
        } else if (searchType === 'personas-interes') {
            // Mostrar modal de selecci√≥n m√∫ltiple
            showMultiSelectModal();
        }
    });
});

// Funci√≥n para manejar los clics en los botones de b√∫squeda
function handleSearchTypeClick(searchType) {
    // Ocultar todos los formularios y resultados primero
    document.querySelectorAll('.search-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('search-results').innerHTML = '';

    // LIMPIAR B√öSQUEDAS ANTERIORES - NUEVO
    document.getElementById('selectedPersonBox').style.display = 'none';
    currentSearchType = null;
    currentSearchResults = null;
    filteredAlerts = null;
    selectedInteresItem = null;
    
    // Ocultar bot√≥n de volver
    document.getElementById('btnBackToAll').style.display = 'none';
    
    // Restaurar t√≠tulo original
    document.querySelector('.panel h3').textContent = 'Alertas en tiempo real (√öltimas 4 horas)';
    
    // Recargar alertas normales
    getAlertas(null);

    switch(searchType) {
        case 'personas':
        case 'vehiculos':
            showInteresModal(searchType);
            break;
        case 'placa':
            document.getElementById('placa-search-form').style.display = 'block';
            break;
        case 'caracteristicas':
            document.getElementById('caracteristicas-search-form').style.display = 'block';
            break;
    }
}

// Event listener para b√∫squeda por placa
document.getElementById('search-placa-btn').addEventListener('click', function() {
    const placa = document.getElementById('placa-input').value.trim();
    log("placa",placa);
    if (!placa) {
        alert('Por favor ingrese un n√∫mero de placa');
        return;
    }
    searchByPlaca(placa);
});

// Event listener para b√∫squeda por caracter√≠sticas
document.getElementById('search-caracteristicas-btn').addEventListener('click', function() {
    searchByCaracteristicas();
});

function searchByPlaca(placa) {
    // Establecer el tipo de b√∫squeda activa
    currentSearchType = 'placa';
    
    const resultsContainer = document.getElementById('placa-results');
    resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"><div class="spinner"></div><div>Buscando veh√≠culos con placa: ' + placa + '</div></div>';
    
    // NUEVO: Mostrar loader global
    showGlobalLoader(true);
    
    // Ocultar el panel de selecci√≥n
    document.getElementById('selectedPersonBox').style.display = 'none';
    
    // Mostrar bot√≥n de volver
    document.getElementById('btnBackToAll').style.display = 'block';
    
    callAPI({
        method: "gestion/dolistseguimientoalert",            
        params: {placa: placa},
        ok: (data) => {
            
            showGlobalLoader(false);
            log("data", data);
            
            // Guardar los resultados de la b√∫squeda
            currentSearchResults = data;
            
            showresultsearch(data);
            
            // Actualizar el contenedor de resultados con un mensaje
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                    <h5 style="color: var(--teal); margin-top: 0;">B√∫squeda completada</h5>
                    <div style="font-size: 14px;">
                        Se encontraron ${data ? data.length : 0} resultados para la placa: ${placa}
                    </div>
                    <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                        Los resultados se muestran en la lista de alertas a la derecha.
                    </div>
                </div>
            `;
        },
        error: (error) => {
            showGlobalLoader(false);
            log("Error en b√∫squeda por placa:", error);
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                    <h5 style="color: var(--orange); margin-top: 0;">Error en la b√∫squeda</h5>
                    <div style="font-size: 14px;">
                        No se pudieron obtener resultados para la placa: ${placa}
                    </div>
                </div>
            `;
        }
    });
}

function showresultsearch(data) {
    const timelineList = document.getElementById('timelineList');
    
    if (!timelineList) {
        console.error('Elemento timelineList no encontrado');
        return;
    }

    // Limpiar el contenido actual
    timelineList.innerHTML = '';

    if (!data || data.length === 0) {
        timelineList.innerHTML = '<div class="loading">No hay detecciones para mostrar</div>';
        return;
    }

    // Ordenar los datos por fecha (m√°s reciente primero)
    const sortedData = [...data].sort((a, b) => new Date(b.date_start) - new Date(a.date_start));

    // Obtener el tiempo actual para calcular opacidades
    const now = new Date();
    
    sortedData.forEach((item, index) => {
        const li = document.createElement('li');
        li.setAttribute('data-id', item.id || index);
        li.setAttribute('data-type', 'caracteristica');

        // Formatear la fecha
        const time = new Date(item.date_start);
        const formattedTime = time.toLocaleString('es-PE');
        
        // CALCULAR OPACIDAD BASADA EN EL TIEMPO TRANSCURRIDO
        const timeDiff = now - time; // Diferencia en milisegundos
        const minutesDiff = timeDiff / (1000 * 60); // Convertir a minutos
        
        // Reducir opacidad 0.1 cada 10 minutos, m√≠nimo 0.5
        const opacity = Math.max(0.4, 1 - (Math.floor(minutesDiff / 10) * 0.1));
        
        // APLICAR OPACIDAD AL ELEMENTO
        li.style.opacity = opacity;
        li.style.transition = 'opacity 0.3s ease'; // Transici√≥n suave

        // Construir el contenido del elemento de lista para caracter√≠sticas
        li.innerHTML = `
            <strong>Detecci√≥n ${index + 1}</strong>
            <div>C√°mara: ${item.cameraname || item.camera_name} ¬∑ ${item.location}</div>
            <div>Sexo: ${item.sexo || 'N/A'} | Edad: ${item.val_edad || 'N/A'}</div>
            <div>Color Superior: ${item.colorup || 'N/A'} | Color Inferior: ${item.colorlow || 'N/A'}</div>
            <time>${formattedTime}</time>
        `;

        // A√±adir event listener para mostrar detalles al hacer clic
        li.addEventListener('click', () => {
            playVideoCaracteristicas(item);
        });

        timelineList.appendChild(li);
    });

    // Cambiar el t√≠tulo del timeline para indicar que es b√∫squeda por caracter√≠sticas
    document.querySelector('.panel h3').textContent = 'Resultados de b√∫squeda por caracter√≠sticas';
}
/*
function showVehicleDetails(item) {
    const panel = document.getElementById('alert-details');
    const content = document.getElementById('alert-details-content');
    const title = document.getElementById('alert-details-title');
    
    if (!panel || !content || !title) {
        log("Elementos del panel de detalles no encontrados");
        return;
    }
    
    // Limpiar cualquier c√°mara previamente resaltada
    clearAlertHighlights();
    highlightedCamera = null;
    
    // Buscar y establecer la c√°mara asociada
    highlightedCamera = camerasData.find(cam => 
        cam.camera_id === item.camera_name
    );
    
    // Forzar mostrar solo esta c√°mara
    forceShowCamera = highlightedCamera;
    
    // Si encontramos una c√°mara, centrar la vista en ella
    if (highlightedCamera) {
        const [x, y, z] = highlightedCamera.coords;
        const [tx, ty] = project([x, y, z]);
        
        // Ajustar zoom y posici√≥n
        zoom = 2.0;
        offsetX = canvas.width/2 - (tx - canvas.width/2);
        offsetY = canvas.height/2 - (ty - canvas.height/2);
    }
    
    // Formatear la fecha
    const time = new Date(item.date_start);
    const formattedTime = time.toLocaleString('es-PE');
    
    title.textContent = `Detalle de Veh√≠culo: ${item.plate || 'N/A'}`;
    
    // Construir el contenido del panel de detalles
    let html = `
        <div style="max-width:320px">
            <h4 class="person-details-title">C√°mara: ${item.camera_name}</h4>
            <div class="detail-item">
                Ubicaci√≥n: ${item.location}
            </div>
            <div class="detail-item">
                Fecha y Hora: ${formattedTime}
            </div>
            <div class="detail-item">
                Placa: ${item.plate || 'N/A'}
            </div>
            <div class="detail-item">
                Color: ${item.color || 'N/A'}
            </div>
            <div class="detail-item">
                Categor√≠a: ${item.category || 'N/A'}
            </div>
            <div class="detail-item">
                Precisi√≥n: ${item.accuracy_obj || 'N/A'}%
            </div>
    `;
    
    // A√±adir frame si est√° disponible
    if (item.foto_frame) {
        html += `
            <div class="detail-item">
                Frame:<br>
                <img src="${item.foto_frame}" style="max-width:100%; margin-top:5px; border-radius:4px;">
            </div>
        `;
    }
    
    html += `</div>`;
    
    content.innerHTML = html;
    
    // Mostrar el panel
    panel.style.display = 'block';
    render();
}
*/

let subzonasSeleccionadas = new Map(); // Cambiar de Set a Map para almacenar id -> objeto completo
let nombresSubzonasSeleccionadas = new Set();

// Funci√≥n para mostrar el modal de selecci√≥n de zonas
function showUbicacionModal() {
    const modal = document.getElementById('zonasModal');
    
    // MOSTRAR EL MODAL
    modal.style.display = 'flex';
    
    // Cargar la lista de zonas
    loadZonasList();
}

// Funci√≥n para cargar la lista de zonas
function loadZonasList() {
    const container = document.getElementById('lista-zonas');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando zonas...</div></div>';
    
    callAPI({
        method: 'gestion/jerarquia_territorial',
        ok: function(data) {
            renderZonasList(data);
        },
        error: function(error) {
            log("Error al cargar zonas:", error);
            const container = document.getElementById('lista-zonas');
            container.innerHTML = '<div class="loading">Error al cargar las zonas</div>';
        }
    });
}

// Funci√≥n para renderizar la lista de zonas - MODIFICADA
function renderZonasList(zonasData) {
    const container = document.getElementById('lista-zonas');
    if (!container) return;
    
    if (!zonasData || Object.keys(zonasData).length === 0) {
        container.innerHTML = '<div class="loading">No hay zonas disponibles</div>';
        return;
    }
    
    let html = '<div style="display: flex; flex-direction: column; gap: 5px;">';
    
    // Convertir objeto a array y procesar cada zona
    Object.values(zonasData).forEach(zona => {
        // MODIFICADO: Usar solo id_subzona como ID (cuadrante)
        const zonaId = zona.id_subzona; // Solo el cuadrante
        const zonaNombre = zona.ubicacion || 'Sin nombre';
        const isSelected = subzonasSeleccionadas.has(zonaId);
        
        html += `
            <div class="zona-item" style="display: flex; align-items: center; padding: 8px; border-radius: 4px; border: 1px solid rgba(34,230,217,0.2); cursor: pointer; transition: background-color 0.3s ease;">
                <input type="checkbox" id="zona-${zonaId}" value="${zonaId}" 
                       ${isSelected ? 'checked' : ''}
                       style="margin-right: 10px; accent-color: var(--teal);">
                <label for="zona-${zonaId}" style="flex: 1; cursor: pointer; color: var(--ink);">
                    <strong>${zonaNombre}</strong>
                    <br><span style="font-size: 12px; color: var(--ink);">
                        √Årea: ${zona.id_area} | Zona: ${zona.id_zona} | Cuadrante: ${zona.id_subzona}
                    </span>
                </label>
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
    // Event listeners para los checkboxes - MODIFICADO
    container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const zonaId = this.value;
            const zonaItem = this.parentElement;
            const zonaNombre = zonaItem.querySelector('strong').textContent;
            
            // Buscar el objeto zona completo en los datos
            const zonaCompleta = Object.values(zonasData).find(z => 
                z.id_subzona === zonaId // MODIFICADO: Buscar por id_subzona
            );
            
            if (this.checked && zonaCompleta) {
                // MODIFICADO: Guardar objeto completo usando solo id_subzona como clave
                subzonasSeleccionadas.set(zonaId, {
                    id: zonaId,
                    nombre: zonaNombre,
                    datos: zonaCompleta
                });
                nombresSubzonasSeleccionadas.add(zonaNombre);
            } else {
                // MODIFICADO: Eliminar del Map usando id_subzona
                subzonasSeleccionadas.delete(zonaId);
                nombresSubzonasSeleccionadas.delete(zonaNombre);
            }
        });
    });
    
    // Resto del c√≥digo permanece igual...
    // NUEVO: Event listener para el bot√≥n "Seleccionar Todas"
    const btnSelectAll = document.getElementById('btnSelectAllZonas');
    if (btnSelectAll) {
        btnSelectAll.addEventListener('click', function() {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            const todasLasZonas = Object.values(zonasData);
            
            if (subzonasSeleccionadas.size === todasLasZonas.length) {
                // Si ya est√°n todas seleccionadas, deseleccionar todas
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                subzonasSeleccionadas.clear();
                nombresSubzonasSeleccionadas.clear();
            } else {
                // Seleccionar todas las zonas
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const zonaId = checkbox.value;
                    const zonaItem = checkbox.parentElement;
                    const zonaNombre = zonaItem.querySelector('strong').textContent;
                    
                    // Buscar el objeto zona completo
                    const zonaCompleta = todasLasZonas.find(z => 
                        z.id_subzona === zonaId // MODIFICADO: Buscar por id_subzona
                    );
                    
                    if (zonaCompleta) {
                        subzonasSeleccionadas.set(zonaId, {
                            id: zonaId,
                            nombre: zonaNombre,
                            datos: zonaCompleta
                        });
                        nombresSubzonasSeleccionadas.add(zonaNombre);
                    }
                });
            }
            
            // Actualizar texto del bot√≥n
            updateSelectAllButtonText();
        });
    }
    
    // Actualizar texto del bot√≥n "Seleccionar Todas" inicialmente
    updateSelectAllButtonText();
    
    // Event listener para el filtro
    const filterInput = document.getElementById('filterZonas');
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const zonaItems = container.querySelectorAll('.zona-item');
            
            zonaItems.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filterText) ? 'flex' : 'none';
            });
        });
    }
}

function updateSelectAllButtonText() {
    const btnSelectAll = document.getElementById('btnSelectAllZonas');
    if (!btnSelectAll) return;
    
    // Obtener datos de zonas para saber el total
    const container = document.getElementById('lista-zonas');
    if (!container) return;
    
    const totalCheckboxes = container.querySelectorAll('input[type="checkbox"]').length;
    
    if (subzonasSeleccionadas.size === totalCheckboxes && totalCheckboxes > 0) {
        btnSelectAll.textContent = 'Deseleccionar Todas';
        btnSelectAll.style.background = 'var(--orange)';
    } else {
        btnSelectAll.textContent = 'Seleccionar Todas';
        btnSelectAll.style.background = 'var(--teal)';
    }
}

// Funci√≥n para actualizar la visualizaci√≥n de zonas seleccionadas
function updateZonasSeleccionadasDisplay() {
    const button = document.getElementById('btnSeleccionarZonas');
    if (!button) return;
    
    if (nombresSubzonasSeleccionadas.size > 0) {
        const zonasList = Array.from(nombresSubzonasSeleccionadas);
        
        // MODIFICADO: Mostrar los nombres en el texto del bot√≥n con ellipsis
        if (zonasList.length > 3) {
            button.textContent = `${zonasList.length} zonas seleccionadas: ${zonasList.slice(0, 3).join(', ')}...`;
        } else {
            button.textContent = zonasList.join(', ');
        }
        button.style.color = 'var(--teal)';
        button.style.fontWeight = 'bold';
        // A√ëADIDO: Asegurar que el texto tenga ellipsis
        button.style.whiteSpace = 'nowrap';
        button.style.overflow = 'hidden';
        button.style.textOverflow = 'ellipsis';
    } else {
        button.textContent = 'Seleccionar Zonas/Subzonas';
        button.style.color = 'var(--ink)';
        button.style.fontWeight = 'normal';
        // A√ëADIDO: Asegurar que el texto tenga ellipsis
        button.style.whiteSpace = 'nowrap';
        button.style.overflow = 'hidden';
        button.style.textOverflow = 'ellipsis';
    }
}

// Event listener para el bot√≥n de seleccionar zonas
document.addEventListener('DOMContentLoaded', function() {
    const btnSeleccionarZonas = document.getElementById('btnSeleccionarZonas');
    if (btnSeleccionarZonas) {
        btnSeleccionarZonas.addEventListener('click', showUbicacionModal);
    }
});

function getvalues() {
    const fechaIni = $('#txtFechaIni').val()
    ? new Date($('#txtFechaIni').val() + 'T00:00:00').getTime()
    : "";

    const fechaFin = $('#txtFechaFin').val()
        ? new Date($('#txtFechaFin').val() + 'T23:59:59.999').getTime()
        : "";
        
    // MODIFICADO: Extraer solo los IDs de subzonas (cuadrantes) del Map
    const subzonasIds = Array.from(subzonasSeleccionadas.keys());
    const subzonasJson = JSON.stringify(subzonasIds);
    
    return {
        subzonas: subzonasJson,
        colorsuperior: $('#txtcolorsup').val().trim(),
        colorinferior: $('#txtcolorinf').val().trim(),
        sexo: $('#txtsexo').val().trim(),
        edad: $("#txtedad").val(),
        precision: null,
        fechaini: fechaIni,
        fechafin: fechaFin,
    }
}

function imageprocess(obj, time) {
    obj.onerror = null;

    var btn = obj.parentElement.parentElement.parentElement.querySelector('button')
    btn.setAttribute('disabled', 1);
    btn.className = "btn btn-w-md btn-secondary btn-rounded"

    setTimeout(
        () => {
            obj.src = '/images/logowin.png'
            obj.style.filter = 'grayscale(100%)'
            obj.style.opacity = '0.1'
        },
        time
    );
}

// Funci√≥n para b√∫squeda por caracter√≠sticas
function searchByCaracteristicas() {
    // Establecer el tipo de b√∫squeda activa
    currentSearchType = 'caracteristicas';
    const resultsContainer = document.getElementById('caracteristicas-results');
    
    // Obtener valores del formulario
    var values = getvalues();
    
    // Validar que al menos un campo est√© completado
    if (values.colorsuperior === 'all' && values.colorinferior === 'all' && values.sexo === 'all' && values.edad === 'all' && !values.fechaini && !values.fechafin) {
        alert('Por favor complete al menos un campo de b√∫squeda');
        return;
    }
    
    resultsContainer.innerHTML = '<div class="loading" style="text-align:center;padding:20px; display:flex; flex-direction:column; align-items:center; justify-content:center;"><div class="spinner"></div><div>Buscando personas con caracter√≠sticas...</div></div>';
    
    // Mostrar loader global
    showGlobalLoader(true);
    
    // Ocultar el panel de selecci√≥n
    document.getElementById('selectedPersonBox').style.display = 'none';
    
    // Mostrar bot√≥n de volver
    document.getElementById('btnBackToAll').style.display = 'block';
    
    callAPI({
        method: "gestion/getlistpersoncaract",
        params: values,
        ok: (data)=>{
            showGlobalLoader(false);
            log("dataobtenida",data);
        
            // FILTRO: Conservar solo las detecciones cuya c√°mara contenga "UTEC"
            if (data && Array.isArray(data)) {
                data = data.filter(item => item.cameraname && item.cameraname.includes('UTEC'));
            }
        
            // Guardar los resultados de la b√∫squeda
            currentSearchResults = data;
        
            // Mostrar resultados en la timeline
            showresultsearch(data);
        
            // Actualizar el contenedor de resultados con un mensaje
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--teal); margin-top: 15px;">
                    <h5 style="color: var(--teal); margin-top: 0;">B√∫squeda completada</h5>
                    <div style="font-size: 14px;">
                        Se encontraron ${data ? data.length : 0} resultados para la b√∫squeda por caracter√≠sticas.
                    </div>
                    <div style="font-size: 12px; color: var(--ink); margin-top: 10px;">
                        Los resultados se muestran en la lista de alertas a la derecha.
                    </div>
                </div>
            `;
        },
        error: (error) => {
            showGlobalLoader(false);
            log("Error en b√∫squeda por caracter√≠sticas:", error);
            resultsContainer.innerHTML = `
                <div style="background: var(--bg); padding: 15px; border-radius: 8px; border: 1px solid var(--orange); margin-top: 15px;">
                    <h5 style="color: var(--orange); margin-top: 0;">Error en la b√∫squeda</h5>
                    <div style="font-size: 14px;">
                        No se pudieron obtener resultados para la b√∫squeda por caracter√≠sticas.
                    </div>
                </div>
            `;
        }
    });
}

// Funciones de selecci√≥n (placeholders)
function selectVehicleByPlaca(placa) {
    alert('Seleccionado veh√≠culo con placa: ' + placa);
    // Aqu√≠ ir√≠a la l√≥gica para seleccionar el veh√≠culo
}

function selectByCaracteristicas() {
    alert('Mostrando detalle de coincidencias por caracter√≠sticas');
    // Aqu√≠ ir√≠a la l√≥gica para mostrar el detalle
}


// Variable global para almacenar selecciones
let multiSelectedItems = [];

// Funci√≥n para mostrar el modal de selecci√≥n m√∫ltiple
function showMultiSelectModal() {
    log("hola")
    const modal = document.getElementById('multiSelectOvl');
    modal.style.display = 'flex';

    // Cargar selecciones actuales del localStorage al estado temporal
    loadSavedSelections();
    tempSelectedItems = [...multiSelectedItems];

    // Cargar la lista de personas
    loadMultiSelectList();
}


// Funci√≥n para cargar la lista de selecci√≥n m√∫ltiple
function loadMultiSelectList() {
    const container = document.getElementById('multiSelectModalContent');
    container.innerHTML = '<div class="loading" style="text-align:center;padding:40px;"><div class="spinner"></div><div>Cargando lista de personas...</div></div>';

    callAPI({
        method: 'gestion/getiperson',
        params: {
            id_lista: 'all',
            nombre: 'all',
            ident_nro: 'all'
        },
        ok: function(data) {
            renderMultiSelectList(data, container);
        },
        error: function(error) {
            log("Error al cargar la lista de inter√©s:", error);
            container.innerHTML = '<div class="loading">Error al cargar la lista</div>';
        }
    });
}

// Funci√≥n para renderizar la lista de selecci√≥n m√∫ltiple
function renderMultiSelectList(data, container) {
    if (!data || data.length === 0) {
        container.innerHTML = '<div class="loading">No hay personas de inter√©s</div>';
        return;
    }

    // Usar tempSelectedItems en lugar de multiSelectedItems
    const currentSelectionIds = tempSelectedItems.map(item => item.id);

    // Mostrar selecciones actuales en la parte superior
    let html = `
        <div style="margin-bottom: 20px; padding: 15px; background: var(--bg); border-radius: 8px; border: 1px solid var(--teal);">
            <h5 style="color: var(--teal); margin-top: 0; margin-bottom: 10px;">Selecciones Actuales</h5>
            <div id="current-selections" style="max-height: 150px; overflow-y: auto;">
    `;

    if (tempSelectedItems.length === 0) {
        html += '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
    } else {
        tempSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                `<img src="/public/images/logowin.png" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">`;

            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${foto}
                        <div>
                            <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                            <div style="color: var(--ink); font-size: 12px;">${item.documento || 'N/A'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">‚úï</button>
                </div>
            `;
        });
    }

    html += `
            </div>
        </div>
        <div style="margin-bottom: 15px;">
            <input type="text" id="filterMultiSelect" placeholder="Buscar por nombre, apellido, documento..."
                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--teal); background: var(--panel); color: var(--ink);">
        </div>
        <div id="multiSelectTableContainer" style="max-height: 400px; overflow-y: auto;">
            <table class="table table-hover-1" id="multiSelectTable" style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background: rgba(34,230,217,0.1);">
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Seleccionar</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Foto</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Nombre</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Documento</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Edad</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Lista</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Raz√≥n</th>
                        <th style="padding: 10px; text-align: left; color: var(--teal); border-bottom: 1px solid rgba(34,230,217,0.3);">Fecha de reporte</th>
                    </tr>
                </thead>
                <tbody>
    `;

    data.forEach(item => {
        const isChecked = currentSelectionIds.includes(item.id);
        const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
            `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
            `<img src="/public/images/logowin.png" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">`;

        const time = new Date(item.fh_crea || item.fecha_robo || item.created_at);
        const formattedTime = time.toLocaleString('es-PE');

        html += `
            <tr class="multi-select-item" data-id="${item.id}" style="cursor: pointer; transition: background-color 0.3s ease; border-bottom: 1px solid rgba(34,230,217,0.1);">
                <td style="padding: 10px;">
                    <input type="checkbox" class="person-checkbox" data-id="${item.id}" ${isChecked ? 'checked' : ''}
                           style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--teal);">
                </td>
                <td style="padding: 10px;">${foto}</td>
                <td style="padding: 10px; color: var(--ink-strong);">${item.personame || item.name || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.documento || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.edad || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${obtainList(item.id_lista.toString(), 1) || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${item.descripcion || 'N/A'}</td>
                <td style="padding: 10px; color: var(--ink);">${formattedTime || 'N/A'}</td>
            </tr>
        `;
    });

    html += `
                </tbody>
            </table>
        </div>
    `;

    container.innerHTML = html;

    // Event listener para el filtro
    const filterInput = document.getElementById('filterMultiSelect');
    if (filterInput) {
        filterInput.addEventListener('input', function() {
            const filterText = this.value.toLowerCase();
            const rows = container.querySelectorAll('#multiSelectTable tbody tr');

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                let found = false;

                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(filterText)) {
                        found = true;
                    }
                });

                row.style.display = found ? '' : 'none';
            });
        });
    }

    // Event listeners para los checkboxes - MODIFICADO: Usar tempSelectedItems
    container.querySelectorAll('.person-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const id = this.getAttribute('data-id');
            const isChecked = this.checked;

            if (isChecked) {
                // Agregar a la selecci√≥n temporal
                const item = data.find(d => d.id == id);
                if (item && !tempSelectedItems.some(selected => selected.id == id)) {
                    tempSelectedItems.push(item);
                }
            } else {
                // Remover de la selecci√≥n temporal
                tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
            }

            // Actualizar la lista de selecciones actuales INMEDIATAMENTE (solo en el modal)
            updateTempSelectionsDisplay();
            
            // NO actualizar el localStorage ni las listas principales aqu√≠
        });
    });

    // Event listener para hacer clic en toda la fila
    container.querySelectorAll('.multi-select-item').forEach(row => {
        row.addEventListener('click', function(e) {
            if (e.target.type === 'checkbox') return;

            const checkbox = this.querySelector('.person-checkbox');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            }
        });

        // Efecto hover
        row.addEventListener('mouseenter', function() {
            this.style.backgroundColor = 'rgba(34, 230, 217, 0.1)';
        });

        row.addEventListener('mouseleave', function() {
            this.style.backgroundColor = '';
        });
    });

    // Event listeners para los botones de eliminar en la secci√≥n de selecciones actuales (temporal)
    container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromTempSelection(id);
            // Volver a renderizar la lista completa
            renderMultiSelectList(data, container);
        });
    });
}

// Funci√≥n para actualizar la visualizaci√≥n de selecciones temporales en el modal
function updateTempSelectionsDisplay() {
    const container = document.querySelector('#multiSelectModalContent #current-selections');
    if (!container) return;

    let html = '';

    if (tempSelectedItems.length === 0) {
        html = '<div style="color: var(--ink); font-size: 14px; text-align: center; padding: 10px;">No hay personas seleccionadas.</div>';
    } else {
        tempSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                `<img src="${item.foto}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;" onerror="this.onerror=null;this.src='/public/images/logowin.png';">` :
                `<img src="/public/images/logowin.png" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">`;

            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(34,230,217,0.2);">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${foto}
                        <div>
                            <div style="color: var(--ink-strong); font-size: 14px; font-weight: bold;">${item.personame || item.name || 'N/A'}</div>
                            <div style="color: var(--ink); font-size: 12px;">${item.documento || 'N/A'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection-temp" data-id="${item.id}" style="background: none; border: none; color: var(--orange); cursor: pointer; padding: 5px; border-radius: 3px;">‚úï</button>
                </div>
            `;
        });
    }

    container.innerHTML = html;

    // Re-a√±adir event listeners para los botones de eliminar
    container.querySelectorAll('.btn-remove-selection-temp').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromTempSelection(id);
            
            // Recargar la lista completa
            loadMultiSelectList();
        });
    });
}

// Funci√≥n para remover una persona de la selecci√≥n temporal
function removeFromTempSelection(id) {
    tempSelectedItems = tempSelectedItems.filter(item => item.id != id);
    updateTempSelectionsDisplay();
}

// Event listener para el bot√≥n de guardar - MODIFICADO
document.getElementById('saveMultiSelection').addEventListener('click', function() {
    // Guardar las selecciones temporales en la variable principal y en localStorage
    multiSelectedItems = [...tempSelectedItems];
    
    if (saveSelectionsToLocalStorage()) {
        // Actualizar todas las visualizaciones
        updateCurrentSelections();
        updateMapSelectedPersonsPanel();
        closeMultiSelectModal();
        
        // Mostrar mensaje de √©xito
        Swal.fire({
            icon: 'success',
            title: 'Selecci√≥n guardada',
            text: `Se han guardado ${multiSelectedItems.length} persona(s) de inter√©s`,
            timer: 2000,
            showConfirmButton: false
        });
    } else {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'No se pudo guardar la selecci√≥n'
        });
    }
});

// Funci√≥n para actualizar la lista de selecciones actuales
function updateCurrentSelections() {
    const container = document.getElementById('current-selections-list');
    if (!container) return;
    
    let html = '';
    
    if (multiSelectedItems.length === 0) {
        html = '<div class="selection-placeholder">Haga clic en "Seleccionar" para a√±adir a la lista personas de inter√©s</div>';
    } else {
        multiSelectedItems.forEach(item => {
            const foto = item.foto && item.foto.trim() && !item.foto.startsWith('@') ?
                item.foto : '/public/images/logowin.png';
            
            html += `
                <div class="selection-item" data-id="${item.id}">
                    <div class="selection-item-info">
                        <img src="${foto}" class="selection-item-photo" 
                             onerror="this.onerror=null;this.src='/public/images/logowin.png';">
                        <div class="selection-item-details">
                            <div class="selection-item-name">${item.personame || item.name || 'N/A'}</div>
                            <div class="selection-item-document">${item.documento || 'N/A'}</div>
                        </div>
                    </div>
                    <button type="button" class="btn-remove-selection" data-id="${item.id}" title="Eliminar de la lista">‚úï</button>
                </div>
            `;
        });
    }
    
    container.innerHTML = html;
    
    // A√±adir event listeners para los botones de eliminar - MEJORADO
    container.querySelectorAll('.btn-remove-selection').forEach(button => {
        button.addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeFromSelection(id);
            
            // Si el modal de selecci√≥n m√∫ltiple est√° abierto, actualizarlo tambi√©n
            const multiSelectModal = document.getElementById('multiSelectOvl');
            if (multiSelectModal && multiSelectModal.style.display === 'flex') {
                loadMultiSelectList();
            }
        });
    });
}

// Funci√≥n para guardar selecciones en localStorage
function saveSelectionsToLocalStorage() {
    try {
        localStorage.setItem('personasInteresSeleccionadas', JSON.stringify(multiSelectedItems));
        return true;
    } catch (e) {
        console.error('Error al guardar en localStorage:', e);
        return false;
    }
}

// La funci√≥n removeFromSelection permanece igual (para eliminaci√≥n desde el panel principal)
function removeFromSelection(id) {
    multiSelectedItems = multiSelectedItems.filter(item => item.id != id);
    updateCurrentSelections();
    saveSelectionsToLocalStorage();
    updateMapSelectedPersonsPanel();
}

// Funci√≥n para inicializar el contenedor de selecciones
function initSelectionsContainer() {
    const container = document.getElementById('selected-persons-container');
    if (container) {
        updateCurrentSelections();
    }
}

// Funci√≥n para cargar selecciones del localStorage
function loadSavedSelections() {
    try {
        const saved = localStorage.getItem('personasInteresSeleccionadas');
        if (saved) {
            multiSelectedItems = JSON.parse(saved);
        } else {
            multiSelectedItems = [];
        }
        initSelectionsContainer();
        // A√ëADIDO: Actualizar tambi√©n el panel del mapa
        updateMapSelectedPersonsPanel();
    } catch (e) {
        console.error('Error al cargar del localStorage:', e);
        multiSelectedItems = [];
        initSelectionsContainer();
        updateMapSelectedPersonsPanel();
    }
}

// Funci√≥n para cerrar el modal de selecci√≥n m√∫ltiple
function closeMultiSelectModal() {
    const modal = document.getElementById('multiSelectOvl');
    modal.style.display = 'none';
}

// Event listeners para el nuevo modal
document.getElementById('closeMultiSelectModal').addEventListener('click', closeMultiSelectModal);
document.getElementById('multiSelectOvl').addEventListener('click', function(e) {
    if (e.target === this) {
        closeMultiSelectModal();
    }
});

// Event listener para el bot√≥n de guardar
document.getElementById('saveMultiSelection').addEventListener('click', function() {
    if (saveSelectionsToLocalStorage()) {
        
        updateMapSelectedPersonsPanel();
        closeMultiSelectModal();
    } else {
        alert('Error al guardar la selecci√≥n');
    }
});

// ==========================
// Funci√≥n para verificar NUEVAS alertas contra personas de inter√©s
// ==========================
function checkAlertsAgainstInteres(nuevasAlertas) {
    // Cargar selecciones guardadas
    loadSavedSelections();
    
    if (!multiSelectedItems || multiSelectedItems.length === 0 || !nuevasAlertas || nuevasAlertas.length === 0) {
        return null;
    }
    
    let lastMatchingAlert = null;
    let lastTimestamp = 0;
    
    nuevasAlertas.forEach(alert => {
        multiSelectedItems.forEach(persona => {
            if ((persona.id && alert.matched_ident && persona.id.toString() === alert.matched_ident.toString()) ||
                (persona.id && alert.dni && persona.id.toString() === alert.dni.toString())) {
                
                const alertTime = new Date(alert.init_time_frame).getTime();
                if (alertTime > lastTimestamp) {
                    lastTimestamp = alertTime;
                    lastMatchingAlert = alert;
                }
                
                // A√ëADIDO: Activar resaltado de la persona
                highlightPersonWithAlert(persona.id);
            }
        });
    });
    
    // NUEVO: Esperar 5 segundos antes de mostrar la alerta
    /*
    if (lastMatchingAlert) {
        setTimeout(() => {
            showAlertDetails(lastMatchingAlert);
        }, 5000);
    }
    */
    
    
    return lastMatchingAlert;
}

// Variable global para almacenar temporizadores de alertas activas
let activeAlertTimers = {};

// Funci√≥n para actualizar el panel de personas de inter√©s en el mapa
function updateMapSelectedPersonsPanel() {
    const panelBody = document.getElementById('selected-persons-map-body');
    if (!panelBody) return;
    
    if (multiSelectedItems.length === 0) {
        panelBody.innerHTML = '<div class="selection-placeholder">No hay personas seleccionadas</div>';
        return;
    }
    
    let html = '';
    multiSelectedItems.forEach(person => {
        const photoUrl = person.foto && !person.foto.startsWith('@') ? 
            person.foto : '/public/images/logowin.png';
        
        html += `
            <img src="${photoUrl}" 
                 class="selected-person-photo" 
                 data-id="${person.id}"
                 title="${person.personame || person.name || 'N/A'}"
                 onerror="this.onerror=null;this.src='/public/images/logowin.png';">
        `;
    });
    
    panelBody.innerHTML = html;
}

function highlightPersonWithAlert(personId) {
    const photoElement = document.querySelector(`.selected-person-photo[data-id="${personId}"]`);
    if (photoElement) {
        photoElement.classList.add('active-alert');
        
        // Limpiar timer anterior si existe
        if (activeAlertTimers[personId]) {
            clearTimeout(activeAlertTimers[personId]);
        }
        
        // Establecer timer para quitar el resaltado despu√©s de 10 segundos
        activeAlertTimers[personId] = setTimeout(() => {
            photoElement.classList.remove('active-alert');
            delete activeAlertTimers[personId];
        }, 10000);
    }
}

function initMapSelectedPersonsPanel() {
    const panel = document.getElementById('selected-persons-map-panel');
    const toggleBtn = panel.querySelector('.selected-persons-map-toggle');
    
    toggleBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        panel.classList.toggle('minimized');
        toggleBtn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
    });
    
    // Actualizar el panel inicialmente
    updateMapSelectedPersonsPanel();
}

function getColors(){
    callAPI({
        method: 'gestion/color',
        ok: function (vals) {
            const seltxtcolorinf = $('#txtcolorinf');
            vals.forEach(obj => {
                seltxtcolorinf.append(`<option value="${obj.id}"> ${obj.name}</option>`);
            });
            const seltxtcolorsup = $('#txtcolorsup');
            vals.forEach(obj => {
                seltxtcolorsup.append(`<option value="${obj.id}"> ${obj.name}</option>`);
            });
        }
    });
}

//actualizaci√≥n cada 30 segundos
// Al final del script, a√±ade:
let alertInterval;

function startAlertUpdates() {
    // Actualizar cada 30 segundos
    alertInterval = setInterval(() => {
        getAlertas();
    }, 30000);
}

function stopAlertUpdates() {
    if (alertInterval) {
        clearInterval(alertInterval);
    }
}

// Iniciar actualizaciones autom√°ticas cuando entre en fullscreen
document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) {
        //stopAlertUpdates();
    } else {
        //startAlertUpdates();
    }
});

// ==========================
// Funci√≥n para normalizar coordenadas del edificio - NUEVA
// ==========================
function normalizarCoordenadasEdificio(edificio) {
    if (!edificio || !edificio.pisos) return edificio;
    
    // Encontrar los l√≠mites globales del edificio
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    
    // Primera pasada: encontrar l√≠mites
    edificio.pisos.forEach(piso => {
        piso.ambientes.forEach(ambiente => {
            if (ambiente.vertices && Array.isArray(ambiente.vertices)) {
                ambiente.vertices.forEach(vertice => {
                    if (Array.isArray(vertice) && vertice.length >= 2) {
                        const x = vertice[0];
                        const z = vertice.length >= 3 ? vertice[2] : vertice[1];
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    }
                });
            }
        });
    });
    
    // Si no se encontraron coordenadas v√°lidas, retornar sin cambios
    if (minX === Infinity || maxX === -Infinity || minZ === Infinity || maxZ === -Infinity) {
        log("No se pudieron determinar los l√≠mites para normalizaci√≥n");
        return edificio;
    }
    
    // Calcular centro y escala
    const centroX = (minX + maxX) / 2;
    const centroZ = (minZ + maxZ) / 2;
    const rangoX = maxX - minX;
    const rangoZ = maxZ - minZ;
    const escala = 200 / Math.max(rangoX, rangoZ);
    
    log(`Normalizando coordenadas: Centro(${centroX}, ${centroZ}), Escala: ${escala}`);
    
    // Segunda pasada: aplicar normalizaci√≥n
    edificio.pisos.forEach(piso => {
        piso.ambientes.forEach(ambiente => {
            if (ambiente.vertices && Array.isArray(ambiente.vertices)) {
                ambiente.vertices = ambiente.vertices.map(vertice => {
                    if (Array.isArray(vertice) && vertice.length >= 2) {
                        const x = (vertice[0] - centroX) * escala;
                        const y = vertice[1]; // Mantener la altura original
                        const z = (vertice.length >= 3 ? vertice[2] : vertice[1] - centroZ) * escala;
                        return [x, y, z];
                    }
                    return vertice;
                });
            }
        });
    });
    
    return edificio;
}

// ==========================
// Funci√≥n para crear una persona en un ambiente
// ==========================
function crearPersonaEnAmbiente(ambiente, nombrePiso) {
    if (!ambiente.vertices || ambiente.vertices.length === 0) {
        return null;
    }
    
    // Calcular √°rea del ambiente para posicionamiento
    const vertices = ambiente.vertices;
    const xCoords = vertices.map(v => v[0]);
    const zCoords = vertices.map(v => v[2]);
    
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minZ = Math.min(...zCoords);
    const maxZ = Math.max(...zCoords);
    
    // Posici√≥n aleatoria dentro del ambiente
    const x = minX + Math.random() * (maxX - minX);
    const z = minZ + Math.random() * (maxZ - minZ);
    const y = vertices[0][1]; // Altura del piso
    
    return {
        id: `${ambiente.nombre}_${Date.now()}_${Math.random()}`,
        posicion: [x, y, z],
        velocidad: [
            (Math.random() - 0.5) * 2 * (configPersonas.velocidadMin + Math.random() * (configPersonas.velocidadMax - configPersonas.velocidadMin)),
            0,
            (Math.random() - 0.5) * 2 * (configPersonas.velocidadMin + Math.random() * (configPersonas.velocidadMax - configPersonas.velocidadMin))
        ],
        ambiente: ambiente.nombre,
        piso: nombrePiso,
        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
        tiempoCambioDireccion: 0
    };
}

// ==========================
// Funci√≥n auxiliar para encontrar ambiente por nombre
// ==========================
function encontrarAmbientePorNombre(nombreAmbiente, nombrePiso) {
    if (!edificio.pisos) return null;
    
    for (const piso of edificio.pisos) {
        if (piso.nombre === nombrePiso) {
            for (const ambiente of piso.ambientes) {
                if (ambiente.nombre === nombreAmbiente) {
                    return ambiente;
                }
            }
        }
    }
    return null;
}

// Configuraci√≥n para personas en tiempo real
const configPersonasTiempoReal = {
    radioPersona: 1.2,
    maxPersonasPorCamara: 10,
    tiempoExpiracion: 30000 // 30 segundos
};


let cameraIds = [];
let renderstop = 0;

// ==========================
// Funci√≥n para determinar jerarqu√≠a de proximidad
// ==========================
function determinarJerarquiaProximidad(persons_info) {
    return persons_info
        .map(persona => ({
            ...persona,
            area: calcularAreaBbox(persona.bbox)
        }))
        .sort((a, b) => b.area - a.area) // Orden descendente por √°rea
        .map((persona, index) => ({
            ...persona,
            ordenProximidad: index + 1,
            distanciaRelativa: index + 1
        }));
}

// ==========================
// Funci√≥n para calcular √°rea del bbox
// ==========================
function calcularAreaBbox(bbox) {
    const ancho = bbox.x2 - bbox.x1;
    const alto = bbox.y2 - bbox.y1;
    return ancho * alto;
}

// ==========================
// Funci√≥n para encontrar subzona por c√°mara
// ==========================
function encontrarSubzonaPorCamara(camara) {
    if (!edificio.pisos) return null;
    if(camara.camera_id="UTEC32"){
        log("datos de c√°mara",camara)
        log("datos de edificio",edificio)
    }
    for (const piso of edificio.pisos) {
        for (const ambiente of piso.ambientes) {
            // BUSCAR EXCLUSIVAMENTE POR SUBZONAS (no cuadrantes)
            if (ambiente.tipo === 'subzona' && 
                ambiente.id_subzona && camara.id_subzona && 
                ambiente.id_subzona.toString() === camara.id_subzona.toString()) {
                return ambiente;
            }
        }
    }
    return null;
}

// ==========================
// Funci√≥n para generar posiciones en subzona seg√∫n proximidad
// ==========================
function generarPosicionesEnSubzona(personasOrdenadas, subzona, camara) {
    const vertices = subzona.vertices;
    const xCoords = vertices.map(v => v[0]);
    const zCoords = vertices.map(v => v[2]);
    
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minZ = Math.min(...zCoords);
    const maxZ = Math.max(...zCoords);
    
    const [camX, camY, camZ] = camara.coords;
    
    return personasOrdenadas.map((persona, index) => {
        // Personas m√°s cercanas (√°rea grande) se posicionan m√°s cerca de la c√°mara
        const factorProximidad = 1 - (index / Math.max(1, personasOrdenadas.length - 1));
        
        // Calcular posici√≥n basada en la proximidad
        const radioMaximo = Math.min(maxX - minX, maxZ - minZ) * 0.4;
        const distancia = radioMaximo * factorProximidad;
        
        // √Ångulo aleatorio alrededor de la c√°mara
        const angulo = Math.random() * 2 * Math.PI;
        
        const posX = camX + Math.cos(angulo) * distancia;
        const posZ = camZ + Math.sin(angulo) * distancia;
        
        // Asegurar que est√° dentro de los l√≠mites de la subzona
        const xFinal = Math.max(minX, Math.min(maxX, posX));
        const zFinal = Math.max(minZ, Math.min(maxZ, posZ));
        
        return {
            id: `${camara.camera_id}_${persona.tracking_id}`,
            tracking_id: persona.tracking_id,
            cameraId: camara.camera_id,
            posicion: [xFinal, camY, zFinal],
            color: index === 0 ? "#FFD700" : "#22e6d9", // Dorado para el m√°s cercano
            piso: subzona.piso,
            areaBbox: persona.area,
            ordenProximidad: persona.ordenProximidad,
            precision: persona.accuracy,
            timestamp: Date.now(),
            velocidad: [
                (Math.random() - 0.5) * 0.1,
                0,
                (Math.random() - 0.5) * 0.1
            ]
        };
    });
}

// ==========================
// Funci√≥n para procesar detecciones de una c√°mara
// ==========================
function procesarDeteccionesCamara(frameData) {
    if (!frameData || !frameData.persons_info || !Array.isArray(frameData.persons_info)) {
        return;
    }
    
    // Buscar la c√°mara en nuestros datos
    const camara = camerasData.find(cam => cam.id.toString() === frameData.id.toString());
    if (!camara) {
        log("C√°mara no encontrada en camerasData: " + frameData.camera_id);
        return;
    }
    
    // CORRECCI√ìN: Buscar la SUBZONA de la c√°mara
    const subzona = encontrarSubzonaPorCamara(camara);
    if (!subzona) {
        log(`No se encontr√≥ subzona para c√°mara ${frameData.camera_id} (id_subzona: ${camara.id_subzona})`);
        return;
    }
    
    // Filtrar detecciones antiguas de esta c√°mara
    personasEnFrames = personasEnFrames.filter(persona => 
        persona.camera_id !== frameData.camera_id
    );
    
    // Procesar nuevas detecciones de personas dentro de la SUBZONA
    frameData.persons_info.forEach(deteccion => {
        if (deteccion.category_name === 'person' && deteccion.bbox) {
            const persona = crearPersonaDesdeDeteccionEnSubzona(camara, deteccion, frameData.epoch_frame, subzona);
            if (persona) {
                personasEnFrames.push(persona);
            }
        }
    });
    
    // Limitar el n√∫mero total de personas para evitar sobrecarga
    if (personasEnFrames.length > 500) {
        personasEnFrames = personasEnFrames.slice(-100);
    }
    
    // Forzar re-renderizado
    render();
}

// ==========================
// Funci√≥n para crear persona desde detecci√≥n en SUBZONA - NUEVA
// ==========================
function crearPersonaDesdeDeteccionEnSubzona(camara, deteccion, epoch, subzona) {
    try {
        const bbox = deteccion.bbox;
        
        // Calcular posici√≥n basada en la SUBZONA de la c√°mara
        const posicion = calcularPosicionDesdeBoundingBoxEnSubzona(camara, bbox, subzona);
        
        return {
            id: `persona_${camara.camera_id}_${deteccion.tracking_id}_${epoch}`,
            camera_id: camara.camera_id,
            posicion: posicion,
            timestamp: epoch,
            bbox: bbox,
            accuracy: deteccion.accuracy || 0,
            tracking_id: deteccion.tracking_id,
            color: configPersonasFrame.colorPersona,
            piso: subzona.piso || camara.piso,
            resaltado: false
        };
    } catch (error) {
        console.log("Error al crear persona desde detecci√≥n en subzona:", error);
        return null;
    }
}

// ==========================
// Funci√≥n para crear objeto persona desde detecci√≥n
// ==========================
function crearPersonaDesdeDeteccion(camara, deteccion, epoch) {
    try {
        const bbox = deteccion.bbox;
        
        // Calcular posici√≥n basada en la c√°mara y el bounding box
        const posicion = calcularPosicionDesdeBoundingBoxEnSubzona(camara, bbox);
        
        return {
            id: `persona_${camara.camera_id}_${deteccion.tracking_id}_${epoch}`,
            camara_id: camara.camera_id,
            posicion: posicion,
            timestamp: epoch, // Usar el epoch del frame
            bbox: bbox,
            accuracy: deteccion.accuracy || 0,
            tracking_id: deteccion.tracking_id,
            color: configPersonasFrame.colorPersona,
            piso: camara.piso,
            resaltado: false
        };
    } catch (error) {
        console.log("Error al crear persona desde detecci√≥n:", error);
        return null;
    }
}

// ==========================
// Funci√≥n para calcular posici√≥n 3D desde bounding box
// ==========================
function calcularPosicionDesdeBoundingBox(camara, bbox) {
    // Obtener coordenadas base de la c√°mara
    const [camX, camY, camZ] = camara.coords;
    
    // Calcular centro del bounding box en coordenadas normalizadas (0-1)
    // Suponiendo una resoluci√≥n de imagen t√≠pica de 1920x1080
    const imageWidth = 1920;
    const imageHeight = 1080;
    
    const centroX = ((bbox.x1 + bbox.x2) / 2) / imageWidth;
    const centroY = ((bbox.y1 + bbox.y2) / 2) / imageHeight;
    
    // Calcular tama√±o relativo del bounding box
    const anchoRelativo = (bbox.x2 - bbox.x1) / imageWidth;
    const altoRelativo = (bbox.y2 - bbox.y1) / imageHeight;
    const areaRelativa = anchoRelativo * altoRelativo;
    
    // Personas m√°s grandes (m√°s cerca de la c√°mara) se posicionan m√°s cerca
    // Personas m√°s peque√±as (m√°s lejos) se posicionan m√°s lejos
    const factorDistancia = Math.max(0.1, Math.min(1, areaRelativa * 5));
    
    // CORRECCI√ìN: La posici√≥n vertical (centroY) afecta la PROFUNDIDAD (Z), no la altura (Y)
    // - Personas en la parte superior de la imagen est√°n M√ÅS LEJOS (Z mayor)
    // - Personas en la parte inferior de la imagen est√°n M√ÅS CERCA (Z menor)
    const offsetZ = (centroY - 0.5) * 20 * factorDistancia;
    
    // La posici√≥n horizontal (centroX) afecta la posici√≥n lateral (X)
    const offsetX = (centroX - 0.5) * 15 * factorDistancia;
    
    // CORRECCI√ìN: La altura (Y) debe ser CONSTANTE (altura del piso)
    // No debe variar con la posici√≥n en la imagen
    const alturaPersona = camY; // Misma altura que la c√°mara o ajustada al piso
    
    return [
        camX + offsetX,           // X: izquierda/derecha desde la c√°mara
        alturaPersona,            // Y: ALTURA CONSTANTE (nivel del piso)
        camZ + offsetZ            // Z: PROFUNDIDAD (cerca/lejos de la c√°mara)
    ];
}

function calcularPosicionDesdeBoundingBoxEnSubzona(camara, bbox, subzona) {
    if (!subzona || !subzona.vertices) {
        return calcularPosicionDesdeBoundingBox(camara, bbox);
    }
    
    // Obtener coordenadas base de la c√°mara
    const [camX, camY, camZ] = camara.coords;
    
    // Calcular centro del bounding box en coordenadas normalizadas (0-1)
    const imageWidth = 1920;
    const imageHeight = 1080;
    
    const centroX = ((bbox.x1 + bbox.x2) / 2) / imageWidth;
    const centroY = ((bbox.y1 + bbox.y2) / 2) / imageHeight;
    
    // Calcular tama√±o relativo del bounding box para distancia aproximada
    const anchoRelativo = (bbox.x2 - bbox.x1) / imageWidth;
    const altoRelativo = (bbox.y2 - bbox.y1) / imageHeight;
    const areaRelativa = anchoRelativo * altoRelativo;
    const factorDistancia = Math.max(0.1, Math.min(1, areaRelativa * 5));
    
    // Obtener los l√≠mites de la SUBZONA
    const vertices = subzona.vertices;
    const xCoords = vertices.map(v => v[0]);
    const zCoords = vertices.map(v => v[2]);
    
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minZ = Math.min(...zCoords);
    const maxZ = Math.max(...zCoords);
    
    // CORRECCI√ìN: Mapear la posici√≥n en la imagen a coordenadas dentro de la SUBZONA COMPLETA
    // Considerar que la c√°mara cubre toda la subzona
    const margen = 0.05; // Margen reducido para usar casi toda la subzona
    const rangoX = (maxX - minX) * (1 - 2 * margen);
    const rangoZ = (maxZ - minZ) * (1 - 2 * margen);
    
    // Posici√≥n X: mapeo directo del frame a la subzona
    // centroX (0-1) -> minX a maxX
    const x = minX + margen * (maxX - minX) + centroX * rangoX;
    
    // Posici√≥n Z: invertir centroY y mapear a la subzona
    // centroY (0-1) -> minZ a maxZ (invertido: arriba en imagen = m√°s lejos en Z)
    const z = minZ + margen * (maxZ - minZ) + (1 - centroY) * rangoZ;
    
    // Altura constante (nivel del piso)
    const y = vertices[0][1];
    
    // CORRECCI√ìN: Aplicar factor de distancia para posicionar personas m√°s cercanas/lejanas
    // dentro de la misma subzona
    const centroSubzonaX = (minX + maxX) / 2;
    const centroSubzonaZ = (minZ + maxZ) / 2;
    
    // Personas m√°s grandes (m√°s cerca) se posicionan m√°s cerca del centro de la subzona
    // Personas m√°s peque√±as (m√°s lejos) se posicionan m√°s cerca de los bordes
    const ajusteX = (x - centroSubzonaX) * (1 - factorDistancia * 0.3);
    const ajusteZ = (z - centroSubzonaZ) * (1 - factorDistancia * 0.3);
    
    return [
        centroSubzonaX + ajusteX,   // X ajustado por distancia dentro de la subzona
        y,                          // Y constante (altura del piso)
        centroSubzonaZ + ajusteZ    // Z ajustado por distancia dentro de la subzona
    ];
}

// ==========================
// Funci√≥n para obtener frames de personas
// ==========================
function obtenerFramesPersonas() {
    const uniqueCameraIds = [...new Set(cameraIds)];
    uniqueCameraIds.forEach(cameraId => {
        if (!cameraId || cameraId === "Selecciona c√°mara") return;

        callAPI({
            method: 'dashboards/lastframe',
            params: { camera_id: cameraId },
            ok: function(data) {
                if (data && data.foto) {
                    if (renderstop == 1) { renderstop = 0; return; } 
                    
                    // CORRECCI√ìN: Procesar las personas detectadas del frame en SUBZONAS
                    if (data.persons_info && Array.isArray(data.persons_info) && data.persons_info.length > 0) {
                        procesarDeteccionesCamara(data);
                    }
                    
                } else {
                    console.warn(`No se encontr√≥ foto para c√°mara ${cameraId}:`, data);
                }
            },
            error: function(error) {
                console.error(`Error al obtener frame para c√°mara ${cameraId}:`, error);
            }
        });
    });
}

// ==========================
// Funci√≥n para procesar frames y posicionar personas en subzonas
// ==========================
function procesarFramesPersonas(frames) {
    const currentTime = Date.now();
    
    // Si no hay frames, salir
    if (!frames || !Array.isArray(frames) || frames.length === 0) {
        // Limpiar personas si no hay frames por m√°s de 10 segundos
        if (currentTime - lastFrameUpdate > 10000) {
            personasEnFrames = [];
            updatePersonCountLegend();
            render();
        }
        return;
    }
    
    lastFrameUpdate = currentTime;
    
    frames.forEach(frame => {
        if (!frame.camera_id || !frame.tracking_id) return;
        
        // Buscar la c√°mara en nuestros datos
        const camara = camerasData.find(cam => cam.camera_id === frame.camera_id);
        if (!camara) {
            log(`C√°mara no encontrada: ${frame.camera_id}`);
            return;
        }
        
        // CORRECCI√ìN: BUSCAR LA SUBZONA CORRESPONDIENTE A LA C√ÅMARA POR id_subzona
        let subzonaEncontrada = null;
        let pisoEncontrado = null;
        
        for (const piso of edificio.pisos) {
            for (const ambiente of piso.ambientes) {
                // BUSCAR POR id_subzona (NO por id_cuadrante)
                if ((ambiente.tipo === 'subzona') && 
                    ambiente.id_subzona && camara.id_subzona && 
                    ambiente.id_subzona.toString() === camara.id_subzona.toString()) {
                    subzonaEncontrada = ambiente;
                    pisoEncontrado = piso.nombre;
                    break;
                }
            }
            if (subzonaEncontrada) break;
        }
        
        if (!subzonaEncontrada) {
            log("adios");
            log(`No se encontr√≥ subzona para c√°mara ${frame.camera_id} (id_subzona: ${camara.id_subzona})`);
            return;
        }
        
        // Calcular posici√≥n dentro de la subzona usando el frame
        let posicion;
        if (frame.bbox) {
            // Si tenemos bounding box, usar c√°lculo m√°s preciso dentro de la SUBZONA
            posicion = calcularPosicionDesdeBoundingBoxEnSubzona(camara, frame.bbox, subzonaEncontrada);
        } else {
            // Si no hay bbox, usar m√©todo basado en la subzona
            posicion = calcularPosicionEnSubzona(subzonaEncontrada, frame);
        }
        
        if (!posicion) return;
        
        // VERIFICAR SI ES PERSONA DE INTER√âS PARA RESALTADO PERMANENTE
        let esPersonaDeInteres = false;
        if (multiSelectedItems && multiSelectedItems.length > 0) {
            esPersonaDeInteres = verificarSiEsPersonaDeInteres(frame);
        }
        
        // Buscar persona existente o crear nueva
        const personaExistenteIndex = personasEnFrames.findIndex(p => 
            p.tracking_id === frame.tracking_id && p.camera_id === frame.camera_id
        );
        
        if (personaExistenteIndex !== -1) {
            // Actualizar persona existente - MANTENER RESALTADO SI ERA DE INTER√âS
            const resaltadoAnterior = personasEnFrames[personaExistenteIndex].resaltado;
            personasEnFrames[personaExistenteIndex] = {
                ...personasEnFrames[personaExistenteIndex],
                posicion: posicion,
                timestamp: currentTime,
                accuracy: frame.accuracy || Math.random() * 30 + 70,
                piso: pisoEncontrado || "Desconocido",
                camera_id: frame.camera_id,
                resaltado: resaltadoAnterior || esPersonaDeInteres
            };
        } else {
            // Crear nueva persona
            const nuevaPersona = {
                tracking_id: frame.tracking_id,
                posicion: posicion,
                timestamp: currentTime,
                accuracy: frame.accuracy || Math.random() * 30 + 70,
                piso: pisoEncontrado || "Desconocido",
                camera_id: frame.camera_id,
                resaltado: esPersonaDeInteres
            };
            
            personasEnFrames.push(nuevaPersona);
        }
    });
    
    // Limpiar personas antiguas (m√°s de 30 segundos sin actualizar)
    personasEnFrames = personasEnFrames.filter(persona => 
        currentTime - persona.timestamp <= 30000
    );
    
    // Actualizar leyenda
    updatePersonCountLegend();
    
    // Forzar re-renderizado
    render();
}

// ==========================
// Funci√≥n para calcular posici√≥n aleatoria dentro de una subzona
// ==========================
function calcularPosicionEnSubzona(subzona, frame) {
    if (!subzona.vertices || subzona.vertices.length < 3) {
        log(`Subzona ${subzona.nombre} no tiene v√©rtices v√°lidos`);
        return null;
    }
    
    const vertices = subzona.vertices;
    
    // Calcular el centroide del pol√≠gono de la SUBZONA
    let sumX = 0, sumZ = 0;
    vertices.forEach(vertex => {
        sumX += vertex[0];
        sumZ += vertex[2];
    });
    
    const centerX = sumX / vertices.length;
    const centerZ = sumZ / vertices.length;
    
    // Usar el tracking_id para generar una posici√≥n "seudo-aleatoria" pero consistente
    // dentro de la SUBZONA completa
    const seed = parseInt(frame.tracking_id.replace(/\D/g, '')) || 0;
    const randomX = (seed % 100) / 100;
    const randomZ = ((seed * 13) % 100) / 100;
    
    // Calcular los l√≠mites del pol√≠gono de la SUBZONA
    const xCoords = vertices.map(v => v[0]);
    const zCoords = vertices.map(v => v[2]);
    
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minZ = Math.min(...zCoords);
    const maxZ = Math.max(...zCoords);
    
    // Posici√≥n dentro del √°rea de la SUBZONA (evitando bordes extremos)
    const margin = 0.1; // 10% de margen
    const rangeX = (maxX - minX) * (1 - 2 * margin);
    const rangeZ = (maxZ - minZ) * (1 - 2 * margin);
    
    const x = minX + margin * (maxX - minX) + randomX * rangeX;
    const z = minZ + margin * (maxZ - minZ) + randomZ * rangeZ;
    const y = vertices[0][1]; // Mantener la altura del piso
    
    // Verificar que la posici√≥n est√© dentro del pol√≠gono de la SUBZONA
    if (!estaDentroDelPoligono([x, z], vertices)) {
        // Si no est√° dentro, usar el centroide
        return [centerX, y, centerZ];
    }
    
    return [x, y, z];
}

function estaDentroDelPoligono(punto, polygon) {
    const [x, y] = punto;
    let dentro = false;
    
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][2];
        const xj = polygon[j][0], yj = polygon[j][2];
        
        const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) dentro = !dentro;
    }
    
    return dentro;
}

function verificarSiEsPersonaDeInteres(frame) {
    if (!multiSelectedItems || multiSelectedItems.length === 0) return false;
    
    // Aqu√≠ implementar√≠as la l√≥gica para comparar el frame con las personas de inter√©s
    // Por ejemplo, comparando documento, caracter√≠sticas, etc.
    // Por ahora, simulamos que algunas personas son de inter√©s basado en tracking_id
    return multiSelectedItems.some(persona => 
        persona.tracking_id === frame.tracking_id || 
        (persona.documento && frame.documento && persona.documento === frame.documento)
    );
}

// ==========================
// Funci√≥n para resaltar personas permanentemente
// ==========================
function resaltarPersonaPermanentemente(trackingId) {
    const personaIndex = personasEnFrames.findIndex(p => p.tracking_id === trackingId);
    if (personaIndex !== -1) {
        personasEnFrames[personaIndex].resaltado = true;
        render();
    }
}

// ==========================
// Funci√≥n para quitar resaltado permanente
// ==========================
function quitarResaltadoPermanente(trackingId) {
    const personaIndex = personasEnFrames.findIndex(p => p.tracking_id === trackingId);
    if (personaIndex !== -1) {
        personasEnFrames[personaIndex].resaltado = false;
        render();
    }
}

</script>